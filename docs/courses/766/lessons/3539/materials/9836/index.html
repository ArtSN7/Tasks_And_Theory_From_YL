<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Что такое QT и PyQT. Знакомство </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок QT Знакомство</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Что такое&nbsp;QT и&nbsp;PyQT. Знакомство</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Графический интерфейс</a></li>
<li><a class="material__link" href="#2">Установка и&nbsp;настройка</a></li>
<li><a class="material__link" href="#3">Первые шаги в PyQT</a></li>
<li><a class="material__link" href="#4">Кто отправил сигнал</a></li>
<li><a class="material__link" href="#5">Открытие других форм</a></li>
<li><a class="material__link" href="#6">Итоги</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке рассказывается о&nbsp;графическом интерфейсе и&nbsp;разных способах его реализации, а&nbsp;также начинается знакомство с&nbsp;библиотекой PyQT5.</p>
<p>Разбирается настройка окружения и&nbsp;примеры работы с&nbsp;основными элементами интерфейса.</p>
</section>
<section class="material__chapter">
<h2 id="1">Графический интерфейс</h2>
<p>Раньше большинство ваших программ запускались и&nbsp;выполнялись из&nbsp;консоли, то&nbsp;есть и&nbsp;ввод, и&nbsp;вывод осуществлялся с&nbsp;использованием интерфейса командной строки (CLI&nbsp;&mdash; Command Line Interface), без создания привычного пользовательского интерфейса (вы&nbsp;немного могли &laquo;поиграть&raquo; с&nbsp;графическим интерфейсом на&nbsp;дополнительном уроке по&nbsp;библиотеке <var>tkinter</var>).</p>
<p>Для программ, которые не&nbsp;предполагают того, что их&nbsp;будет использовать неподготовленный к&nbsp;работе с&nbsp;командной строкой пользователь, текстового интерфейса хватает. Существует большое количество консольных утилит, предназначенных для программистов или системных администраторов, но&nbsp;часто в&nbsp;жизни разработчика наступает момент, когда разработанную программу надо передать незнакомому с&nbsp;консолью пользователю. Графический интерфейс (GUI&nbsp;&mdash; Graphical User Interface) более &laquo;дружелюбный&raquo; к&nbsp;пользователям, а&nbsp;если в&nbsp;программе необходимо отображать не&nbsp;только текст, но&nbsp;и&nbsp;графическую или мультимедийную информацию, его использование становится необходимостью.</p>
<p>Рассмотрим основные понятия концепции GUI. Допустим, есть знакомый нам текстовый редактор. Когда мы&nbsp;нажимаем клавишу&nbsp;Х, возникает событие &laquo;Нажата клавиша&nbsp;Х&raquo;. В&nbsp;то&nbsp;же время внутри программы запускается <strong>обработчик</strong>, который проверяет, какая клавиша нажата, какая раскладка выбрана и&nbsp;так далее. Затем он&nbsp;выполняет <strong>действие</strong>: выводит нужный символ на&nbsp;экран. Общий принцип работы можно представить в&nbsp;виде такой несложной схемы:.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-1-1.svg" width="680" height="auto" /></div>
<p>Для языка программирования Python есть много способов создания приложений с&nbsp;графическим интерфейсом, в&nbsp;частности, уже знакомая вам библиотека tkinter. Она используется в&nbsp;большом числе кроссплатформенных приложений, написанных на&nbsp;Python. Мы&nbsp;абсолютно ничего не&nbsp;имеем против tkinter, но&nbsp;в&nbsp;этом разделе курса будем рассматривать библиотеку PyQT, так как ее&nbsp;возможности значительно богаче. Разобраться с&nbsp;другими библиотеками для построения графических интерфейсов вы&nbsp;можете самостоятельно, так как они имеют похожий принцип работы. Кроме того, на&nbsp;схеме Событие &rarr; Обработчик &rarr; Действие в&nbsp;том или ином виде построены почти все современные библиотеки, предназначенные для взаимодействия с&nbsp;пользователем. В&nbsp;этом вы&nbsp;сможете убедиться самостоятельно в&nbsp;следующих разделах курса.</p>
<p>Что&nbsp;же такое PyQT? Для начала разберемся, что такое QT. Это написанная на&nbsp;C++ библиотека с&nbsp;классами для создания графического интерфейса. Библиотека получилась настолько удачной, что начала собирать вокруг себя большое сообщество программистов, которые разрабатывали приложения не&nbsp;только на&nbsp;C++, но&nbsp;и&nbsp;на&nbsp;других языках программирования. Это привело к&nbsp;тому, что и&nbsp;для других языков программирования стали появляться свои библиотеки-&laquo;обертки&raquo; для&nbsp;QT. Для Python это <strong>PyQT</strong>.</p>
</section>
<section class="material__chapter">
<h2 id="2">Установка и&nbsp;настройка</h2>
<p>PyQt устанавливается так&nbsp;же, как и&nbsp;любая другая библиотека в&nbsp;Python:</p>
<pre><code>pip install PyQT5
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Первые шаги в PyQT</h2>
<p>В&nbsp;терминологии PyQT (и&nbsp;достаточно большого числа других библиотек создания GUI) все графические приложения состоят из&nbsp;виджетов.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Виджет</strong></p>
<p>Виджет&nbsp;&mdash; минимальный элемент графического интерфейса пользователя.</p>
</section>
<p>В&nbsp;библиотеке PyQT5 существует множество модулей, но&nbsp;чаще других используется <strong>QtWidgets</strong>. Именно в&nbsp;нем находятся классы, соответствующие различным элементам интерфейса.</p>
<p>Напишем простейшую программу с&nbsp;использованием библиотеки PyQT5:</p>
<pre><code class="language-python">import sys

# Импортируем из PyQt5.QtWidgets классы для создания приложения и виджета
from PyQt5.QtWidgets import QApplication, QWidget


# Унаследуем наш класс от простейшего графического примитива QWidget
class Example(QWidget):
    def __init__(self):
        # Надо не забыть вызвать инициализатор базового класса
        super().__init__()
        # В метод initUI() будем выносить всю настройку интерфейса,
        # чтобы не перегружать инициализатор
        self.initUI()

    def initUI(self):
        # Зададим размер и положение нашего виджета,
        self.setGeometry(300, 300, 300, 300)
        # А также его заголовок
        self.setWindowTitle('Первая программа')


if __name__ == '__main__':
    # Создадим класс приложения PyQT
    app = QApplication(sys.argv)
    # А теперь создадим и покажем пользователю экземпляр
    # нашего виджета класса Example
    ex = Example()
    ex.show()
    # Будем ждать, пока пользователь не завершил исполнение QApplication,
    # а потом завершим и нашу программу
    sys.exit(app.exec())
</code></pre>
<p>Если мы&nbsp;запустим эту программу, увидим такое окно:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-res-1-1.png" width="302" height="auto" /></div>
<p>Давайте разберемся, что происходит в&nbsp;этой программе. Обратите внимание на&nbsp;наш класс&nbsp;&mdash; <var>Example</var>. Он&nbsp;наследуется от&nbsp;базового класса <var>QWidget</var>, который определяет простейшее окно. От&nbsp;него наследуется много встроенных виджетов.</p>
<p>Первое, что можно увидеть в&nbsp;классе,&nbsp;&mdash; перегруженный конструктор.</p>
<p><code>super().__init__()</code> &mdash; эта строка вызывает конструктор родительского класса. Потом вызывается метод класса с&nbsp;названием <var>initUI</var>.</p>
<p>Разумеется, инициализацию интерфейса можно реализовать и&nbsp;в&nbsp;инициализаторе класса, но&nbsp;хорошей практикой считается вынос этой функциональности в&nbsp;отдельный метод класса с&nbsp;названием <var>initUI</var>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>PEP&nbsp;8</strong></p>
<p>Обратите внимание: метод <var>initUI</var> называется с&nbsp;нарушением правил PEP&nbsp;8. Как мы&nbsp;говорили ранее, такое отступление возможно для сохранения совместимости с&nbsp;используемой библиотекой, а&nbsp;так как библиотека&nbsp;QT изначально написана на&nbsp;C++&nbsp;с именованием методов в&nbsp;стиле camelCase, то&nbsp;<var>initUI</var>&nbsp;&mdash; допустимое название метода в&nbsp;классе, который унаследован от&nbsp;<var>QWidget</var>.</p>
</section>
<p>В&nbsp;<var>initUI</var> мы&nbsp;определяем положение и&nbsp;размеры нашего окна методом <var>setGeometry</var>. Первые два параметра&nbsp;&mdash; X&nbsp;и&nbsp;У&nbsp;&mdash; координаты левого верхнего угла формы относительно левого верхнего угла нашего монитора. Оставшиеся&nbsp;&mdash; ширина и&nbsp;высота виджета. Методом <var>setWindowTitle</var> задаем заголовок нашего окна.</p>
<p>Мы&nbsp;создали класс, но&nbsp;пока его не&nbsp;используем. Чтобы начать с&nbsp;ним работать, необходимо куда-то разместить наш виджет.</p>
<p>Для этого нужно создать приложение&nbsp;&mdash; объект класса <var>QApplication</var>, строка <code>app =
        QApplication(sys.argv)</code> как раз отвечает за&nbsp;это. Несмотря на&nbsp;то, что после инициализации переменная <var>app</var> используется только один раз, она необходима. Все скрытое от&nbsp;пользователя и&nbsp;разработчика взаимодействие программы с&nbsp;операционной системой возможно только благодаря этому классу. Передавать значение <var>sys.argv</var> в&nbsp;конструктор <var>QApplication</var> не&nbsp;обязательно, можно передать любой список, даже пустой. Но&nbsp;приведенная запись является хорошим тоном создания PyQT-приложений, так как она позволит корректно обрабатывать запуск приложения с&nbsp;параметрами командной строки (о&nbsp;них мы&nbsp;поговорим позднее).</p>
<p>Затем мы&nbsp;создаем экземпляр нашего класса: <code>ex = Example()</code>. Все готово, можно запускать. Метод <code>show()</code> отображает наш виджет в&nbsp;приложение. Но&nbsp;отобразить недостаточно, надо запустить цикл обработки событий. Для этого вызываем метод <code>app.exec()</code>.</p>
<p>В&nbsp;последней строке программы этот вызов &laquo;обернут&raquo; в&nbsp;<code>sys.exit</code>. Это сделано для корректного завершения программы.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-1-2.svg" width="680" height="auto" /></div>
<p>Но&nbsp;просто пустое окно&nbsp;&mdash; это скучно, начнем добавлять туда виджеты. Первый на&nbsp;очереди&nbsp;&mdash; знакомая нам кнопка. Класс, который необходим для работы с&nbsp;ней, называется <var>QPushButton</var>.</p>
<pre><code class="language-python">import sys

from PyQt5.QtWidgets import QApplication, QWidget, QPushButton


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 300, 300)
        self.setWindowTitle('Вторая программа')
        # Создаем кнопку.
        # Передаем 2 параметра:
        # надпись и виджет, на котором будет размещена кнопка
        btn = QPushButton('Кнопка', self)
        # Изменяем размер кнопки. Теперь он 100 на 100 пикселей
        btn.resize(100, 100)
        # Размещаем кнопку на родительском виджете
        # по координатам (100, 100)
        btn.move(100, 100)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())

</code></pre>
<p>Вспомним картинку выше: у&nbsp;любого виджета, кроме базового, должен быть &laquo;родитель&raquo;. Когда мы&nbsp;добавляем кнопку, &laquo;родителем&raquo; выступает наш виджет окна. Поэтому при объявлении кнопки мы&nbsp;указываем не&nbsp;только текст, но&nbsp;и&nbsp;экземпляр класса <var>QWidget</var> (или, как в&nbsp;нашем случае, его наследника).</p>
<p>Метод <var>resize</var> позволяет изменить размеры кнопки. А&nbsp;с&nbsp;помощью метода <var>move</var> мы&nbsp;указываем расположение нашей кнопки в&nbsp;виджете-&laquo;родителе&raquo;. Запустим программу и&nbsp;убедимся, что кнопка появилась.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-res-1-2.png" width="302" height="auto" /></div>
<p>На&nbsp;кнопку можно даже понажимать, но&nbsp;пока безрезультатно. Сделаем ее&nbsp;полезной&nbsp;&mdash; добавим функциональность. В&nbsp;уже рассмотренных нами терминах&nbsp;&mdash; добавим обработчик события &laquo;нажатие на&nbsp;кнопку&raquo;.</p>
<pre><code class="language-python">import sys

from PyQt5.QtWidgets import QApplication, QWidget, QPushButton


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 300, 300)
        self.setWindowTitle('Третья программа')

        self.btn = QPushButton('Кнопка', self)
        self.btn.resize(100, 100)
        self.btn.move(100, 100)
        # присоединим к событию нажатия на кнопку обработчик self.hello()
        self.btn.clicked.connect(self.hello)

    def hello(self):
        # метод setText() используется для задания надписи на кпопке
        self.btn.setText('Привет')


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Что изменилось по&nbsp;сравнению с&nbsp;предыдущей программой? Во-первых, теперь <var>btn</var>&nbsp;&mdash; это поле класса, а&nbsp;не&nbsp;просто локальная переменная метода, как было в&nbsp;прошлый раз. Поэтому добраться до&nbsp;кнопки мы&nbsp;теперь можем не&nbsp;только из&nbsp;метода <var>initUI</var>, а&nbsp;из&nbsp;любого места внутри класса нашей формы (и&nbsp;даже из&nbsp;любого кода, который имеет доступ к&nbsp;объекту нашей формы). А&nbsp;во-вторых, добавилась функциональность: при нажатии на&nbsp;кнопку надпись на&nbsp;ней изменяется на&nbsp;строку &laquo;Привет&raquo;.</p>
<p><code>self.btn.clicked.connect(self.hello)</code>&nbsp;&mdash; что значит эта фраза в&nbsp;переводе на&nbsp;человеческий язык? &laquo;Если получишь <strong>событие clicked</strong> от&nbsp;<strong>объекта self.btn</strong>, вызови <strong>обработчик self.hello()</strong>&raquo;. В&nbsp;нем с&nbsp;помощью метода <var>setText</var> мы&nbsp;меняем текст на&nbsp;кнопке.</p>
<p>Но&nbsp;эта кнопка фактически &laquo;одноразовая&raquo;, поскольку текст на&nbsp;кнопке изменится только после первого нажатия. При последующих нажатиях&nbsp;он, конечно&nbsp;же, тоже меняется, ведь метод <code>hello()</code> вызывается, но&nbsp;мы, как пользователи, этого не&nbsp;видим.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-res-1-3.png" width="302" height="auto" /></div>
<p>Если говорить про библиотеку&nbsp;QT, в&nbsp;ней концепция &laquo;Событие &rarr; Обработчик &rarr; Действие&raquo; реализована с&nbsp;некоторыми особенностями, поэтому введена своя терминология&nbsp;&mdash; <strong>сигналы и&nbsp;слоты</strong> (хотя если вы&nbsp;будете использовать более общие названия, вас все равно поймут).</p>
<p><strong>Сигнал</strong> вырабатывается, когда происходит определенное событие. <strong>Слот</strong>&nbsp;&mdash; это функция, которая <strong>ловит</strong> определенный сигнал. Все классы, наследуемые от&nbsp;<var>QObject</var> или его дочерних классов (например, уже знакомые нам <var>QWidget</var> и&nbsp;<var>QPushButton</var>) могут содержать сигналы и&nbsp;слоты. Сигналы вырабатываются объектами, когда они изменяют свое состояние так, что это может заинтересовать другие объекты. При этом сами объекты не&nbsp;знают и&nbsp;не&nbsp;заботятся о&nbsp;том, что у&nbsp;его сигнала может не&nbsp;быть получателя. Только класс, который определяет сигнал, (или его дочерние классы) могут вырабатывать сигнал.</p>
<p><strong>Слоты</strong>&nbsp;&mdash; обычные функции (или методы класса), которые могут быть использованы для получения сигналов (хотя никто не&nbsp;запрещает вам вызывать эти функции и&nbsp;просто так). Точно так&nbsp;же, как объект не&nbsp;знает ничего о&nbsp;получателях своих сигналов, функция-слот ничего не&nbsp;знает о&nbsp;сигналах, которые к&nbsp;ней подключены.</p>
<p>Мы&nbsp;можем подключать к&nbsp;одному слоту сколько угодно сигналов, а&nbsp;один слот может быть подключен к&nbsp;неограниченному количеству сигналов (даже несколько раз к&nbsp;одному и&nbsp;тому&nbsp;же сигналу, тогда при появлении сигнала функция-слот выполнится столько раз, сколько была подключена). Кроме того, возможно подключать сигнал к&nbsp;другому сигналу, что вызовет выработку второго сигнала немедленно после появления первого.</p>
<p>В&nbsp;качестве аналогии можно привести радиотрансляцию с&nbsp;радиостанции. Сигнал&nbsp;&mdash; это такая трансляция, и&nbsp;радиостанции неизвестно, сколько радиоприемников-слотов будут настроены на&nbsp;волну, когда будет трансляция. Но&nbsp;все настроенные на&nbsp;нужную волну приемники получат сигнал.</p>
<p>Но&nbsp;довольно теории, давайте выводить на&nbsp;кнопке не&nbsp;один и&nbsp;тот&nbsp;же текст каждый раз, а, например, количество нажатий на&nbsp;нее. Никаких дополнительных атрибутов в&nbsp;нашем классе нам не&nbsp;понадобится&nbsp;&mdash; хранить информацию будем прямо в&nbsp;&laquo;кнопке&raquo;.</p>
<pre><code class="language-python">import sys

from PyQt5.QtWidgets import QApplication, QWidget, QPushButton


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 300, 300)
        self.setWindowTitle('Четвёртая программа')

        self.btn = QPushButton('0', self)
        self.btn.resize(100, 100)
        self.btn.move(100, 100)
        # Подпишем функцию-слот self.count() на сигнал clicked кнопки btn
        self.btn.clicked.connect(self.count)

    def count(self):
        # Не забываем, что надпись на кнопке - это текст.
        self.btn.setText(f"{int(self.btn.text()) + 1}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Метод <code>text()</code> возвращает строку&nbsp;&mdash; текущую надпись на&nbsp;кнопке.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-res-1-4.png" width="302" height="auto" /></div>
<p>Для отображения данных в&nbsp;PyQT есть и&nbsp;более подходящие виджеты. Для текстовых данных лучше использовать <var>QLabel</var>, а&nbsp;для цифр есть красивый виджет <var>QLCDNumber</var>, который имитирует дисплей калькулятора.</p>
<pre><code class="language-python">import sys

from PyQt5.QtWidgets import QApplication, QWidget, QPushButton
from PyQt5.QtWidgets import QLCDNumber, QLabel


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 400, 400)
        self.setWindowTitle('Пятая программа')

        self.btn = QPushButton('Кнопка', self)
        # Подстроим размер кнопки под надпись на ней
        self.btn.resize(self.btn.sizeHint())
        self.btn.move(100, 150)
        # Обратите внимание: функцию не надо вызывать :)
        self.btn.clicked.connect(self.inc_click)

        self.label = QLabel(self)
        # Текст задается также, как и для кнопки
        self.label.setText("Количество нажатий на кнопку")
        self.label.move(80, 30)

        self.LCD_count = QLCDNumber(self)
        self.LCD_count.move(110, 80)

        self.count = 0

    def inc_click(self):
        self.count += 1
        # В QLCDNumber для отображения данных используется метод display()
        self.LCD_count.display(self.count)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Теперь для хранения будем использовать отдельное поле&nbsp;&mdash; <var>count</var>. Для задания значения у&nbsp;<var>QLCDNumber</var> используется метод <var>display</var>, а&nbsp;для <var>QLabel</var>&nbsp;&mdash; <var>setText</var>, как и&nbsp;у&nbsp;<var>QPushButton</var>.</p>
<p>Код <code>self.btn.resize(self.btn.sizeHint())</code> подстраивает размеры кнопки под размер надписи на&nbsp;ней, чтобы не&nbsp;возникла ситуация, что часть надписи заходила за&nbsp;границу этого виджета.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-res-1-5.png" width="302" height="auto" /></div>
<p><var>QLCDNumber</var>, кроме чисел, умеет показывать следующие символы: O&nbsp;(нулем), S&nbsp;(с&nbsp;помощью&nbsp;5), g&nbsp;(с&nbsp;помощью&nbsp;9), минус, точку, A, B, C, D, E, F, h, H, L, o, P, r, u, U, Y, кавычку, пробел. То&nbsp;есть вполне возможно написать на&nbsp;<var>QLCDNumber</var> какое-либо сообщение, например Error. Те&nbsp;символы, которые <var>QLCDNumber</var> отобразить не&nbsp;может, он&nbsp;просто заменяет на&nbsp;пробелы.</p>
<p>Как вы&nbsp;понимаете, отображать данные пользователю нашей программы&nbsp;&mdash; это только половина дела, не&nbsp;менее важно получать от&nbsp;него данные. Для этого существуют несколько виджетов. Если пользователь должен ввести одну строку, то&nbsp;для получения ее&nbsp;получения прекрасно подойдет <var>QLineEdit</var>.</p>
<pre><code class="language-python">import sys

from PyQt5.QtWidgets import QApplication, QWidget, QPushButton
from PyQt5.QtWidgets import QLabel, QLineEdit


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 400, 400)
        self.setWindowTitle('Шестая программа')

        self.btn = QPushButton('Кнопка', self)
        self.btn.resize(self.btn.sizeHint())
        self.btn.move(100, 150)
        self.btn.clicked.connect(self.hello)

        self.label = QLabel(self)
        self.label.setText("Привет, неопознанный лев")
        self.label.move(40, 30)

        self.name_label = QLabel(self)
        self.name_label.setText("Введите имя: ")
        self.name_label.move(40, 90)

        self.name_input = QLineEdit(self)
        self.name_input.move(150, 90)

    def hello(self):
        name = self.name_input.text()  # Получим текст из поля ввода
        self.label.setText(f"Привет, {name}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())

</code></pre>
<p>Метод <code>text()</code> виджета <var>QLineEdit</var> позволяет получить введенную пользователем строчку.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-res-1-6.png" width="302" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="4">Кто отправил сигнал</h2>
<p>Давайте рассмотрим более детально, как происходит взаимодействие между виджетами. Когда пользователь нажимает на&nbsp;кнопку, возникает <strong>сигнал</strong>, который обрабатывается некоторой функцией-слотом. Но&nbsp;если у&nbsp;нас одна функция-обработчик для нескольких кнопок, как понять, на&nbsp;какую из&nbsp;них нажал пользователь?</p>
<p>Чтобы определить, кто является источником сигнала, у виджета есть метод <code>.sender()</code>.</p>
<p>Рассмотрим пример такой программы.</p>
<pre><code class="language-python">import sys

from PyQt5.QtWidgets import QWidget, QApplication, QPushButton, QLabel


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 300, 200)
        self.setWindowTitle('Кто отправил сигнал')

        self.button_1 = QPushButton(self)
        self.button_1.move(90, 40)
        self.button_1.setText("Кнопка 1")
        self.button_1.clicked.connect(self.run)

        self.button_2 = QPushButton(self)
        self.button_2.move(90, 80)
        self.button_2.setText("Кнопка 2")
        self.button_2.clicked.connect(self.run)

        self.label = QLabel(self)
        self.label.setText("Пока никто не отправлял")
        self.label.move(50, 120)

        self.show()

    def run(self):
        self.label.setText(self.sender().text())
        print(self.sender().text())


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())

</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-1/qt-res-1-7.png" width="299" height="auto" /></div>
<p>В&nbsp;этой программе слот <code>run()</code> привязан к&nbsp;сигналам от&nbsp;двух кнопок. Независимо от&nbsp;того, кто его вызвал, метод печатает в&nbsp;консоль текст нажатой кнопки, которую мы&nbsp;получаем с&nbsp;помощью <code>sender()</code>.</p>
</section>
<section class="material__chapter">
<h2 id="5">Открытие других форм</h2>
<p>Разумеется, далеко не&nbsp;всегда приложение ограничивается одной формой. В&nbsp;<strong>настоящих</strong> программах, как минимум, есть еще одна&nbsp;&mdash; &laquo;О&nbsp;программе&raquo;, а&nbsp;также формы с&nbsp;настройками, диалоги открытия и&nbsp;сохранения файлов и&nbsp;так далее. Конечно, PyQT дает возможность в&nbsp;нашем приложении создавать формы из&nbsp;других форм. Обычно (но&nbsp;далеко не&nbsp;всегда) для главной формы приложения выбирают класс <var>QMainWindow</var>, а&nbsp;для дочерних форм&nbsp;&mdash; класс <var>QWidget</var>. Чтобы создать форму из&nbsp;другой формы, достаточно сделать объект нужного нам класса и&nbsp;вызвать у&nbsp;него метод <var>show</var>.</p>
<pre><code class="language-python">import sys

from PyQt5.QtWidgets import QApplication, QWidget, QPushButton
from PyQt5.QtWidgets import QMainWindow, QLabel


class FirstForm(QMainWindow):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 300, 300)
        self.setWindowTitle('Главная форма')

        self.btn = QPushButton('Другая форма', self)
        self.btn.resize(self.btn.sizeHint())
        self.btn.move(100, 100)

        self.btn.clicked.connect(self.open_second_form)

    def open_second_form(self):
        self.second_form = SecondForm(self, "Данные для второй формы")
        self.second_form.show()


class SecondForm(QWidget):
    def __init__(self, *args):
        super().__init__()
        self.initUI(args)

    def initUI(self, args):
        self.setGeometry(300, 300, 300, 300)
        self.setWindowTitle('Вторая форма')
        self.lbl = QLabel(args[-1], self)
        self.lbl.adjustSize()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = FirstForm()
    ex.show()
    sys.exit(app.exec())

</code></pre>
<p>Обратите внимание на&nbsp;два момента:</p>
<ol>
<li>Мы&nbsp;сохраняем созданную форму в&nbsp;атрибут нашей родительской формы для того, чтобы иметь возможность управлять ею&nbsp;из&nbsp;других методов. И&nbsp;для того, чтобы сборщик мусора Python не&nbsp;удалил ее&nbsp;случайно как объект, на&nbsp;который нет ссылок.</li>
<li>В&nbsp;инициализаторе дочерней формы, помимо <var>self</var>, есть еще <code>*args</code>, куда мы&nbsp;можем помещать информацию, которую хотим передать из&nbsp;родительской формы в&nbsp;дочернюю. Тут мы&nbsp;передаем ссылку на&nbsp;объект-родитель (его обычно передают первым) и&nbsp;сообщение, которое мы&nbsp;будет отображать на&nbsp;второй форме в&nbsp;<var>QLabel</var>.</li>
</ol>
</section>
<section class="material__chapter">
<h2 id="6">Итоги</h2>
<p>На&nbsp;этом уроке мы&nbsp;изучили работу с&nbsp;основными виджетами:</p>
<ul>
<li>QWidget</li>
<li>QPushButton</li>
<li>QLCDNumber</li>
<li>QLabel</li>
<li>QLineEdit</li>
</ul>
<p>Но&nbsp;мы&nbsp;рассмотрели далеко не&nbsp;все доступные методы. Информацию о&nbsp;других методах можно посмотреть на&nbsp;<a class="material__link" href="https://doc.qt.io/qt-5/qtwidgets-module.html" target="_blank" rel="noopener noreferrer">официальном сайте QT</a>. Обратите внимание: документация написана для языка&nbsp;C++, так что нужно обращать внимание лишь на&nbsp;названия методов и&nbsp;параметры, но&nbsp;не&nbsp;на&nbsp;синтаксис примеров.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>