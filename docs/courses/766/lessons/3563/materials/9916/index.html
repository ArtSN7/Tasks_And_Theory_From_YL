<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Понятие исключения. Обработка исключений. Собственные исключения </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок QT3. Исключения</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Понятие исключения. Обработка исключений. Собственные исключения</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Что такое ошибка или исключение</a></li>
<li><a class="material__link" href="#2">Cтек вызовов в&nbsp;Python</a></li>
<li><a class="material__link" href="#3">Работа с&nbsp;кодами возврата</a></li>
<li><a class="material__link" href="#4">Трудности работы с&nbsp;кодами возврата</a></li>
<li><a class="material__link" href="#5">Обработка исключений</a></li>
<li><a class="material__link" href="#6">Методики LBYL и&nbsp;EAFP</a></li>
<li><a class="material__link" href="#7">Полный синтаксис блока try...except</a></li>
<li><a class="material__link" href="#8">Создание пользовательских типов ошибок</a></li>
<li><a class="material__link" href="#9">Перехват системных исключений</a></li>
<li><a class="material__link" href="#10">Конструкция assert</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Урок рассказывает о&nbsp;работе с&nbsp;исключениями в&nbsp;современных языках программирования, в&nbsp;частности, в&nbsp;языке Python. Сравнение методики исключений с&nbsp;методикой кодов возврата. Построение собственных классов исключений и&nbsp;их&nbsp;наследование, методики LBYL и&nbsp;EAFP.</p>
</section>
<section class="material__chapter">
<h2 id="1">Что такое ошибка или исключение</h2>
<p>У&nbsp;вашей программы есть &laquo;главная&raquo; ветка&nbsp;&mdash; то, что относится к&nbsp;основному алгоритму. Именно ей&nbsp;вы&nbsp;уделяете основное внимание.</p>
<p>Во&nbsp;время работы программы иногда возникают непредвиденные обстоятельства (&laquo;упс, что-то пошло не&nbsp;так&raquo;)&nbsp;&mdash; как правило, внешние. Программа должна их&nbsp;верно обрабатывать. Мы&nbsp;будем называть такие обстоятельства&nbsp;<strong>ошибками</strong> или <strong>исключениями</strong>.</p>
<p>Чтобы было понятнее, рассмотрим пример алгоритма посещения магазина.</p>
<p>Родители посылают дочь в&nbsp;магазин и&nbsp;просят купить молока некоторого бренда ценой 40&nbsp;рублей. Это и&nbsp;есть для девочки основной алгоритм в&nbsp;данной ситуации. Однако могут возникнуть непредвиденные обстоятельства: именно этот магазин сейчас закрыт (нужно&nbsp;ли тратить время и&nbsp;идти в&nbsp;следующий?), такого молока в&nbsp;продаже нет (вернуться обратно или купить другое?), молоко подорожало (все равно брать?), заканчивается срок годности (это важно?) и&nbsp;так далее.</p>
<p>Все это можно обсудить сразу, но&nbsp;нужно соблюдать меру и&nbsp;не&nbsp;раздувать алгоритм покупок до&nbsp;инструкции на&nbsp;30&nbsp;страниц, включающей подробные указания на&nbsp;случай стихийных бедствий.</p>
<p>Лучше всего решить, что делать в&nbsp;тех случаях, которые легко предугадать. Все остальное свести к&nbsp;универсальному решению &laquo;вернуться обратно&raquo; или &laquo;позвонить родителям и&nbsp;спросить&raquo;.</p>
<p>То&nbsp;же самое и&nbsp;в&nbsp;программировании.</p>
<p>Например, вы&nbsp;написали алгоритм, скачивающий плейлист из&nbsp;ВКонтакте в&nbsp;папку на&nbsp;компьютере. Запустили его. Что&nbsp;же может пойти не&nbsp;так?</p>
<ul>
<li>Проблемы с&nbsp;доступом в&nbsp;Интернет</li>
<li>Сервера ВКонтакте работают нестабильно и&nbsp;не&nbsp;отвечают</li>
<li>Если алгоритм дает имена файлам по&nbsp;названиям треков, то&nbsp;ему могут попасться недопустимые символы</li>
<li>Закончилось свободное место на&nbsp;диске</li>
<li>...</li>
</ul>
<p>Есть несколько путей:</p>
<ol>
<li>В&nbsp;любом непредвиденном случае программа остановится, а&nbsp;вы&nbsp;увидите сообщение об&nbsp;ошибке (так Python работает по&nbsp;умолчанию)</li>
<li>Вы&nbsp;добавляете автоматическую обработку некоторых известных вам проблем</li>
<li>Программа будет каждый раз спрашивать вас о&nbsp;том, как поступить в&nbsp;возникшей нештатной ситуации</li>
<li>Комбинация этих решений</li>
</ol>
<p>Если мы&nbsp;хотим, чтобы программа работала с&nbsp;широким диапазоном входных данных и&nbsp;внешних условий, то&nbsp;надо учитывать исключения.</p>
<p>Отметим еще раз, что по&nbsp;умолчанию от&nbsp;необработанной ошибки программа на&nbsp;Python немедленно останавливается и&nbsp;выводит сообщение:</p>
<pre><code class="language-python">for i in range(10):
    print(10 / i)
</code></pre>
<pre><samp>Traceback (most recent call last):
  File "/home/02.py", line 2, in &lt;module&gt;
    print(10 / i)
ZeroDivisionError: division by zero</samp></pre>
</section>
<section class="material__chapter">
<h2 id="2">Cтек вызовов в&nbsp;Python</h2>
<p>Теперь поговорим немного про стек вызовов (traceback). Программа на&nbsp;Python состоит из&nbsp;блоков, входящих один в&nbsp;другой, поэтому у&nbsp;любой точки программы есть вложенность. Давайте посмотрим, какую информацию дает стек вызовов, когда указывает на&nbsp;место ошибки.</p>
<p>Например, вычисление частного двух чисел, введенных пользователем. Отметим, что огромное количество ошибок происходит из-за того, что пользователь ввел неправильные данные.</p>
<p>Проведем три эксперимента:</p>
<ol>
<li>Введем правильные числа</li>
<li>Введем второе число, равное&nbsp;0</li>
<li>Введем не&nbsp;число, а&nbsp;строку</li>
</ol>
<pre><code class="language-python">def div(a, b):
    return a / b


print(div(4, 10))
</code></pre>
<pre><samp>0.4</samp></pre>
<pre><code class="language-python">def run_division():
    a = float(input("Введите a: "))
    b = float(input("Введите b: "))
    print(div(a, b))
</code></pre>
<p>Запустим программу и&nbsp;посмотрим на&nbsp;результат:</p>
<pre><samp>Введите a: 45
Введите b: 11
4.090909090909091</samp></pre>
<p>Снова выполним программу и&nbsp;проанализируем результат:</p>
<pre><samp>Введите a: 45
Введите b: 0
Traceback (most recent call last):
  File "/home/01.py", line 11, in &lt;module&gt;
    run_division()
  File "/home/01.py", line 8, in run_division
    print(div(a, b))
  File "/home/01.py", line 2, in div
    return a / b
ZeroDivisionError: float division by zero</samp></pre>
<p>И еще раз:</p>
<pre><samp>Введите a: fd
Traceback (most recent call last):
  File "/home/01.py", line 11, in &lt;module&gt;
    run_division()
  File "/home/01.py", line 6, in run_division
    a = float(input("Введите a: "))
ValueError: could not convert string to float: 'fd'</samp></pre>
<p>Печать стека вызовов в&nbsp;момент аварийного завершения программы помогает нам найти ошибку. Мы&nbsp;слишком понадеялись на&nbsp;то, что пользователь введет только вещественные числа в&nbsp;европейском формате (с&nbsp;точкой в&nbsp;качестве десятичного разделителя). Кроме того, не&nbsp;все помнят, что на&nbsp;0&nbsp;делить нельзя (по&nbsp;крайней мере, в&nbsp;Python).</p>
</section>
<section class="material__chapter">
<h2 id="3">Работа с&nbsp;кодами возврата</h2>
<p>Этот тип работы с&nbsp;исключениями первым появился в&nbsp;истории программирования. Его следы остались в&nbsp;некоторых функциях Python&nbsp;&mdash; языка, который унаследовал механику у&nbsp;С.</p>
<p>Например, метод <var>find</var> строки ищет позицию вхождения подстроки в&nbsp;заданную строчку. Он&nbsp;возвращает либо номер позиции, либо &minus;1, если такой подстроки нет.</p>
<pre><code class="language-python">s = "Привет, мир!"
print(s.find(","))
print(s.find("Д"))
</code></pre>
<p>Программа выведет:</p>
<pre><samp>6
-1</samp></pre>
<p>Из-за того, что в&nbsp;исходной строке не&nbsp;было символа &laquo;Д&raquo;, нам было возвращено значение &minus;1. Это и&nbsp;есть <strong>код возврата</strong>. Так как любая функция в&nbsp;Python возвращает значения, мы&nbsp;можем использовать их&nbsp;для кодирования информации об&nbsp;ошибке.</p>
<p>Для каждой ошибки можно придумать свой код возврата. Коды не&nbsp;должны совпадать с&nbsp;возможными обычными ответами.</p>
<p>В&nbsp;больших информационных системах у&nbsp;каждой ситуации, в&nbsp;том числе и&nbsp;у&nbsp;нештатной, есть свой номер. Например, у&nbsp;ошибок в&nbsp;Интернете: 404, 503. А&nbsp;200&nbsp;&mdash; это код, возвращаемый серверами при успешном выполнении задания.</p>
<p>С&nbsp;кодами возврата&nbsp;вы, наверняка, достаточно часто сталкивались на&nbsp;предыдущих двух уроках при использовании библиотеки PyQT, так как&nbsp;QT написана на&nbsp;C++.&nbsp;Мы&nbsp;пишем строчку <code>sys.exit(app.exec())</code> при создании приложения в&nbsp;том числе и&nbsp;для того, чтобы в&nbsp;случае ошибки получить код возврата библиотеки PyQT.</p>
<p>Давайте рассмотрим еще один пример использования кодов возврата.</p>
<p>У&nbsp;нас есть приложение с&nbsp;возможностью оплаты картой каких-либо товаров или услуг (например, премиум-подписки). Просим пользователя ввести номер карты.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/card.svg" width="600" height="auto" /></div>
<p>Примерно вот так может выглядеть <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/pyqt/pay.ui" target="_blank" rel="noopener noreferrer">форма</a> такого приложения:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/pyqt-3-pay.png" width="616" height="auto" /></div>
<p>Программа для этого может быть тоже очень простой:</p>
<pre><code class="language-python">import sys

from PyQt5 import uic
from PyQt5.QtWidgets import QWidget, QApplication


class PayForm(QWidget):
    def __init__(self):
        super(PayForm, self).__init__()
        uic.loadUi('pay.ui', self)
        self.payButton.clicked.connect(self.get_data)

    def get_data(self):
        card_num = self.cardData.text()
        print(card_num)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    form = PayForm()
    form.show()
    sys.exit(app.exec())
</code></pre>
<p>Но&nbsp;здесь нас подстерегает несколько неожиданностей. Пользователь не&nbsp;знает формата, в&nbsp;котором нужен номер карты. Просто цифры без пробела? Или группами по&nbsp;четыре с&nbsp;пробелами, как на&nbsp;карте?</p>
<p>Можно написать ему об&nbsp;этом:</p>
<pre><code class="language-python">self.hintLabel.setText('Введите номер карты (16 цифр без пробелов):')
</code></pre>
<p>Но&nbsp;и&nbsp;теперь мы&nbsp;не&nbsp;застрахованы от&nbsp;ошибок&nbsp;&mdash; пользователь может набрать букву&nbsp;O вместо нуля, перепутать цифры, не&nbsp;прочитать внимательно инструкцию и&nbsp;ввести пробелы или просто начать целенаправленно взламывать нашу программу, набирая заведомо некорректные данные (это называется фаззинг (fuzzing).</p>
<p>Ситуацию усложняет&nbsp;то, что номера карт&nbsp;&mdash; не&nbsp;просто случайный набор из&nbsp;16&nbsp;цифр.</p>
<p>Первая цифра обозначает тип карты. Например, номера карт Visa начинаются с&nbsp;4, а&nbsp;MasterCard&nbsp;&mdash; c&nbsp;5. Следующие пять обозначают банк, который выпустил карту. Другие девять цифр&nbsp;&mdash; уникальный номер конкретной карты. Последнюю, шестнадцатую цифру, называют контрольной.</p>
<p>Номер должен проходить проверку специальным алгоритмом Лу́на. Его придумал немецкий инженер Ганс Питер Лун.</p>
<p>Чтобы проверить, нужно взять номер карты и&nbsp;вычислить для него специальное число&nbsp;&mdash; контрольную сумму. Вот как это делают:</p>
<ol>
<li>Каждую цифру в&nbsp;нечетной позиции, начиная с&nbsp;первого числа слева, умножаем на&nbsp;два. Если результат больше&nbsp;9, складываем обе цифры этого двузначного числа. Или вычитаем из&nbsp;него 9&nbsp;и&nbsp;получаем тот&nbsp;же результат. Например, если у&nbsp;нас&nbsp;18, при сложении 1 + 8&nbsp;получится&nbsp;9, при вычитании 18&nbsp;&mdash; 9&nbsp;&mdash; тоже&nbsp;9</li>
<li>Затем мы&nbsp;складываем все результаты и&nbsp;цифры на&nbsp;четных позициях&nbsp;&mdash; в&nbsp;том числе и&nbsp;последнюю контрольную цифру</li>
<li>Если сумма кратна&nbsp;10, то&nbsp;номер карты правильный. Именно последняя контрольная цифра делает общую сумму кратной&nbsp;10</li>
</ol>
<p>Когда банки выпускают новые карты и&nbsp;генерируют номера для них, контрольную шестнадцатую цифру они подбирают так, чтобы алгоритм Лу́на давал кратное десяти число. Поэтому у&nbsp;всех банковских карт в&nbsp;мире номера с&nbsp;такой контрольной суммой.</p>
<p>Когда пользователь вводит номер своей карты, мы&nbsp;применяем алгоритм Луна. Если получится число, не&nbsp;кратное 10,&nbsp;&mdash; значит, пользователь ошибся.</p>
<p>Допустим, мы&nbsp;получаем номер карты от&nbsp;пользователя, а&nbsp;потом эта карта поступает в&nbsp;обработку (не&nbsp;забудьте поменять слот при нажатии на&nbsp;кнопку на&nbsp;<var>process_data</var>):</p>
<pre><code class="language-python">def get_card_number(self):
    card_num = self.cardData.text()
    return card_num


def process_data(self):
    number = self.get_card_number()
    self.errorLabel.setText("Ваша карта обрабатывается...")
</code></pre>
<p>На&nbsp;этом этапе мы&nbsp;никак не&nbsp;контролируем пользователя. Проверяем номер карты по&nbsp;алгоритму Луна:</p>
<pre><code class="language-python">def get_card_number(self):
    card_num = self.cardData.text()
    return card_num


def double(self, x):
    res = x * 2
    if res &gt; 9:
        res = res - 9
    return res


def luhn_algorithm(self, card):
    odd = map(lambda x: self.double(int(x)), card[::2])
    even = map(int, card[1::2])
    return (sum(odd) + sum(even)) % 10 == 0


def process_data(self):
    number = self.get_card_number()
    if self.luhn_algorithm(number):
        self.errorLabel.setText("Ваша карта обрабатывается...")
</code></pre>
<p>Проверим, введем номер карты: 4728795357233848.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/pyqt-3-pay-2.png" width="614" height="auto" /></div>
<p>Метод <var>luhn_algorithm</var> проверяет данные. Карта засчитается, только если данные корректны. Можно рассматривать этот метод как функцию с&nbsp;кодом возврата. Он говорит там, корректен&nbsp;ли номер карты.</p>
<p>Однако если пользователь введет не&nbsp;16&nbsp;цифр, а&nbsp;что-нибудь другое, или 16&nbsp;цифр, разделенных пробелами, то&nbsp;он&nbsp;обрушит программу. Попробуйте, например, ввести &laquo;asdasdasd&raquo;.</p>
<p>Программа упадет с&nbsp;таким сообщением:</p>
<pre><samp>Process finished with exit code -1073740791 (0xC0000409)</samp></pre>
<p>Не&nbsp;очень информативно... Это происходит из-за того, что мы&nbsp;используем PyQT, а&nbsp;она по&nbsp;умолчанию &laquo;замалчивает&raquo; необработанные ошибки. Внесем небольшие изменения в&nbsp;код нашей программы, чтобы это исправить (в&nbsp;дальнейшем вставляйте этот код во&nbsp;все свои приложения на&nbsp;PyQT):</p>
<pre><code class="language-python">def except_hook(cls, exception, traceback):
    sys.__excepthook__(cls, exception, traceback)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    form = PayForm()
    form.show()
    sys.excepthook = except_hook
    sys.exit(app.exec())
</code></pre>
<p>Попробуем ввести неверные данные еще раз и&nbsp;получим в&nbsp;консоли уже более понятное сообщение:</p>
<pre><samp>Traceback (most recent call last):
  File "D:/projects/yandexlyceum/Lessons/QT2020/QT3/Sample/1/main.py", line 31, in process_data
    if self.luhn_algorithm(number):
  File "D:/projects/yandexlyceum/Lessons/QT2020/QT3/Sample/1/main.py", line 27, in luhn_algorithm
    return (sum(odd) + sum(even)) % 10 == 0
  File "D:/projects/yandexlyceum/Lessons/QT2020/QT3/Sample/1/main.py", line 25, in &lt;lambda&gt;
    odd = map(lambda x: self.double(int(x)), card[::2])
ValueError: invalid literal for int() with base 10: 'a'</samp></pre>
<p>Как с&nbsp;такими сообщениями работать поговорим чуть позже, а&nbsp;пока сделаем так, чтобы в&nbsp;ответ на&nbsp;некорректный запрос программа не&nbsp;&laquo;падала&raquo;, а&nbsp;требовала ввести 16&nbsp;цифр, произвольно разделенных пробелами.</p>
<p>Для этого метод <var>get_card_number</var> теперь будет возвращать специальный код&nbsp;&mdash; например, 404, как в&nbsp;Интернете.</p>
<pre><code class="language-python">def get_card_number(self):
    card_num = self.cardData.text()
    card_num = ''.join(card_num.split())
    if card_num.isdigit() and len(card_num) == 16:
        return card_num
    else:
        return 404


def double(self, x):
    res = x * 2
    if res &gt; 9:
        res = res - 9
    return res


def luhn_algorithm(self, card):
    odd = map(lambda x: self.double(int(x)), card[::2])
    even = map(int, card[1::2])
    return (sum(odd) + sum(even)) % 10 == 0


def process_data(self):
    number = self.get_card_number()
    if number == 404:
        self.errorLabel.setText(
            "Введите только 16 цифр. Допускаются пробелы")
    elif self.luhn_algorithm(number):
        self.errorLabel.setText(
            "Ваша карта обрабатывается...")
    else:
        self.errorLabel.setText(
            "Номер недействителен. Попробуйте снова.")
</code></pre>
<p>Теперь при вводе неверных данных пользователь может получить еще одно сообщение:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/pyqt-3-pay-3.png" width="614" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="4">Трудности работы с&nbsp;кодами возврата</h2>
<p>Мы видим, что даже простая функция для обработки пользовательских данных обрастает дополнительным кодом, проверкой многих условий и&nbsp;&laquo;магическими&raquo; кодами возврата. Если функция с&nbsp;кодом возврата находится глубоко в&nbsp;стеке вызовов, то&nbsp;придется сделать так, чтобы ее&nbsp;правильно обрабатывала вся вышестоящая цепочка функций. Каждая из&nbsp;них должна принимать код и&nbsp;возвращать свой.</p>
<p>Чтобы упростить обработку ошибок, программисты стали работать с&nbsp;исключениями как с&nbsp;объектами.</p>
</section>
<section class="material__chapter">
<h2 id="5">Обработка исключений</h2>
<p>В&nbsp;Python и&nbsp;других объектно-ориентированных языках <strong>исключения</strong>&nbsp;&mdash; такие&nbsp;же объекты в&nbsp;программе, как и&nbsp;все остальное. Исключение создается в&nbsp;любом месте и&nbsp;поднимается по&nbsp;стеку вызовов, пока его не&nbsp;отловит какой-нибудь код-обработчик.</p>
<p>Сейчас поймаем исключения:</p>
<pre><samp>Traceback (most recent call last):
  File "/home/06.py", line 2, in &lt;module&gt;
    s.index("9")
ValueError: substring not found</samp></pre>
<p>Такое сообщение об&nbsp;ошибке означает, что метод <var>index</var> породил исключение&nbsp;&mdash; объект типа <var>ValueError</var>. Все функции стека вызовов получили уведомление о&nbsp;нештатной ситуации. Если ни&nbsp;одна из&nbsp;них не&nbsp;отреагирует, программа аварийно завершится.</p>
<p>Исключения ловят в&nbsp;специальном блоке <code>try...except</code>:</p>
<pre><code class="language-python">try:
    a = int(input("Введите целое число: "))
    print(a + 10)
except ValueError:
    print("Неверное число")
</code></pre>
<pre><samp>Введите целое число: 11df
Неверное число</samp></pre>
<p>Функция <var>int</var> порождает исключение <var>ValueError</var> (неверное значение), когда в&nbsp;строке есть посторонние символы (например, буквы).</p>
<p>Как только не&nbsp;удается выполнить строку <code>a = ...</code>, управление переходит к&nbsp;обработчику исключений (блок <var>except</var>).</p>
<p>Так как исключения&nbsp;&mdash; это классы, то&nbsp;они могут быть наследниками друг друга. Обработчик поймает не&nbsp;только указанные исключения, но&nbsp;и&nbsp;всех их&nbsp;наследников.</p>
<p>Дерево встроенных исключений выглядит так:</p>
<pre><code>BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
           +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
</code></pre>
<p>Если нужен доступ к&nbsp;исключению как к&nbsp;объекту, пригодится такая конструкция:</p>
<pre><code class="language-python">try:
    a = int(input("Введите целое число: "))
    print(a + 10)
except ValueError as ve:
    print("Неверное число")
    print(ve)
    print(dir(ve))
</code></pre>
<pre><samp>Введите целое число: fff
Неверное число
invalid literal for int() with base 10: 'fff'
['__cause__', '__class__', '__context__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__suppress_context__', '__traceback__', 'args', 'with_traceback']</samp></pre>
<p>В&nbsp;данном примере в&nbsp;переменную <var>ve</var>&nbsp;попадает объект класса <var>ValueError</var>, а&nbsp;функция <var>dir</var> позволяет увидеть содержимое этого объекта.</p>
<p>Перепишем задачу ввода карты вместе с&nbsp;исключениями. Там, где нужно было использовать код возврата, вставим конструкцию <var>raise</var> (генерация объекта&nbsp;&mdash; исключения заданного типа).</p>
<p>Вот во&nbsp;что превратится метод <var>get_card_number</var>:</p>
<pre><code class="language-python">def get_card_number(self):
    card_num = self.cardData.text()
    if not (card_num.isdigit() and len(card_num) == 16):
        raise ValueError("Неверный формат номера")
    return card_num
</code></pre>
<p>А&nbsp;остальные методы нашего класса станут такими:</p>
<pre><code class="language-python">def double(self, x):
    res = x * 2
    if res &gt; 9:
        res = res - 9
    return res


def luhn_algorithm(self, card):
    odd = map(lambda x: self.double(int(x)), card[::2])
    even = map(int, card[1::2])
    if (sum(odd) + sum(even)) % 10 == 0:
        return True
    else:
        raise ValueError("Недействительный номер карты")


def process_data(self):
    try:
        number = self.get_card_number()
        if self.luhn_algorithm(number):
            print("Ваша карта обрабатывается...")
    except ValueError as e:
        self.errorLabel.setText(f"Ошибка! {e}")
</code></pre>
<p>Результат работы программы:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/pyqt-3-pay-4.png" width="614" height="auto" /></div>
<p>Работа с&nbsp;исключениями избавляет от&nbsp;некоторых недостатков кодов возврата: он&nbsp;становится короче и&nbsp;не&nbsp;надо ставить конструкции <var>if</var>&nbsp;во&nbsp;всем стеке вызовов. Работа с&nbsp;ошибками становится гибче благодаря дереву исключений. Мы&nbsp;можем работать с&nbsp;системными исключениями (например, с&nbsp;прерыванием по&nbsp;нажатию на&nbsp;клавишу) так&nbsp;же легко, как с&nbsp;собственными.</p>
<p>Однако для работы с&nbsp;исключениями надо тренироваться. Код легко наводнить бесконечными проверками условий в&nbsp;ущерб основному алгоритму.</p>
<p>У&nbsp;работы с&nbsp;исключениями есть преимущества перед кодами возврата. В&nbsp;современных языках программирования используются именно объекты-исключения. Поговорим подробнее про механизмы работы с&nbsp;ними.</p>
</section>
<section class="material__chapter">
<h2 id="6">Методики LBYL и&nbsp;EAFP</h2>
<p>Когда мы&nbsp;изучаем исключения, то&nbsp;с&nbsp;их&nbsp;помощью хочется обрабатывать вообще все внештатные ситуации, максимально очищая код от&nbsp;дополнительных условий-проверок.</p>
<p>Есть два крайних подхода: LBYL (Look Before You Leap&nbsp;&mdash; <em>Посмотри перед прыжком</em>) и&nbsp;EAFP (Easier to&nbsp;Ask Forgiveness than Permission&nbsp;&mdash; <em>Проще извиниться, чем спрашивать разрешение</em>).</p>
<p>Например, при работе со&nbsp;словарями, когда доступ по&nbsp;ключу, а&nbsp;ключа нет, генерируется стандартное исключение <var>KeyError</var>:</p>
<pre><code class="language-python">mydict = {4: 34}
mydict[4354]
</code></pre>
<pre><samp>Traceback (most recent call last):
  File "/home/01.py", line 2, in &lt;module&gt;
    mydict[4354]
KeyError: 4354</samp></pre>
<p>С&nbsp;одной стороны, можно перестраховываться, заранее проверяя, что все получится. Это идеология LBYL-подхода. Сначала посмотрели, убедились, что все в&nbsp;порядке, только потом сделали. Как при переходе улицы: поглядели на&nbsp;светофор, потом по&nbsp;сторонам. Если горит зеленый свет и&nbsp;нет препятствий, можно переходить.</p>
<pre><code class="language-python">mydict = {'Elizabeth': 12, 'Ivan': 145}
if 'Ivan' in mydict:
    mydict['Ivan'] += 1
</code></pre>
<p>С&nbsp;другой стороны, мы&nbsp;можем описывать только главный алгоритм, рассчитывая, что все будет хорошо. Но&nbsp;при таком подходе необходимо прописать действия с&nbsp;исключениями (иногда и&nbsp;разных типов). Это суть подхода EAFP.</p>
<pre><code class="language-python">try:
    mydict['Ivan'] += 1
except KeyError:
    pass
</code></pre>
<p>В&nbsp;Python преобладает EAFP-подход, особенно если речь идет о&nbsp;стандартных исключениях и&nbsp;действиях с&nbsp;данными внутри них. Но&nbsp;это не&nbsp;значит, что методику LBYL вообще нельзя использовать. Всегда нужно рассматривать конкретный случай. Иногда есть и&nbsp;третий вариант. Например, в&nbsp;нашем случае можно было воспользоваться словарем, содержащим для всех ключей значение по&nbsp;умолчанию (в&nbsp;примере&nbsp;&mdash; 0):</p>
<pre><code class="language-python">from collections import defaultdict
    
    
s = defaultdict(lambda: 0)
s[34]
</code></pre>
<pre><samp>0</samp></pre>
<pre><code class="language-python">s[12] += 11
s[12]
</code></pre>
<pre><samp>11</samp></pre>
<p>В&nbsp;коде многопоточной программы лучше использовать EAFP. Если процессов несколько, один из&nbsp;них может неожиданно изменить данные, которые только что проверил и&nbsp;собирается использовать другой. Но&nbsp;сейчас мы&nbsp;не&nbsp;будем на&nbsp;этом останавливаться.</p>
</section>
<section class="material__chapter">
<h2 id="7">Полный синтаксис блока try...except</h2>
<p>Мы&nbsp;уже пользовались блоком <code>try...except</code>, но&nbsp;вообще <code>try...except</code> может выглядеть существенно сложнее:</p>
<pre><code class="language-python">s = [(1, 2), (4, 7), (1, 0), (13, None)]

for i in range(10):
    try:
        x, y = s[i]
        print(x / y)
    except IndexError:
        print('Мы за границей списка')
    except ZeroDivisionError as e:
        print('Поделили на 0')
    except Exception as e:
        print('Непредвиденная ошибка %s' % e)
    finally:
        print('Идем дальше')
</code></pre>
<pre><samp>0.5
Идем дальше
0.5714285714285714
Идем дальше
Поделили на 0
Идем дальше
Непредвиденная ошибка unsupported operand type(s) for /: 'int' and 'NoneType'
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше</samp></pre>
<p>К&nbsp;одному <var>try</var> может быть прикреплено несколько <var>except</var>. Блок <var>finally</var> выполняется независимо от&nbsp;того, создано&nbsp;ли исключение и&nbsp;какого оно типа. Даже если программа прервется внешним исключением, переходом по&nbsp;<var>break</var> или <var>continue</var>, блок <var>finally</var> будет выполнен.</p>
<p>Порядок перечисления исключений важен. Перебор закончится на&nbsp;первом&nbsp;же подходящем по&nbsp;условию блоке:</p>
<pre><code class="language-python">s = [(1, 2), (4, 7), (1, 0), (13, None)]

for i in range(10):
    try:
        x, y = s[i]
        print(x / y)
    except Exception as e:
        print('Непредвиденная ошибка %s' % e)
    except IndexError:
        print('Мы за границей списка')
    except ZeroDivisionError as e:
        print('Поделили на 0')
    finally:
        print('Идём дальше')
</code></pre>
<pre><samp>0.5
Идем дальше
0.5714285714285714
Идем дальше
Непредвиденная ошибка division by zero
Идем дальше
Непредвиденная ошибка unsupported operand type(s) for /: 'int' and 'NoneType'
Идем дальше
Непредвиденная ошибка list index out of range
Идем дальше
Непредвиденная ошибка list index out of range
Идем дальше
Непредвиденная ошибка list index out of range
Идем дальше
Непредвиденная ошибка list index out of range
Идем дальше
Непредвиденная ошибка list index out of range
Идем дальше
Непредвиденная ошибка list index out of range
Идем дальше</samp></pre>
<p>Все ошибки получились <strong>непредвиденными</strong>, потому что <var>Exception</var>&nbsp;&mdash; класс-родитель для большинства встроенных исключений. Все они могут быть приведены к&nbsp;типу <var>Exception</var> и&nbsp;провалились в&nbsp;первый&nbsp;же блок <var>except</var>.</p>
<p>В&nbsp;блоке <code>try...except</code> можно применять конструкцию <var>else</var>. Этот блок выполняется, если ни&nbsp;один из&nbsp;блоков <var>except</var> не&nbsp;подошел:</p>
<pre><code class="language-python">s = [(1, 2), (4, 7), (1, 0), (13, None)]

for i in range(10):
    try:
        x, y = s[i]
        print(x / y)
    except IndexError:
        print('Мы за границей списка')
    except ZeroDivisionError as e:
        print('Поделили на 0')
    except Exception as e:
        print('Непредвиденная ошибка %s' % e)
    else:
        print('Всё хорошо')
    finally:
        print('Идём дальше')
</code></pre>
<pre><samp>0.5
Все хорошо
Идем дальше
0.5714285714285714
Все хорошо
Идем дальше
Поделили на 0
Идем дальше
Непредвиденная ошибка unsupported operand type(s) for /: 'int' and 'NoneType'
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше
Мы за границей списка
Идем дальше</samp></pre>
<p>Перечислим еще несколько особенностей работы с&nbsp;исключениями.</p>
<ul>
<li>Сам блок <var>except</var> может быть источником исключений</li>
<li>Так как обработчик исключения и&nbsp;код, который его вызвал, могут находиться на&nbsp;разных уровнях стека, код может <strong>разорваться</strong>. В&nbsp;такой ситуации сложно уследить за&nbsp;общей логикой работы программы</li>
<li>Возможно вы&nbsp;захотите сделать что-то такое
<pre><code class="language-python">try:
    someting()
except Exception:
    pass
</code></pre>
</li>
</ul>
<p>Если вы&nbsp;не&nbsp;логируете (в&nbsp;файл, базу данных) ошибки в&nbsp;этом случае и&nbsp;не&nbsp;регистрируете сам их&nbsp;факт, программу тяжело отлаживать: она может выдавать неверные результаты, но&nbsp;неизменно отчитываться, что все в&nbsp;порядке.</p>
</section>
<section class="material__chapter">
<h2 id="8">Создание пользовательских типов ошибок</h2>
<p>Исключение&nbsp;&mdash; это объект. Мы&nbsp;можем дополнять дерево исключений собственными так&nbsp;же, как делаем это с&nbsp;любыми другими классами и&nbsp;объектами.</p>
<p>Если мы&nbsp;пишем большой модуль, нам почти всегда требуется собственная иерархия объектов-исключений. Обычно методы и&nbsp;свойства для собственных объектов не&nbsp;переопределяются и&nbsp;не&nbsp;дополняются. То, что нужно&nbsp;&mdash; прозрачные названия ошибок и&nbsp;корректная работа блока <code>try...except</code> с&nbsp;нужными классами&nbsp;&mdash; обеспечивается простым наследованием.</p>
<p>Как правило, новые объекты наследуют классу <var>Exception</var>.</p>
<p>Рассмотрим пример про проверку номеров банковской карты, в&nbsp;который мы&nbsp;добавили несколько собственных исключений:</p>
<pre><code class="language-python">import sys

from PyQt5 import uic
from PyQt5.QtWidgets import QWidget, QApplication


class CardError(Exception):
    pass


class CardFormatError(CardError):
    pass


class CardLuhnError(CardError):
    pass


class PayForm(QWidget):
    def __init__(self):
        super(PayForm, self).__init__()
        uic.loadUi('pay.ui', self)
        self.hintLabel.setText(
            'Введите номер карты (16 цифр без пробелов):')
        self.payButton.clicked.connect(self.process_data)

    def get_card_number(self):
        card_num = self.cardData.text()
        if not (card_num.isdigit() and len(card_num) == 16):
            raise CardFormatError("Неверный формат номера")
        return card_num

    def double(self, x):
        res = x * 2
        if res &gt; 9:
            res = res - 9
        return res

    def luhn_algorithm(self, card):
        odd = map(lambda x: self.double(int(x)), card[::2])
        even = map(int, card[1::2])
        if (sum(odd) + sum(even)) % 10 == 0:
            return True
        else:
            raise CardLuhnError("Недействительный номер карты")

    def process_data(self):
        try:
            number = self.get_card_number()
            if self.luhn_algorithm(number):
                print("Ваша карта обрабатывается...")
        except CardError as e:
            self.errorLabel.setText(f"Ошибка! {e}")


def except_hook(cls, exception, traceback):
    sys.__excepthook__(cls, exception, traceback)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    form = PayForm()
    form.show()
    sys.excepthook = except_hook
    sys.exit(app.exec())
</code></pre>
<p>Родительское исключение <var>CardError</var> позволяет нам перехватывать все нештатные ситуации, связанные с&nbsp;номером карты, а&nbsp;не&nbsp;только&nbsp;те, для которых есть специальные обработчики.</p>
</section>
<section class="material__chapter">
<h2 id="9">Перехват системных исключений</h2>
<p>В&nbsp;иерархии классов-исключений есть исключения <var>SystemExit</var> и&nbsp;<var>KeyboardInterrupt</var>.</p>
<p>Их&nbsp;можно использовать. Например, нажатие комбинации Ctrl+C обычно прекращает работу консольного приложения и&nbsp;генерирует исключение <strong>прерывание от&nbsp;клавиатуры</strong>.</p>
<p>Обработаем этот случай:</p>
<pre><code class="language-python">a = 0

while True:
    try:
        a += 1
    except KeyboardInterrupt:
        res = input('Действительно остановить? ')
        if res == 'yes':
            break
</code></pre>
<p>В&nbsp;этом примере после &laquo;волшебной&raquo; комбинации Ctrl+C&nbsp;мы попадем в&nbsp;блок <var>except</var> и&nbsp;зададим пользователю вопрос о&nbsp;прерывании работы программы.</p>
</section>
<section class="material__chapter">
<h2 id="10">Конструкция assert</h2>
<p>Конструкция <var>assert</var>&nbsp;&mdash; это часть Python, связанная с&nbsp;тестированием. Тестирование мы&nbsp;еще не&nbsp;проходили, но&nbsp;это не&nbsp;помешает понять, как&nbsp;же <var>assert</var> работает.</p>
<p>В&nbsp;любое место программы вы&nbsp;можете вставить блок такого вида:</p>
<pre><code class="language-python">assert логическое выражение
</code></pre>
<p>Например:</p>
<pre><code class="language-python">s = [1, 2, 34, 54, 3]
assert len(s) == 4
</code></pre>
<p>Когда мы&nbsp;попытаемся выполнить приведенный код, то&nbsp;получим:</p>
<pre><samp>-----------------------------------------------------------------

AssertionError                  Traceback (most recent call last)

&lt;ipython-input-1-c1fdb0a01058&gt; in &lt;module&gt;()
      1 s = [1, 2, 34, 54, 3]
----&gt; 2 assert len(s) == 4
    

AssertionError: </samp></pre>
<p>Блок работает так: если выражение верное, ничего не&nbsp;происходит. Если нет&nbsp;&mdash; создается исключение <var>AssertionError</var>.</p>
<p>Можно снабдить программу разными вспомогательными проверками. Они помогут контролировать правильность исполнения. Если какое-то условие не&nbsp;будет выполнено, то&nbsp;программа аварийно остановится. Это помогает тестировать и&nbsp;отлаживать&nbsp;ПО.</p>
<p>Интерпретатор Python можно запустить с&nbsp;опцией <code>-O</code>&nbsp;&mdash; тогда он&nbsp;будет пропускать блоки <var>assert</var>.</p>
<pre><code>-O     : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x
</code></pre>
<p>Это позволяет включать и&nbsp;выключать отладочные проверки.</p>
<p>Исключения&nbsp;&mdash; прекрасный инструмент, который позволит вам писать более простые и&nbsp;красивые программы, однако, использовать его надо с&nbsp;умом, выбирая, когда лучше использовать&nbsp;их, а&nbsp;когда добавить дополнительное условие.</p>
<p>Сам механизм исключений достаточно медленный, поэтому, например, не&nbsp;очень хорошей идеей будет кидать исключение внутри цикла, когда мы&nbsp;точно знаем, что их&nbsp;будет достаточное большое количество.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>