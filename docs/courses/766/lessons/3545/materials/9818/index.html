<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Введение в БД, работа с SQL-таблицами и отображение данных в PyQT. Часть 2 </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок QT SQL 2</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Введение в&nbsp;БД, работа с&nbsp;SQL-таблицами и&nbsp;отображение данных в&nbsp;PyQT. Часть 2</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">SQL. Продолжение</a></li>
<li><a class="material__link" href="#2">Модификация из&nbsp;Python</a></li>
<li><a class="material__link" href="#3">Заключение</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке мы&nbsp;продолжим знакомство с&nbsp;базами данных и&nbsp;работой с&nbsp;ними при помощи SQL и&nbsp;Python. Сделаем основной упор на&nbsp;управление данными: запись, изменение и&nbsp;удаление записей.</p>
</section>
<section class="material__chapter">
<h2 id="1">SQL. Продолжение</h2>
<p>Давайте снова вернемся в&nbsp;SQLiteStudio, откроем модельную <a class="material__link" href="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/films_db.sqlite" target="_blank" rel="noopener noreferrer">базу данных</a> с&nbsp;информацией о&nbsp;фильмах и&nbsp;выполним несколько запросов.</p>
<p><strong>Добавление записей</strong></p>
<p>На&nbsp;прошлом уроке мы&nbsp;познакомились только с&nbsp;одной частью работы с&nbsp;SQL&nbsp;&mdash; получение информации с&nbsp;помощью специального запроса <var>SELECT</var>. Но&nbsp;перед тем, как получать информацию из&nbsp;базы, необходимо ее&nbsp;туда поместить.</p>
<p>Для этого существует оператор <var>INSERT</var>. Его&nbsp;синтаксис в&nbsp;общем случае выглядит так:</p>
<pre><code class="language-python">INSERT INTO имя_таблицы(названия_полей*) VALUES(значения) 
</code></pre>
<p>Названия полей могут не&nbsp;указываться, тогда значения по&nbsp;умолчанию подставятся в&nbsp;поля по&nbsp;порядку. Давайте рассмотрим несколько примеров:</p>
<pre><code class="language-python">INSERT INTO genres(id,title) VALUES(42,'Фантасмагория')
</code></pre>
<pre><code class="language-python">INSERT INTO genres(title) VALUES('Лекции')
</code></pre>
<p>И&nbsp;теперь, когда мы&nbsp;захотим вывести таблицу жанров, мы&nbsp;увидим, что там появились новые значения.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-7/qt-7-1.png" width="225" height="auto" /></div>
<p>Но&nbsp;откуда взялось значение&nbsp;id, равное 43? Мы&nbsp;же его нигде не&nbsp;указывали? Дело в&nbsp;том, что в&nbsp;нашей таблице поле id&nbsp;является <strong>автоинкрементным</strong>, то&nbsp;есть при создании нового элемента берется максимальный из&nbsp;уже созданных индексов, увеличивается на&nbsp;единицу и&nbsp;присваивается новому элементу.</p>
<p>Часто в&nbsp;таблицу необходимо вставить не&nbsp;одно значение, а&nbsp;несколько. Для это не&nbsp;нужно вызывать оператор <var>INSERT</var> несколько раз, а&nbsp;достаточно через запятую перечислить все значения, которые необходимо добавить. Например, так:</p>
<pre><code class="language-python">INSERT INTO genres VALUES (45, 'Научные'), (46, 'Сказки') 
</code></pre>
<p><strong>Изменение записей</strong></p>
<p>Часто случается, что информация, хранящаяся в&nbsp;базе данных, нуждается в&nbsp;изменении. Для таких запросов используется оператор <var>UPDATE</var>. Его синтаксис в&nbsp;общем случае выглядит следующим образом:</p>
<pre><code class="language-python">UPDATE имя_таблицы
SET название_колонки = новое_значение
WHERE условие
</code></pre>
<p>Обратите внимание: если не&nbsp;указать условие обновления, изменятся <strong>абсолютно все</strong> записи в&nbsp;таблице.</p>
<p>Перейдем к&nbsp;примеру. Предположим, что мы&nbsp;посмотрели режиссерскую версию фильма &laquo;Аватар&raquo;, и&nbsp;теперь хотим указать новую продолжительность фильма. Разумеется, можно сохранить информацию, удалить запись и&nbsp;создать новую. Можно, но&nbsp;это крайне неудобно. Так что обновим значение поля <var>duration</var> для фильма &laquo;Аватар&raquo; .</p>
<pre><code class="language-python">UPDATE films
SET duration = '162'
WHERE title = 'Аватар'
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-7/qt-7-2.png" width="322" height="auto" /></div>
<p><strong>Удаление записей</strong></p>
<p>Но&nbsp;бывают и&nbsp;ситуации, когда какая-либо информация уже совершенно точно не&nbsp;нужна. Тогда ее&nbsp;необходимо удалить из&nbsp;БД, чтобы она не&nbsp;занимала лишнее пространство в&nbsp;памяти. Для этого используется оператор <var>DELETE</var>.</p>
<p>Например, чтобы удалить все фильмы, выпущенные до&nbsp;1985&nbsp;года, необходимо написать следующий запрос:</p>
<pre><code class="language-python">DELETE from films
where year &lt; 1985
</code></pre>
<p>Обратите внимание: если не&nbsp;указать условие, будут удалены <strong>абсолютно все</strong> записи в&nbsp;таблице. Во&nbsp;многие менеджеры даже встроен запрос подтверждения действия при выполнении запроса <var>DELETE</var> без части <var>WHERE</var>.</p>
</section>
<section class="material__chapter">
<h2 id="2">Модификация из&nbsp;Python</h2>
<p><strong>Редактирование данных</strong></p>
<p>В&nbsp;прошлом уроке мы&nbsp;научились получать информацию из&nbsp;БД и&nbsp;отображать ее&nbsp;в&nbsp;таблице. Но&nbsp;достаточно часто пользователям нужно не&nbsp;только просматривать, но&nbsp;и&nbsp;модифицировать и&nbsp;удалять информацию. Напишем программу, которая позволит получить фильм по&nbsp;его идентификатору, изменить его поля и&nbsp;сохранить.</p>
<p>Создадим интерфейс с&nbsp;помощью QtDesigner. Разместим на&nbsp;форме:</p>
<ul>
<li>Виджет для ввода id&nbsp;записи, например, QSpinBox</li>
<li>Две кнопки. Одну&nbsp;&mdash; для получения информации из&nbsp;базы данных, другую&nbsp;&mdash; для сохранения изменений</li>
<li>QTableWidget для отображения информации</li>
</ul>
<p>Упакуем это все с&nbsp;использованием какого-нибудь Layout. В&nbsp;результате у&nbsp;нас должно получиться что-то вроде такого:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-7/qt-7-3-1.png" width="646" height="auto" /></div>
<p>Начнем писать наше приложение с&nbsp;создания класса и&nbsp;заглушек для методов.</p>
<pre><code class="language-python">import sqlite3
import sys

from PyQt5 import uic
from PyQt5.QtWidgets import QApplication
from PyQt5.QtWidgets import QMainWindow, QTableWidgetItem


class MyWidget(QMainWindow):
    def __init__(self):
        super().__init__()
        uic.loadUi("UI1.ui", self)
        self.con = sqlite3.connect("films_db.sqlite")
        self.pushButton.clicked.connect(self.update_result)
        self.tableWidget.itemChanged.connect(self.item_changed)
        self.pushButton_2.clicked.connect(self.save_results)
        self.modified = {}
        self.titles = None

    def update_result(self):
        pass

    def item_changed(self, item):
        pass

    def save_results(self):
        pass


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = MyWidget()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Для того чтобы обработать изменение содержимого ячейки, воспользуемся сигналом <code>self.tableWidget.itemChanged</code>.</p>
<p>Начнем с&nbsp;метода получения данных <code>update_result()</code>. Тут все просто. Единственное, на&nbsp;что стоит обратить внимание&nbsp;&mdash; получение данных о&nbsp;заголовках столбцов из&nbsp;параметра курсора.</p>
<pre><code class="language-python">def update_result(self):
    cur = self.con.cursor()
    # Получили результат запроса, который ввели в текстовое поле
    result = cur.execute("SELECT * FROM films WHERE id=?",
                         (item_id := self.spinBox.text(), )).fetchall()
    # Заполнили размеры таблицы
    self.tableWidget.setRowCount(len(result))
    # Если запись не нашлась, то не будем ничего делать
    if not result:
        self.statusBar().showMessage('Ничего не нашлось')
        return
    else:
        self.statusBar().showMessage(f"Нашлась запись с id = {item_id}")
    self.tableWidget.setColumnCount(len(result[0]))
    self.titles = [description[0] for description in cur.description]
    # Заполнили таблицу полученными элементами
    for i, elem in enumerate(result):
        for j, val in enumerate(elem):
            self.tableWidget.setItem(i, j, QTableWidgetItem(str(val)))
    self.modified = {}
</code></pre>
<p>Теперь напишем метод, который будет отслеживать изменения ячеек. Будем записывать в&nbsp;словарь пару, состоящую из&nbsp;наименования поля и&nbsp;нового значения.</p>
<pre><code class="language-python">def item_changed(self, item):
    # Если значение в ячейке было изменено, 
    # то в словарь записывается пара: название поля, новое значение
    self.modified[self.titles[item.column()]] = item.text()
</code></pre>
<p>Обратите внимание на&nbsp;параметр <var>item</var>. При изменении ячейки в&nbsp;него будет попадать объект класса <var>QTableWidgetItem</var>, у&nbsp;которого можно получить интересующую нас информацию с&nbsp;помощью методов <code>column()</code> и&nbsp;<code>text()</code>.</p>
<p>Затем нам необходимо сохранить полученные результаты в&nbsp;БД. Так как заранее мы&nbsp;не&nbsp;знаем, какие поля были модифицированы, то&nbsp;мы&nbsp;не&nbsp;можем использовать конструкцию с&nbsp;вопросительным знаком. Так что просто &laquo;склеим&raquo; необходимый нам запрос, например, используя обыкновенную конкатенацию строк.</p>
<pre><code class="language-python">def save_results(self):
    if self.modified:
        cur = self.con.cursor()
        que = "UPDATE films SET\n"
        que += ", ".join([f"{key}='{self.modified.get(key)}'"
                          for key in self.modified.keys()])
        que += "WHERE id = ?"
        print(que)
        cur.execute(que, (self.spinBox.text(),))
        self.con.commit()
        self.modified.clear()
</code></pre>
<p>Одна из&nbsp;самых важных строк в&nbsp;<var>save_results</var>&nbsp;&mdash; вызов метода <code>commit()</code> у&nbsp;объекта-соединения с&nbsp;базой данных. По&nbsp;умолчанию все изменения с&nbsp;базой данных проводятся в&nbsp;памяти и&nbsp;не&nbsp;записываются в&nbsp;сам файл, поэтому если мы&nbsp;совершим манипуляцию с&nbsp;данными и&nbsp;перезапустим приложение, все правки пропадут. Чтобы такого не&nbsp;происходило, изменения надо зафиксировать. За&nbsp;это как раз и&nbsp;отвечает метод <code>commit()</code>.</p>
<p>Изначальное отображение:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-7/qt-7-5.png" width="674" height="auto" /></div>
<p>После изменения и&nbsp;сохранения:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-7/qt-7-6.png" width="674" height="auto" /></div>
<p>На&nbsp;практике изменение записи непосредственно в&nbsp;таблице используется не&nbsp;так часто. Обычно для редактирования существующей или создания новой записи производится в&nbsp;отдельной форме. Так лучше делать по&nbsp;нескольким причинам:</p>
<ol>
<li>Более широкие возможности для пользователя благодаря правильному подбору виджетов для каждого отдельного типа данных.</li>
<li>Меньше возможности пользователю отредактировать не&nbsp;те&nbsp;данные.</li>
<li>Проще отслеживать и&nbsp;сохранять изменения.</li>
</ol>
<p><strong>Удаление данных</strong></p>
<p>Теперь рассмотрим программу для удаления выделенного элемента.</p>
<p>Часто перед удалением какой-либо информации различные программы запрашивают у&nbsp;пользователя подтверждение. Сделаем программу с&nbsp;похожей функциональностью. Будем работать только с&nbsp;таблицей films. Создадим интерфейс нашей программы. Разместим на&nbsp;форме следующие виджеты:</p>
<ul>
<li>Виджет для ввода параметров фильтрации, например, например, QTextEdit</li>
<li>Две кнопки. Одну&nbsp;&mdash; для получения информации из&nbsp;базы данных, другую&nbsp;&mdash; для удаления записей</li>
<li>QTableWidget для отображения информации</li>
</ul>
<p>Снова запакуем в&nbsp;какой-нибудь Layout. Результат будет выглядеть как-то так:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-7/qt-7-5-delete.png" width="518" height="auto" /></div>
<p>В&nbsp;поле для ввода будем вводить только условие (то, что будет идти после оператора WHERE). А&nbsp;сам запрос будет формироваться так:</p>
<pre><code class="language-python">queue = "SELECT * FROM films WHERE " + self.textEdit.toPlainText()
</code></pre>
<p>Пользователь может выделить одно или несколько значений, а&nbsp;затем нажать на&nbsp;кнопку &laquo;Удалить&raquo;. После этого открывается окно с&nbsp;подтверждением, в&nbsp;котором указаны все&nbsp;ID, которые были выделены.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-7/qt-7-6-delete.png" width="517" height="auto" /></div>
<p>В&nbsp;случае положительного ответа при повторном запросе удаленные элементы уже не&nbsp;отобразятся.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-7/qt-7-7.png" width="518" height="auto" /></div>
<p>Основной метод, отличающий этот пример от&nbsp;предыдущего&nbsp;&mdash; <code>delete_elem()</code> для удаления выделенных элементов. Рассмотрим его&nbsp;поподробнее.</p>
<pre><code class="language-python">def delete_elem(self):
    # Получаем список элементов без повторов и их id
    rows = list(set([i.row() for i in self.tableWidget.selectedItems()]))
    ids = [self.tableWidget.item(i, 0).text() for i in rows]
    # Спрашиваем у пользователя подтверждение на удаление элементов
    valid = QMessageBox.question(
        self, '', "Действительно удалить элементы с id " + ",".join(ids),
        QMessageBox.Yes, QMessageBox.No)
    # Если пользователь ответил утвердительно, удаляем элементы. 
    # Не забываем зафиксировать изменения
    if valid == QMessageBox.Yes:
        cur = self.con.cursor()
        cur.execute("DELETE FROM films WHERE id IN (" + ", ".join(
            '?' * len(ids)) + ")", ids)
        self.con.commit()
</code></pre>
<p>В&nbsp;первой строке мы&nbsp;получаем список строк без повторов. Откуда взялись повторы? Выделяя строку, мы&nbsp;выделяем все элементы строки (все ячейки), соответственно, в&nbsp;список добавляется номер строки столько раз, сколько в&nbsp;ней элементов.</p>
<p>Поскольку номера строк очень часто не&nbsp;совпадают с&nbsp;идентификаторами, во&nbsp;второй строке мы&nbsp;получаем id&nbsp;записей, по&nbsp;которым мы&nbsp;и&nbsp;будем производить удаление, непосредственно из&nbsp;значений ячейки в&nbsp;нулевой колонке.</p>
<p>Теперь нам необходимо показать пользователю форму с&nbsp;подтверждением своего действия. Можно воспользоваться уже знакомым нам <var>QInputDialog</var> и&nbsp;написать что-то вроде:</p>
<pre><code class="language-python">answer, ok_pressed = QInputDialog.getItem(
    self, "Подтверждение удаления",
    "Вы точно хотите удалить элементы с id " + ",".join(ids),
    ("нет", "да"), 1, False)
</code></pre>
<p>Однако для отображения пользователю диалога о&nbsp;подтверждении какого-либо действия или информационного сообщения о&nbsp;каком-нибудь системном событии (например, об&nbsp;ошибке) в&nbsp;PyQT есть более привычный и&nbsp;подходящий инструмент. Это класс <var>QMessageBox</var>, у&nbsp;которого с&nbsp;<var>QInputDialog</var> общий родитель&nbsp;&mdash; <var>QDialog</var>. Поэтому импортируем его из&nbsp;PyQt5.QtWidgets, вызовем метод <code>question()</code>, в&nbsp;который передаются следующие параметры:</p>
<ul>
<li>Родитель&nbsp;&mdash; <var>self</var></li>
<li>Заголовок&nbsp;&mdash; обычно передается пустое поле, если мы&nbsp;хотим задать пользователю вопрос</li>
<li>Текст вопроса</li>
<li>Варианты ответов&nbsp;&mdash; <var>QMessageBox.Yes</var>, <var>QMessageBox.No</var></li>
</ul>
<p>Возможности <var>QMessageBox</var> достаточно широки, рекомендуем ознакомиться с&nbsp;ними в&nbsp;<a class="material__link" href="https://doc.qt.io/qt-5/qmessagebox.html" target="_blank" rel="noopener noreferrer">документации</a>.</p>
<p>После того как пользователь нажмет на&nbsp;одну из&nbsp;кнопок, результат будет занесен в&nbsp;переменную <var>valid</var>. А&nbsp;затем будет выполнена проверка и&nbsp;удаление.</p>
<p>Важно обратить внимание на&nbsp;то, что текст запроса формируется с&nbsp;использованием и&nbsp;конкатенации строк, и&nbsp;оператора <code>"?"</code>. В&nbsp;данной задаче мы&nbsp;также столкнулись с&nbsp;методом <code>commit()</code> у соединения с&nbsp;базой данных. Не&nbsp;забывайте фиксировать изменения после изменения данных или их&nbsp;удаления.</p>
</section>
<section class="material__chapter">
<h2 id="3">Заключение</h2>
<p>Мы&nbsp;рассмотрели основные запросы SQL и&nbsp;теперь умеем все, что необходимо для написания полноценных приложений для работы с&nbsp;данными, хранящимися в&nbsp;SQLite базе данных. Конечно, возможности SQL значительно шире, а&nbsp;уже рассмотренные операторы умеют больше. Уверенные знания языка запросов&nbsp;&mdash; &laquo;must have&raquo; для значительной части разработчиков программного обеспечения, поэтому настоятельно рекомендуем вам самостоятельно углубиться в&nbsp;эту тему. К&nbsp;счастью, в&nbsp;интернете существует огромное количество материалов, в&nbsp;том числе и&nbsp;бесплатных.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>