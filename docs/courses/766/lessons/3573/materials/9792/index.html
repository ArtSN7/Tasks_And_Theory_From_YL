<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | REST-API. Flask-restful </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Flask-restful</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>REST-API. Flask-RESTful</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Flask-RESTful</a></li>
<li><a class="material__link" href="#2">Миграции</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Сегодня мы&nbsp;посмотрим, как создавать RESTful-сервисы с&nbsp;помощью библиотеки flask-restful.</p>
</section>
<section class="material__chapter">
<h2 id="1">Flask-RESTful</h2>
<p>Все&nbsp;то, что мы&nbsp;сделали ранее при создании RESTful-сервиса, можно обернуть в&nbsp;более лаконичную, а&nbsp;главное&nbsp;&mdash; объектно-ориентированную оболочку, забыв о&nbsp;множестве разбросанных функций-обработчиков. Для этого установим дополнительный модуль flask-restful с&nbsp;помощью pip.</p>
<pre><code>pip install flask-restful
</code></pre>
<p>Из&nbsp;него нам понадобятся следующие объекты и&nbsp;функции:</p>
<pre><code class="language-python">from flask_restful import reqparse, abort, Api, Resource
</code></pre>
<p>Создадим вторую версию нашего REST-сервиса. После создания flask-приложения создадим объект RESTful-API:</p>
<pre><code class="language-python">app = Flask(__name__)
api = Api(app)
</code></pre>
<p>Для каждого ресурса (единица информации в&nbsp;REST называется <strong>ресурсом</strong>: новости, пользователи и&nbsp;т.&nbsp;д.) создается два класса: для одного объекта и&nbsp;для списка объектов. В&nbsp;нашем случае это классы <var>NewsResource</var> и&nbsp;<var>NewsListResource</var> соответственно. Создадим их&nbsp;в&nbsp;отдельном модуле, который назовем news_resources.py. Оба этих класса необходимо унаследовать от&nbsp;класса <var>Resource</var> из&nbsp;модуля flask-restful.</p>
<p>В&nbsp;классе одного объекта (<var>NewsResource</var>) определяются операции, которые мы&nbsp;можем сделать с&nbsp;<strong>одним</strong> объектом: получить информацию об&nbsp;объекте, изменить информацию, удалить объект. flask-restful подразумевает, что эти методы будут иметь имена, аналогичные соответствующим HTTP-запросам: <var>get</var>, <var>put</var>, <var>post</var>, <var>delete</var>. И&nbsp;все они, конечно, должны принимать в&nbsp;качестве аргумента идентификатор объекта.</p>
<p>Когда мы&nbsp;проектировали REST-сервис вручную, в&nbsp;каждой функции-обработчике мы&nbsp;проверяли, существует&nbsp;ли новость с&nbsp;таким идентификатором, и&nbsp;если нет, то&nbsp;отправляли ошибку. А&nbsp;также мы&nbsp;определили функцию <var>not_found</var> с&nbsp;декоратором <code>@app.errorhandler(404)</code>, чтобы изменить формат ответа сервера в&nbsp;случае ошибки. Давайте вынесем эту проверку в&nbsp;отдельную функцию в&nbsp;файле с&nbsp;ресурсами для записей:</p>
<pre><code class="language-python">def abort_if_news_not_found(news_id):
    session = db_session.create_session()
    news = session.query(News).get(news_id)
    if not news:
        abort(404, message=f"News {news_id} not found")
</code></pre>
<p>Функция <var>abort</var> генерирует HTTP-ошибку с&nbsp;нужным кодом и&nbsp;возвращает ответ в&nbsp;формате JSON, поэтому функция <var>not_found</var> нам больше не&nbsp;нужна. В&nbsp;предыдущем нашем варианте мы&nbsp;никак не&nbsp;использовали коды ответа сервера, это неверно. Наше сообщение об&nbsp;ошибке мог прочитать только человек, а&nbsp;для программы-клиента оно ничего не&nbsp;значит, ответ пришел со&nbsp;статусом&nbsp;ОК (200). Давно знакомый вам код 404&nbsp;означает, что запрашиваемый ресурс не&nbsp;найден. Подробнее про статусы состояния протокола HTTP можно почитать <a class="material__link" href="https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP" target="_blank" rel="noopener noreferrer">здесь</a>.</p>
<p>Класс <var>NewsResource</var> с&nbsp;методами получения информации и&nbsp;удаления будет иметь вид:</p>
<pre><code class="language-python">class NewsResource(Resource):
    def get(self, news_id):
        abort_if_news_not_found(news_id)
        session = db_session.create_session()
        news = session.query(News).get(news_id)
        return jsonify({'news': news.to_dict(
            only=('title', 'content', 'user_id', 'is_private'))})

    def delete(self, news_id):
        abort_if_news_not_found(news_id)
        session = db_session.create_session()
        news = session.query(News).get(news_id)
        session.delete(news)
        session.commit()
        return jsonify({'success': 'OK'})
</code></pre>
<p>В&nbsp;классе списка объектов (<var>NewsListResource</var>) определяются операции, которые мы&nbsp;можем сделать с&nbsp;<strong>набором</strong> объектов: показать список объектов и&nbsp;добавить объект в&nbsp;список. В&nbsp;этом классе нам потребуется реализовать два метода: <var>get</var> и&nbsp;<var>post</var> без аргументов. Доступ к&nbsp;данным, переданным в&nbsp;теле POST-запроса, осуществляется с&nbsp;помощью парсера аргументов из&nbsp;модуля reqparse, который предварительно нужно создать и&nbsp;добавить в&nbsp;него аргументы:</p>
<pre><code class="language-python">parser = reqparse.RequestParser()
parser.add_argument('title', required=True)
parser.add_argument('content', required=True)
parser.add_argument('is_private', required=True, type=bool)
parser.add_argument('is_published', required=True, type=bool)
parser.add_argument('user_id', required=True, type=int)
</code></pre>
<p>По-прежнему считаем, что все поля новости являются обязательными. Также укажем тип идентификатора пользователя&nbsp;&mdash; целое число. Теперь всю проверку аргументов запроса за&nbsp;нас будет делать модуль reqparse.</p>
<p>Таким образом, класс <var>NewsListResource</var> будет иметь вид:</p>
<pre><code class="language-python">class NewsListResource(Resource):
    def get(self):
        session = db_session.create_session()
        news = session.query(News).all()
        return jsonify({'news': [item.to_dict(
            only=('title', 'content', 'user.name')) for item in news]})

    def post(self):
        args = parser.parse_args()
        session = db_session.create_session()
        news = News(
            title=args['title'],
            content=args['content'],
            user_id=args['user_id'],
            is_published=args['is_published'],
            is_private=args['is_private']
        )
        session.add(news)
        session.commit()
        return jsonify({'success': 'OK'})
</code></pre>
<p>После того как мы&nbsp;создали классы ресурсов, нам надо внести их&nbsp;в&nbsp;настройки нашего RESTful-API, указав имя класса и&nbsp;URL. Параметр URL также указывается в&nbsp;угловых скобках. Для этого в&nbsp;main.py перед запуском нашего приложения необходимо добавить вот такой код:</p>
<pre><code class="language-python"># для списка объектов
api.add_resource(news_resources.NewsListResource, '/api/v2/news') 

# для одного объекта
api.add_resource(news_resources.NewsResource, '/api/v2/news/&lt;int:news_id&gt;')
</code></pre>
<p>Давайте проверим такую реализацию RESTful-сервиса с&nbsp;помощью запросов в&nbsp;нашем тестовом файле test.py. Убедитесь, что все работает, как нужно.</p>
<p>Документация по&nbsp;модулю flask-RESTful есть на&nbsp;<a class="material__link" href="http://flask-restful.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener noreferrer">официальном сайте</a>.</p>
<p>Если ваше приложение построено по&nbsp;правилам REST, вы&nbsp;получите логичную организацию работы с&nbsp;ресурсами, даже если их&nbsp;в&nbsp;приложении большое количество. Клиенты используют простые и&nbsp;понятные URL, а&nbsp;новым клиентам не&nbsp;составит труда разобраться с&nbsp;интерфейсом вашего приложения. Также в&nbsp;мире веб-разработки стандартом становится предоставлять <a class="material__link" href="https://restfulapi.net/rest-api-design-tutorial-with-example/" target="_blank" rel="noopener noreferrer">RESTful API</a> для сторонних приложений.</p>
<p>Есть&nbsp;ли подводные камни при использовании REST? Да, и&nbsp;этим камнем является HTML. Дело в&nbsp;том, что спецификация HTML позволяет создавать формы, отправляющие только GET- или POST-запросы. Поэтому для нормальной работы с&nbsp;другими методами (PUT, DELETE) приходится имитировать их&nbsp;искусственно. Часто в&nbsp;этих случаях используют JavaScript-библиотеки, например, JQuery.</p>
<p>Как и&nbsp;предыдущем уроке, здесь мы&nbsp;не&nbsp;рассматривали вопрос авторизации. В&nbsp;видеоматериалах к&nbsp;уроку эта тема раскрыта.</p>
</section>
<section class="material__chapter">
<h2 id="2">Миграции</h2>
<p>Мы&nbsp;уже говорили о&nbsp;том, что sqlalchemy при старте не&nbsp;вносит изменения в&nbsp;таблицы, если они уже созданы. Но&nbsp;абсолютно всегда бывает ситуация, когда после запуска первой версии нам захочется что-то поменять такого, что затронет и&nbsp;наши модели. Наверняка нам захочется хранить в&nbsp;базе дополнительную информацию. Что делать в&nbsp;таком случае? Не&nbsp;удалять&nbsp;же базу данных с&nbsp;информацией о&nbsp;куче пользователей, они такого не&nbsp;простят. Конечно, можно написать SQL-скрипты для приведения базы данных в&nbsp;актуальное состояние, но&nbsp;в&nbsp;общем случае это занятие не&nbsp;из&nbsp;приятных, потому что столбцы могут изменяться, удаляться, могут меняться связи между моделями и&nbsp;т.&nbsp;д. Тут на&nbsp;помощь приходят инструменты для <strong>миграции</strong>.</p>
<p>Уже упоминалось, что это такая штука, вроде системы контроля версий, только для базы данных. Инструменты миграции созданы для того, чтобы поддерживать вашу базу данных в&nbsp;актуальном состоянии и&nbsp;автоматически генерировать скрипты для перехода состояния базы из&nbsp;состояния <code>n</code>&nbsp;к&nbsp;состоянию <code>n
            + 1</code>&nbsp;и&nbsp;обратно (примерно как переходы по&nbsp;истории коммитов).</p>
<p>Какие-то ORM содержат модули миграции прямо из&nbsp;коробки (например, в&nbsp;Django), для sqlalchemy нам придется устанавливать и&nbsp;настраивать такую библиотеку отдельно. Она называется <a class="material__link" href="https://alembic.sqlalchemy.org/en/latest/" target="_blank" rel="noopener noreferrer">Alembic</a>.</p>
<p>Есть еще flask-migrate&nbsp;&mdash; обертка для alembic, упрощающая работу именно для flask-приложений, но&nbsp;мы&nbsp;рассмотрим более общий пример.</p>
<p>Установим библиотеку:</p>
<pre><code>pip install alembic
</code></pre>
<p>После в&nbsp;командной строке нужно перейти в&nbsp;директорию с&nbsp;нашим проектом и&nbsp;выполнить команду:</p>
<pre><code>alembic init alembic
</code></pre>
<p>Эта команда создаст директорию с&nbsp;именем alembic, в&nbsp;которой модуль будет хранить все необходимые файлы. А&nbsp;также alembic.ini в&nbsp;директории вашего проекта.</p>
<p>Откройте alembic.ini и&nbsp;измените строку с&nbsp;параметром <var>sqlalchemy.url</var> на&nbsp;путь к&nbsp;вашей базе данных:</p>
<pre><code>sqlalchemy.url = sqlite:///db/blogs.sqlite?check_same_thread=False
</code></pre>
<p>После этого перейдем в&nbsp;папку alembic. Нас интересует файл env.py. Откроем его и&nbsp;найдем строчку с&nbsp;переменной <var>target_metadata</var>. Эта переменная должна &laquo;узнать&raquo; о&nbsp;всех файлах нашей модели. Напишем там следующий код:</p>
<pre><code class="language-python">import sys
sys.path.insert(0, 'Путь к папке вашего проекта')
from data.db_session import SqlAlchemyBase
import data.__all_models
target_metadata = SqlAlchemyBase.metadata
</code></pre>
<p><code>sys.path.insert</code>&nbsp;&mdash; вставляет путь к&nbsp;каталогу в&nbsp;PATH. Это нужно для того, чтобы было проще писать импорты данных остальных файлов.</p>
<p>Затем импортируем нашу базу данных, напоминаем ей&nbsp;о&nbsp;всех моделях, после чего получаем данные о&nbsp;всех моделях.</p>
<p>Давайте попробуем. Например, мы&nbsp;хотим добавить в&nbsp;модель с&nbsp;новостью поле, которое показывает, опубликована запись или нет, чтобы потом показывать в&nbsp;списке только опубликованные записи. Идем в&nbsp;модель <var>News</var> и&nbsp;добавляем в&nbsp;нее новое поле:</p>
<pre><code class="language-python">is_published = sqlalchemy.Column(sqlalchemy.Boolean, default=True)
</code></pre>
<p>Теперь запускаем консоль в&nbsp;папке нашего проекта и&nbsp;выполняем команду:</p>
<pre><code>alembic revision --autogenerate -m "добавили признак публикации"
</code></pre>
<p>Alembic посмотрит на&nbsp;наши модели и&nbsp;на&nbsp;базу и&nbsp;создаст в&nbsp;папке alembic/versions новую миграцию вот с&nbsp;таким кодом:</p>
<pre><code class="language-python">from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '3acec80b2659'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('news', sa.Column('is_published', sa.Boolean(), 
                                    nullable=True))
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('news', 'is_published')
    # ### end Alembic commands ###
</code></pre>
<p>Тут всего две функции. <var>upgrade</var> выполняет код для изменения состояния базы, <var>downgrade</var>&nbsp;&mdash; код для возврата к&nbsp;предыдущему состоянию. Давайте обновим нашу базу, для чего выполним в&nbsp;консоли команду:</p>
<pre><code>alembic upgrade head
</code></pre>
<p><var>head</var> означает, что мы&nbsp;хотим применить все миграции друг за&nbsp;другом для приведения базы в&nbsp;самое актуальное состояние. Вместо <var>head</var> можно указать номер ревизии или написать, например, <code>+2</code>, чтобы обновиться только на&nbsp;2&nbsp;следующие версии.</p>
<p>Посмотрим, что случилось с&nbsp;нашей базой данных. В&nbsp;таблице news появилось поле <var>is_published</var>, как и&nbsp;ожидалось, но&nbsp;кроме этого появилась новая таблица <var>alembic_version</var>. В&nbsp;этой таблице хранится номер ревизии, которой в&nbsp;настоящий момент соответствует база данных.</p>
<p>Из-за ограничений СУБД sqlite команда <code>alembic downgrade head</code>не удалит ранее добавленную в таблицу колонку.</p>
<p>К&nbsp;сожалению, alembic не&nbsp;всемогущ. Вот что он&nbsp;умеет определять.</p>
<p>Операции, которые Alembic умеет выявлять:</p>
<ul>
<li>Добавление и&nbsp;удаление таблиц</li>
<li>Добавление и&nbsp;удаление колонок</li>
<li>Изменения во&nbsp;внешних ключах</li>
<li>Изменения в&nbsp;типах колонок</li>
<li>Изменения в&nbsp;индексах и&nbsp;использованных уникальных ограничениях</li>
</ul>
<p>А&nbsp;вот какие изменения не&nbsp;умеет:</p>
<ul>
<li>Изменение имени таблицы</li>
<li>Изменение имени колонки</li>
</ul>
<p>Поэтому бывают ситуации, когда в&nbsp;файлы миграции надо вмешиваться и&nbsp;дописывать в&nbsp;них необходимые изменения. Не&nbsp;бойтесь этого.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>