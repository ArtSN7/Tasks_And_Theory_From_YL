<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | REST-API. Понятие. Делаем простое REST-API </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок WEB. REST-API</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>REST-API. Понятие. Делаем простое REST-API</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">REST API на&nbsp;flask. Микросервисы</a></li>
<li><a class="material__link" href="#2">REST</a></li>
<li><a class="material__link" href="#3">Blueprint</a></li>
<li><a class="material__link" href="#4">Сериализация в&nbsp;json</a></li>
<li><a class="material__link" href="#5">Создание и&nbsp;тестирование сервисов</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;этом занятии мы&nbsp;научимся создавать собственное API для наших веб-приложений.</p>
</section>
<section class="material__chapter">
<h2 id="1">REST API на&nbsp;flask. Микросервисы</h2>
<p>На&nbsp;прошлых уроках вы&nbsp;изучили базовые возможности фреймворка Flask и&nbsp;уже можете создавать полноценные веб-приложения, которые могут взаимодействовать с&nbsp;пользователем и&nbsp;работать с&nbsp;базой данных. На&nbsp;этом уроке мы&nbsp;предлагаем подняться на&nbsp;уровень выше и&nbsp;рассмотреть архитектуру веб-приложения: по&nbsp;каким правилам будут взаимодействовать компоненты вашего приложения и&nbsp;как организовать код, чтобы в&nbsp;дальнейшем его было легче поддерживать и&nbsp;проще добавлять новые функции.</p>
<p>Можно выделить два основных подхода к&nbsp;организации архитектуры веб-приложений:</p>
<ul>
<li>Монолитная архитектура (Monolithic Style)</li>
<li>Сервис-ориентированная архитектура (SOA, Service-oriented Architecture)</li>
</ul>
<p>При монолитном подходе приложение строится как единое целое. Как правило, монолитное веб-приложение включает три части: веб-сервер, который содержит всю логику приложения, базу данных и&nbsp;пользовательский интерфейс в&nbsp;виде HTML-страниц. Любые изменения в&nbsp;логике сервера, даже самые небольшие, приводят к&nbsp;выпуску новой версии всего приложения. А&nbsp;с&nbsp;учетом того, что все больше приложений развертываются на&nbsp;облачных серверах, после внесенных изменений нужно заново развертывать в&nbsp;облаке монолитное приложение целиком. Монолитный подход является самым старым, именно с&nbsp;него началась разработка всего программного обеспечения. Тем не&nbsp;менее, монолитные приложения живы и&nbsp;по&nbsp;сей день, и&nbsp;в&nbsp;некоторых проектах такой подход является оправданным.</p>
<p>Недостатки монолитной архитектуры привели к&nbsp;появлению сначала <strong>модульной</strong>, а&nbsp;потом и&nbsp;сервис-ориентированной архитектуры. <strong>Сервис-ориентированная архитектура</strong> (SOA) основана на&nbsp;использовании отдельных полностью самодостаточных модулей, называемых <strong>сервисами</strong>. Разработка сервисов происходит отдельно друг от&nbsp;друга, а&nbsp;потому изменения в&nbsp;коде одного сервиса будут влиять только на&nbsp;него.</p>
<p>Около 10&nbsp;лет назад (сам термин устоялся только в&nbsp;2012&nbsp;году) появился еще один подход, &laquo;современный взгляд&raquo; на&nbsp;проектирование распределенных приложений&nbsp;&mdash; <strong>архитектура микросервисов</strong> (MSA, Micro Service Architecture). Можно сказать, что MSA является разновидностью, частным случаем SOA. Такая архитектура подразумевает, что ваше приложение представляет собой много небольших сервисов, которые взаимодействуют между собой путем обмена сообщениями, как правило, по&nbsp;протоколу HTTP (или разные сервисы взаимодействуют по&nbsp;разным протоколам). MSA предполагает, что каждый микросервис&nbsp;&mdash; это полностью независимое приложение, содержащее всего несколько сотен строк кода. Согласно MSA, микросервисы могут располагаться даже на&nbsp;различных серверах. Интересно, что при таком подходе разные микросервисы в&nbsp;рамках одного приложения могут быть написаны на&nbsp;разных языках программирования и&nbsp;с&nbsp;применением разных технологий.</p>
<p>Рекомендуем прочитать подробную статью про микросервисную архитектуру на&nbsp;<a class="material__link" href="https://habr.com/company/dataart/blog/280083/" target="_blank" rel="noopener noreferrer">Хабре</a>.</p>
<p>Можно сказать, что микросервисы&nbsp;&mdash; это теория, а&nbsp;на&nbsp;практике она может выражаться по-разному. Мы&nbsp;рассмотрим архитектурный стиль, основанный на&nbsp;идеологии микросервисов, который на&nbsp;настоящее время становится стандартом при разработке веб-приложений&nbsp;&mdash; <strong>архитектурный стиль REST</strong> (REpresentational State Transfer).</p>
</section>
<section class="material__chapter">
<h2 id="2">REST</h2>
<p>REST&nbsp;&mdash; архитектурный стиль программного обеспечения, который определяет правила управления информационными потоками и&nbsp;правила взаимодействия компонентов распределенного приложения. Другими словами, REST&nbsp;&mdash; это набор ограничений и&nbsp;принципов взаимодействия сервера и&nbsp;клиента в&nbsp;сети, который использует существующие стандарты: протокол HTTP, стандарт построения URL, форматы данных JSON и&nbsp;XML.</p>
<p>Ключевым понятием в&nbsp;архитектуре REST является URL. Каждая единица информации имеет уникальный идентификатор&nbsp;&mdash; URL, который строится по&nbsp;строго заданному формату. Например, вторая книга с&nbsp;книжной полки будет иметь URL /book/2, а&nbsp;50-я страница в&nbsp;этой книге&nbsp;&mdash; /book/2/page/50.</p>
<p>То, каким образом происходит управление этой информацией, определяет протокол передачи данных. REST использует протокол HTTP, соответственно, управление информацией происходит с&nbsp;помощью HTTP-запросов: GET (получить), PUT (заменить), POST (добавить), DELETE (удалить). Для каждой единицы информации определяется пять операций:</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<thead>
<tr>
<th>№</th>
<th>Операция</th>
<th>Запрос</th>
<th>Пример URL</th>
<th>Примечание</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Получить список всех объектов</td>
<td>GET</td>
<td>/book/</td>
<td>Получить список всех книг на&nbsp;полке</td>
</tr>
<tr>
<td>2</td>
<td>Получить информацию об&nbsp;объекте</td>
<td>GET</td>
<td>/book/2</td>
<td>Получить информацию о&nbsp;книге №&nbsp;2</td>
</tr>
<tr>
<td>3</td>
<td>Создать новый объект</td>
<td>POST</td>
<td>/book/</td>
<td>Добавить новую книгу на&nbsp;основе информации, переданной с&nbsp;запросом</td>
</tr>
<tr>
<td>4</td>
<td>Изменить существующий объект</td>
<td>PUT</td>
<td>/book/1</td>
<td>Изменить книгу №&nbsp;1&nbsp;на основе информации, переданной с&nbsp;запросом</td>
</tr>
<tr>
<td>5</td>
<td>Удалить существующий объект</td>
<td>DELETE</td>
<td>/book/2</td>
<td>Удалить книгу №&nbsp;2</td>
</tr>
</tbody>
</table>
</div>
<p>Данные для изменения и&nbsp;добавления (PUT- и&nbsp;POST-запросы) передаются в&nbsp;теле запроса в&nbsp;формате JSON или XML. Глядя на&nbsp;запрос, можно сразу определить, для чего он&nbsp;служит (к&nbsp;сожалению, в&nbsp;некоторых других архитектурных стилях&nbsp;&mdash; SOAP, XML-RPC&nbsp;&mdash; это не&nbsp;так).</p>
<p>Приложения, поддерживающие архитектуру REST, называются <strong>RESTful-приложениями</strong>. Давайте создадим наш первый RESTful веб-сервис.</p>
<p>Перед написанием кода нужно продумать, с&nbsp;какой информацией мы&nbsp;будем работать и&nbsp;на&nbsp;основе каких правил будут строиться URL. Давайте вернемся к&nbsp;нашему приложению по&nbsp;работе с&nbsp;новостями из&nbsp;прошлого урока и&nbsp;построим его по&nbsp;принципам REST. Для получения списка всех новостей можно использовать такой URL:</p>
<pre><code>http://127.0.0.1:5000/api/news
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Blueprint</h2>
<p>Чтобы не&nbsp;смешивать код обработчиков API для новостей с&nbsp;кодом основного приложения, мы&nbsp;воспользуемся механизмом разделения приложения Flask на&nbsp;независимые модули или Blueprint. Как правило, blueprint&nbsp;&mdash; логически выделяемый набор обработчиков адресов, который можно вынести в&nbsp;отдельный файл или модуль. Blueprint работает аналогично объекту приложения Flask, но&nbsp;в&nbsp;действительности он&nbsp;не&nbsp;является приложением. Обычно это лишь эскиз для сборки или расширения приложения.</p>
<p>Давайте создадим файл news_api.py и&nbsp;добавим в&nbsp;него следующий код:</p>
<pre><code class="language-python">import flask

from . import db_session
from .news import News

blueprint = flask.Blueprint(
    'news_api',
    __name__,
    template_folder='templates'
)


@blueprint.route('/api/news')
def get_news():
    return "Обработчик в news_api"
</code></pre>
<p>Мы&nbsp;создали схему, в&nbsp;которую добавили обработчик. Обратите внимание: мы&nbsp;воспользовались не&nbsp;декоратором <code>app.route</code>, а&nbsp;аналогичным для схемы&nbsp;&mdash; <code>blueprint.route</code>. Теперь нужно, чтобы о&nbsp;нашей схеме узнало основное приложение, для чего в&nbsp;main.py перед запуском добавим регистрацию схемы:</p>
<pre><code class="language-python">from data import db_session, news_api


def main():
    db_session.global_init("db/blogs.db")
    app.register_blueprint(news_api.blueprint)
    app.run()
</code></pre>
<p>Перейдем по&nbsp;адресу http://127.0.0.1:5000/api/news и&nbsp;проверим, что у&nbsp;нас получилось.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/web-rest-1.png" width="272" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="4">Сериализация в&nbsp;json</h2>
<p>Обычно REST-сервисы обмениваются информацией в формате json. Поэтому надо научить объекты наших моделей превращаться в&nbsp;словарь, для чего надо добавить каждой из&nbsp;моделей метод <var>to_dict</var>. Это достаточно просто сделать руками, но&nbsp;мы&nbsp;воспользуемся возможностями модуля SQLAlchemy-serializer. Установим его:</p>
<pre><code>pip install SQLAlchemy-serializer
</code></pre>
<p>Теперь мы&nbsp;снова сможем воспользоваться множественным наследованием и&nbsp;добавить к&nbsp;каждой из&nbsp;наших моделей еще один класс-примесь <var>SerializerMixin</var>, добавляющий метод <var>to_dict</var>.</p>
<p>Заголовок класса <var>Users</var> теперь у&nbsp;нас выглядит так:</p>
<pre><code class="language-python">class User(SqlAlchemyBase, UserMixin, SerializerMixin):
</code></pre>
<p>Не&nbsp;забудьте добавить <var>SerializerMixin</var> и&nbsp;в&nbsp;остальные модели.</p>
</section>
<section class="material__chapter">
<h2 id="5">Создание и&nbsp;тестирование сервисов</h2>
<p>Теперь допишем в&nbsp;функцию <code>get_news()</code> код для получения всех новостей. Давайте пока опустим проверку авторизации пользователя.</p>
<pre><code class="language-python">@blueprint.route('/api/news')
def get_news():
    db_sess = db_session.create_session()
    news = db_sess.query(News).all()
    return jsonify(
        {
            'news':
                [item.to_dict(only=('title', 'content', 'user.name')) 
                 for item in news]
        }
    )
</code></pre>
<p>Как видите, мы&nbsp;можем явно указать, какие поля хотим оставить в&nbsp;получившемся словаре.</p>
<p>Согласно архитектуре REST, обмен данными между клиентом и&nbsp;сервером осуществляется в&nbsp;формате JSON (реже&nbsp;&mdash; XML). Поэтому мы&nbsp;изменили формат ответа сервера flask с&nbsp;помощью метода <var>jsonify</var>, который преобразует наши данные в&nbsp;JSON.</p>
<p>Посмотреть, что вернул сервер, можно и&nbsp;не&nbsp;открывая браузер. По&nbsp;сути, браузер&nbsp;&mdash; это средство для отправки запросов на&nbsp;сервер и&nbsp;отображения ответа. Отправить запрос на&nbsp;сервер можно и&nbsp;другими способами (например, консольная утилита curl или GUI-программа Postman), но&nbsp;как программисты на&nbsp;Python, мы&nbsp;воспользуемся его средствами, а&nbsp;именно&nbsp;&mdash; модулем requests. Мы&nbsp;уже неплохо знакомы с&nbsp;этим модулем и&nbsp;помним, что он&nbsp;позволяет отправлять на&nbsp;сервер разные типы запросов, передавать данные вместе с&nbsp;POST- и&nbsp;PUT-запросами. Для этого используются специальные функции, их&nbsp;имена совпадают с&nbsp;именем HTTP-запроса. Для тестирования нашего RESTful-сервиса создадим файл test.py со&nbsp;следующим содержимым:</p>
<pre><code class="language-python">from requests import get

print(get('http://localhost:5000/api/news').json())
</code></pre>
<p>Запустим файл (не&nbsp;забудьте запустить сервер) и&nbsp;увидим, что на&nbsp;наш GET-запрос пришел ответ от&nbsp;сервера со&nbsp;всеми новостями из&nbsp;базы данных.</p>
<p>Согласно REST, далее нужно реализовать получение информации об&nbsp;одной новости. Фактически, мы&nbsp;уже получили из&nbsp;списка всю информацию о&nbsp;каждой новости. При проектировании приложений по&nbsp;архитектуре REST обычно поступают таким образом: когда возвращается список объектов, он&nbsp;содержит только краткую информацию (например, только id&nbsp;и&nbsp;заголовок), а&nbsp;полную информацию (текст и&nbsp;автора) можно посмотреть с&nbsp;помощью запроса, который мы&nbsp;обработаем далее.</p>
<p>Напишем функцию <var>get_one_news</var> для получения информации о&nbsp;новости по&nbsp;ее&nbsp;идентификатору. Как нам говорит REST, идентификатор объекта содержится в&nbsp;URL, по&nbsp;которому мы&nbsp;обращаемся. Как&nbsp;же передать этот идентификатор, если он&nbsp;различный у&nbsp;всех новостей, а&nbsp;в&nbsp;декораторе функции-обработчика мы&nbsp;указываем статический адрес? Flask позволяет решить эту проблему с&nbsp;помощью параметров адреса: мы&nbsp;можем передать параметр в&nbsp;URL, в&nbsp;декораторе заключив его в&nbsp;угловые скобки и&nbsp;указав тип и&nbsp;имя (например, <code>&lt;int:news_id&gt;</code>), и&nbsp;он&nbsp;будет передан функции-обработчику как аргумент. Обратите внимание: теперь наша функция принимает аргумент <var>news_id</var>:</p>
<pre><code class="language-python">@blueprint.route('/api/news/&lt;int:news_id&gt;', methods=['GET'])
def get_one_news(news_id):
    db_sess = db_session.create_session()
    news = db_sess.query(News).get(news_id)
    if not news:
        return jsonify({'error': 'Not found'})
    return jsonify(
        {
            'news': news.to_dict(only=(
                'title', 'content', 'user_id', 'is_private'))
        }
    )
</code></pre>
<p>Посмотрим ответ сервера с&nbsp;корректным <var>id</var>&nbsp;и&nbsp;с&nbsp;ошибочным, добавив еще два запроса в&nbsp;файл test.py:</p>
<pre><code class="language-python">print(get('http://localhost:5000/api/news/1').json())

print(get('http://localhost:5000/api/news/999').json())
# новости с id = 999 нет в базе
</code></pre>
<p>Как видим, в&nbsp;первом случае нам вернулась одна новость, во&nbsp;втором&nbsp;&mdash; сообщение об&nbsp;ошибке. В&nbsp;типе параметра URL мы&nbsp;указали <var>int</var>. Что&nbsp;же будет, если мы&nbsp;передадим не&nbsp;число? Давайте проверим.</p>
<pre><code class="language-python">print(get('http://localhost:5000/api/news/q').json())
</code></pre>
<p>Файл test.py завершится с&nbsp;ошибкой. Так как параметр не&nbsp;типа <var>int</var>, в&nbsp;функцию <var>get_one_news</var> мы&nbsp;даже не&nbsp;попадем&nbsp;&mdash; нет полного совпадения декоратора. На&nbsp;такой запрос сервер вернет ответ со&nbsp;статусом 404 (страница не&nbsp;найдена), но&nbsp;не&nbsp;в&nbsp;формате JSON. Поэтому при попытке преобразовать ответ с&nbsp;помощью метода <code>json()</code> программа завершается с&nbsp;ошибкой, так как клиентское приложение, в&nbsp;нашем случае, ожидает от&nbsp;сервера ответ в&nbsp;формате JSON. Уберите приведение ответа к&nbsp;JSON и&nbsp;посмотрите, что вернул сервер.</p>
<p>Чтобы такой ошибки не&nbsp;возникало, воспользуемся модулем make_response. Импортируем модуль и&nbsp;добавим функции с&nbsp;декораторами 404 и 400 &nbsp;ошибок:</p>
<pre><code class="language-python">from flask import make_response

@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'Not found'}), 404)


@app.errorhandler(400)
def bad_request(_):
    return make_response(jsonify({'error': 'Bad Request'}), 400)
</code></pre>
<p>После этого даже при передаче неправильного параметра ответ от&nbsp;сервера будет приходить в&nbsp;формате JSON, и&nbsp;клиентское приложение не&nbsp;будет падать. Верните метод <code>json()</code> и&nbsp;проверьте результат.</p>
<p>Следующая операция, которую нам нужно реализовать&nbsp;&mdash; добавление новой новости с&nbsp;помощью POST-запроса. Как уже было сказано, данные для создаваемой новости будут переданы в&nbsp;теле запроса. Чтобы добраться до&nbsp;тела запроса, нам понадобиться модуль request из&nbsp;flask (не&nbsp;путайте с&nbsp;модулем requests).</p>
<pre><code class="language-python">@blueprint.route('/api/news', methods=['POST'])
def create_news():
    if not request.json:
        return jsonify({'error': 'Empty request'})
    elif not all(key in request.json for key in
                 ['title', 'content', 'user_id', 'is_private']):
        return jsonify({'error': 'Bad request'})
    db_sess = db_session.create_session()
    news = News(
        title=request.json['title'],
        content=request.json['content'],
        user_id=request.json['user_id'],
        is_private=request.json['is_private']
    )
    db_sess.add(news)
    db_sess.commit()
    return jsonify({'success': 'OK'})
</code></pre>
<p>Проверив, что запрос содержит все требуемые поля, мы&nbsp;заносим новую запись в&nbsp;базу данных. <var>request.json</var> содержит тело запроса, с&nbsp;ним можно работать, как со&nbsp;словарем. В&nbsp;нашем случае все ключи заранее известны и&nbsp;все поля обязательны. В&nbsp;противном случае для работы со&nbsp;словарем <var>request.json</var> нужно использовать метод словарей <var>get</var>. Вспомните, в&nbsp;чем его особенность.</p>
<p>При тестировании проверим пустой запрос, передачу только заголовка новости и&nbsp;корректный запрос. Все данные передаются в&nbsp;параметре json:</p>
<pre><code class="language-python">print(post('http://localhost:5000/api/news').json())

print(post('http://localhost:5000/api/news',
           json={'title': 'Заголовок'}).json())

print(post('http://localhost:5000/api/news',
           json={'title': 'Заголовок',
                 'content': 'Текст новости',
                 'user_id': 1,
                 'is_private': False}).json())
</code></pre>
<p>Проверьте, что в&nbsp;каждом случае от&nbsp;сервера приходит нужное сообщение. Также давайте отправим запрос на&nbsp;получение всех новостей и&nbsp;убедимся, что новость добавлена.</p>
<p>Добавим функцию удаления новости:</p>
<pre><code class="language-python">@blueprint.route('/api/news/&lt;int:news_id&gt;', methods=['DELETE'])
def delete_news(news_id):
    db_sess = db_session.create_session()
    news = db_sess.query(News).get(news_id)
    if not news:
        return jsonify({'error': 'Not found'})
    db_sess.delete(news)
    db_sess.commit()
    return jsonify({'success': 'OK'})
</code></pre>
<p>И&nbsp;протестируем&nbsp;ее:</p>
<pre><code class="language-python">print(delete('http://localhost:5000/api/news/999').json())
# новости с id = 999 нет в базе

print(delete('http://localhost:5000/api/news/1').json())
</code></pre>
<p>Такой &laquo;ручной&raquo; способ создания RESTful-сервисов достаточно объемный и&nbsp;трудоемкий. Нужно держать в&nbsp;голове все URL и&nbsp;методы, создавать много функций-обработчиков с&nbsp;декораторами для каждого типа запросов (эти функции как раз и&nbsp;являются микросервисами). Программисты на&nbsp;Python не&nbsp;были&nbsp;бы программистами на&nbsp;Python, если&nbsp;бы не&nbsp;стремились упростить объемный код и&nbsp;сделать его более лаконичным. Так и&nbsp;появился легкий способ создавать RESTful-сервисы на&nbsp;flask&nbsp;&mdash; модуль Flask-RESTful, который мы&nbsp;рассмотрим уже на&nbsp;следующем уроке.</p>
<p>Еще один важный вопрос не&nbsp;был рассмотрен в&nbsp;этом уроке&nbsp;&mdash; вопрос авторизации. Сейчас удалять, добавлять и&nbsp;просматривать новости с&nbsp;помощью нашего API может любой пользователь, а&nbsp;точнее любая программа, которая будет использовать этот API. В&nbsp;настоящих API для выполнения таких действий пользователь должен представиться. Эта тема раскрыта в&nbsp;видео к&nbsp;уроку.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>