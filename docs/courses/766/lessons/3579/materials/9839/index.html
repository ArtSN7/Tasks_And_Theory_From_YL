<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Чат-боты 3 (Discord) </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Боты Discord</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Чат-боты 3</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Введение</a></li>
<li><a class="material__link" href="#2">Асинхронное программирование</a></li>
<li><a class="material__link" href="#3">Подготовка</a></li>
<li><a class="material__link" href="#4">Простой бот</a></li>
<li><a class="material__link" href="#5">Объектно-ориентированный подход</a></li>
<li><a class="material__link" href="#6">Команды</a></li>
<li><a class="material__link" href="#7">Заключение</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;заключительном уроке по&nbsp;созданию чат-ботов мы&nbsp;создадим бота для Discord, а&nbsp;также немного поговорим о&nbsp;таком понятии, как параллельное программирование.</p>
</section>
<section class="material__chapter">
<h2 id="1">Введение</h2>
<p>Сегодня мы&nbsp;создадим бота для Discord. Discord&nbsp;&mdash; бесплатный голосовой и&nbsp;текстовый чат, ориентированный в&nbsp;первую очередь на&nbsp;тех, кто играет в&nbsp;компьютерные игры. Однако его удобство, надежность и&nbsp;поддержка разных платформ позволяет использовать его не&nbsp;только в&nbsp;целях организации совместной игры. Есть много небольших команд разработчиков, которые используют Discord в&nbsp;рабочем процессе, в&nbsp;том числе и&nbsp;для автоматизации различных задач.</p>
<p>Для начала работы необходимо скачать клиент Discord с&nbsp;<a class="material__link" href="https://discordapp.com/" target="_blank" rel="noopener noreferrer">официального сайта</a>, установить его и&nbsp;зарегистрировать учетную запись, если ее&nbsp;еще нет.</p>
<p>Для работы с&nbsp;API Discord мы&nbsp;будем использовать библиотеку discord.py, которую сначала надо установить:</p>
<pre><code>pip install discord.py
</code></pre>
<p>discord.py полностью реализует API Discord, и&nbsp;предоставляет возможность создавать собственных ботов как с&nbsp;использованием декораторов (как при создании своих обработчиков во&nbsp;flask), так и&nbsp;с&nbsp;использованием объектно-ориентированного подхода.</p>
<p>Документацию на&nbsp;библиотеку можно найти <a class="material__link" href="https://discordpy.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer">тут</a>, а&nbsp;описание самого API&nbsp;&mdash; вот <a class="material__link" href="https://discordapp.com/developers/docs/intro" target="_blank" rel="noopener noreferrer">тут</a>.</p>
<p>Но&nbsp;прежде чем мы&nbsp;продолжим, надо упомянуть важный момент: discord.py&nbsp;&mdash; асинхронная библиотека. Это будет накладывать некоторый отпечаток на&nbsp;процесс разработки программ с&nbsp;ее&nbsp;использованием.</p>
</section>
<section class="material__chapter">
<h2 id="2">Асинхронное программирование</h2>
<p>Все время до&nbsp;этого момента мы&nbsp;писали <strong>синхронные</strong> программы, то&nbsp;есть такие, которые выполняются поэтапно. Если в&nbsp;коде написан последовательный вызов двух функций, то&nbsp;в&nbsp;синхронной программе интерпретатор вызовет первую, дождется завершения ее&nbsp;выполнения, а&nbsp;только затем вызовет вторую.</p>
<p>Такой подход достаточно понятен в&nbsp;написании программы: у&nbsp;нас есть гарантия того, какой кусок кода выполнится после какого, гарантия, что какие-то ресурсы (например, стандартный поток ввода <var>stdin</var>) будут использованы именно теми функциями, от&nbsp;которых мы&nbsp;этого ожидаем в&nbsp;каждый конкретный момент времени. Однако такой подход далеко не&nbsp;всегда удобен.</p>
<p>Давайте представим, что операционная система нашего компьютера работает полностью синхронно. Мы&nbsp;выбрали файл и&nbsp;начали копировать его из&nbsp;одной папки в&nbsp;другую. При синхронном подходе на&nbsp;время копирования файлов наша работа с&nbsp;операционной системой заблокирована до&nbsp;завершения текущей операции. Согласитесь, звучит не&nbsp;очень.</p>
<p>Когда мы&nbsp;говорим об&nbsp;асинхронном программировании, то&nbsp;подразумеваем создание такого кода, который позволяет программе не&nbsp;ждать завершения некоторого процесса, а&nbsp;продолжать работу не&nbsp;зависимо от&nbsp;него. Например, мы&nbsp;начали скачивать в&nbsp;браузере какой-то файл и&nbsp;после этого переключились на&nbsp;другую вкладку и&nbsp;продолжили заниматься своими делами.</p>
<p>Изначально в&nbsp;Python для решения задач асинхронного программирования использовались <strong>корутины</strong>, основанные на&nbsp;генераторах. Но, начиная с&nbsp;Python&nbsp;3.4, появился модуль asyncio, в&nbsp;котором реализованы механизмы асинхронного программирования. А&nbsp;в&nbsp;Python&nbsp;3.5 появилась конструкция <code>async/await</code>.</p>
<p>С&nbsp;помощью ключевого слова <var>async</var> при создании функции можно указать интерпретатору, что она является корутиной и&nbsp;может выполняться асинхронно. С&nbsp;помощью ключевого слова <var>await</var> мы&nbsp;можем вызвать такую функцию. Давайте рассмотрим очень простой пример:</p>
<pre><code class="language-python">import asyncio


async def work(name):
    print(f'{name} задача началась')
    await asyncio.sleep(1)
    print(f'{name} задача завершилась')


async def main():
    await asyncio.gather(
        asyncio.create_task(work('Первая')),
        asyncio.create_task(work('Вторая')),
    )


if __name__ == '__main__':
    asyncio.run(main())
</code></pre>
<p>Если мы&nbsp;запустим этот код, увидим такой вывод:</p>
<pre><samp>Первая задача началась
Вторая задача началась
Первая задача завершилась
Вторая задача завершилась</samp></pre>
<p>Внутри модуля asyncio много всего интересного, о&nbsp;чем можно почитать в&nbsp;<a class="material__link" href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener noreferrer">документации</a>, но&nbsp;для написания ботов для Discord нам будет достаточно этого небольшого введения.</p>
</section>
<section class="material__chapter">
<h2 id="3">Подготовка</h2>
<p>Чтобы получить доступ к&nbsp;API Discord, необходимо проделать несколько шагов и&nbsp;получить несколько токенов доступа. Во-первых, необходимо зарегистрироваться на&nbsp;самой платформе и&nbsp;подтвердить почту, которая была указана при регистрации.</p>
<p>После этого надо зайти на&nbsp;<a class="material__link" href="https://discordapp.com/developers/" target="_blank" rel="noopener noreferrer">портал для разработчиков</a>, авторизоваться там и&nbsp;нажать кнопку New application. Discord устроен так, что для создания бота необходимо сначала создать приложение для получения доступа к&nbsp;API, а&nbsp;потом к&nbsp;этому приложению можно будет добавить бота.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-3/discord-1.png" width="680" height="auto" /></div>
<p>После ввода имени приложения мы&nbsp;перейдем в&nbsp;настройки приложения.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-3/discord-2.png" width="680" height="auto" /></div>
<p>Затем для добавления к&nbsp;своему приложению бота перейдите на&nbsp;вкладку Bot и&nbsp;нажмите кнопку Add Bot. Можно сделать публичного бота, которого смогут добавлять все желающие, либо приватного, которого сможете добавлять только&nbsp;вы.</p>
<p>Остался последний штрих&nbsp;&mdash; добавить боту прав. Для этого воспользуемся вкладкой OAuth2. Выберем URL Generator&nbsp;&mdash;&nbsp;Scopes&nbsp;&mdash; Bot, а&nbsp;в&nbsp;Bot Permissions&nbsp;&mdash; Administrator.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-3/discord-3.png" width="680" height="auto" /></div>
<p>После этого перейдите по&nbsp;ссылке из поля GENERATED URL и&nbsp;добавьте бота на&nbsp;сервер. Это может быть личный сервер или любой, который вы&nbsp;создали в&nbsp;приложении Discord.</p>
<p>Бот добавился и&nbsp;написал автоматическое приветственное сообщение:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-3/discord-4.png" width="680" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="4">Простой бот</h2>
<p>Самый простой бот для Discord выглядит следующим образом:</p>
<pre><code class="language-python">import discord

TOKEN = "BOT_TOKEN"
intents = discord.Intents.default()
client = discord.Client(intents=intents)
client.run(TOKEN)
</code></pre>
<p>Чтобы эта программа заработала, надо получить для своего бота token.<img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/presentation/photo_2022-03-27%2019.36.56.jpeg" width="680" height="auto" /></p>
<p>Этот бот, конечно, ничего не&nbsp;делает, но&nbsp;можно явно посмотреть на&nbsp;ту&nbsp;структуру, которую предлагает нам модуль. Согласитесь, она очень похожа на&nbsp;flask. Так&nbsp;же, как и&nbsp;во&nbsp;flask, обработчики событий можно создавать с&nbsp;использованием декоратора. Тут это декоратор <code>client.event</code>.</p>
<p>Давайте добавим между созданием клиента и&nbsp;его запуском обработчик события <var>on_ready</var>, который выполнится после того, как бот будет запущен и&nbsp;подключится к&nbsp;Discord, то&nbsp;есть появится &laquo;В&nbsp;сети&raquo;.</p>
<pre><code class="language-python">@client.event
async def on_ready():
    print(f'{client.user} подключен к Discord!')
    for guild in client.guilds:
        print(
            f'{client.user} подключились к чату:\n'
            f'{guild.name}(id: {guild.id})'
        )
</code></pre>
<p>Этот обработчик пройдет по&nbsp;всем гильдиям (чатам), в&nbsp;которые добавлен бот, и&nbsp;выведет информацию об&nbsp;этом. Обратите внимание: наша функция асинхронная и&nbsp;определена с&nbsp;использованием ключевого слова <var>async</var>. Собственно, на&nbsp;этом все особенности в&nbsp;данном случае и&nbsp;заканчиваются.</p>
<p>В&nbsp;принципе, можно продолжать писать ботов с&nbsp;использованием декораторов, но&nbsp;библиотека discord.py позволяет использовать и&nbsp;объектно-ориентированный подход.</p>
</section>
<section class="material__chapter">
<h2 id="5">Объектно-ориентированный подход</h2>
<p>Давайте перепишем этот простой пример с&nbsp;использованием объектно-ориентированного подхода:</p>
<pre><code class="language-python">import discord

TOKEN = "BOT_TOKEN"


class YLBotClient(discord.Client):
    async def on_ready(self):
        print(f'{self.user} has connected to Discord!')
        for guild in self.guilds:
            print(
                f'{self.user} подключились к чату:\n'
                f'{guild.name}(id: {guild.id})')


intents = discord.Intents.default()
client = YLBotClient(intents=intents)
client.run(TOKEN)
</code></pre>
<p>Код получился еще проще и&nbsp;понятнее.</p>
<p>Добавим еще несколько штрихов к нашей программе, чтобы получилось как в настоящих промышленных системах. Надо добавить в нашу программу логирование. В саму библиотеку <strong>discord.py</strong> уже встроен стандартный логгер, надо только его настроить. Добавьте в начало программы следующий код.</p>
<pre><code class="language-python">import logging

logger = logging.getLogger('discord')
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s'))
logger.addHandler(handler)
</code></pre>
<p>Теперь в консоль будет выводиться вся информация о работе нашего бота, в т.ч. мы увидим какие события он обрабатывает.</p>
<pre><code class="language-python">2022-03-27 12:35:49,590:WARNING:discord.client: PyNaCl is not installed, voice will NOT be supported
2022-03-27 12:35:49,590:INFO:discord.client: logging in using static token
2022-03-27 12:35:51,041:INFO:discord.gateway: Shard ID None has sent the IDENTIFY payload.
2022-03-27 12:35:51,446:INFO:discord.gateway: Shard ID None has connected to Gateway: ["gateway-prd-main-k6dw",{"micros":190782,"calls":["discord-sessions-blue-prd-2-144",{"micros":188463,"calls":["start_session",{"micros":151206,"calls":["discord-api-7fbf95f445-g6mld",{"micros":138989,"calls":["get_user",{"micros":33933},"add_authorized_ip",{"micros":12363},"get_guilds",{"micros":16109},"coros_wait",{"micros":2}]}]},"guilds_connect",{"micros":2,"calls":[]},"presence_connect",{"micros":24866,"calls":[]}]}]}] (Session ID: fc7219be402e040768429d5363abbdb0).
2022-03-27 12:35:53,460:INFO:discord: yl_bot_test#0766 has connected to Discord!
    </code></pre>
<p>Если вам покажется, что информации слишком много, то можно изменить подробность логирования, указав другой уровень. Например, заменить <code class="language-python">logger.setLevel(logging.DEBUG)</code> на <code class="language-python">logger.setLevel(logging.INFO)</code>. Теперь заменим "принты" на правильное логирование:</p>
<pre><code class="language-python">    async def on_ready(self):
        logger.info(f'{self.user} has connected to Discord!')
        for guild in self.guilds:
            logger.info(
                f'{self.user} подключились к чату:\n'
                f'{guild.name}(id: {guild.id})')
</code></pre>
<p>Давайте добавим несколько обработчиков событий. Для начала напишем обработчик, который будет приветствовать присоединение к серверу нового пользователя <code>(on_member_join)</code> личным сообщением. Обработчик этого события будет принимать еще один аргумент&nbsp;&mdash; объект нового пользователя. Добавим новый метод к нашему классу.</p>
<pre><code class="language-python">async def on_member_join(self, member):
    await member.create_dm()
    await member.dm_channel.send(
        f'Привет, {member.name}!'
    )
</code></pre>
<p>Но этого еще недостаточно, чтобы сообщение о событии <code>(on_member_join)</code> отправлялось нашему боту. Надо еще сделать небольшую настройку.</p>
<p>На странице настройки приложения надо перейти на закладку <strong>Bot</strong> добавить для бота разрешения на получение событий об изменении статусов пользователей сервера. Надо включить <strong>PRESENCE INTENT</strong> и <strong>SERVER MEMBERS INTENT</strong>.</p>
<p>Строку инициализации клиента <code class="language-python">client = YLBotClient()</code> заменить на следующий код:</p>
<pre><code class="language-python">intents = discord.Intents.default()
intents.members = True
client = YLBotClient(intents=intents)
    </code></pre>
<p>Здесь мы создаем объект класса <code>intents</code>, в котором указываем, что наш бот будет получать события, связанные с пользователями.</p>
<p>В&nbsp;тот момент, когда к&nbsp;нам приходит новый пользователь, бот создает чат для прямой отправки сообщений этому пользователю и&nbsp;посылает в&nbsp;него сообщение. Обратите внимание: все вызовы внутренних функций и&nbsp;методов объектов модуля discord.py должны происходить с&nbsp;указанием ключевого слова <var>await</var>. Проверьте как это работает. Для этого подключите бота к своему серверу, включите его и пригласите кого-нибудь на сервер. Как только новый пользователь зайдет на сервер, он тут же получит в личку привет от нашего бота.</p>
<p>Теперь давайте добавим реакцию бота на&nbsp;какое-либо сообщение. Для этого необходимо в&nbsp;класс добавить метод <var>on_message</var>, который в&nbsp;качестве параметра принимает объект сообщения.</p>
<pre><code class="language-python">async def on_message(self, message):
    await message.channel.send("Спасибо за сообщение")
</code></pre>
<p>Мы&nbsp;получаем сообщение и&nbsp;отправляем свое в&nbsp;чат, в&nbsp;котором это сообщение было получено. Давайте запустим и&nbsp;посмотрим, что произойдет.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-3/discord-5.png" width="480" height="auto" /></div>
<p>Наш бот начнет отправлять сообщения бесконечно. Это связано с&nbsp;тем, что сообщения от&nbsp;самого бота также вызывают событие <var>on_message</var>. Чтобы этого не&nbsp;происходило, можно добавить проверку на&nbsp;автора сообщения:</p>
<pre><code class="language-python">if message.author == self.user:
    return
</code></pre>
<p>Разумеется внутри обработчика мы&nbsp;можем получить доступ к&nbsp;содержанию сообщения <var>message</var>. Сначала надо добавить для бота разрешения на получение текстов сообщений от пользователей сервера (<strong>MESSAGE CONTENT INTENT</strong>). Давайте проверим, что пользователь с&nbsp;нами поздоровался:</p>
<pre><code class="language-python">if "привет" in message.content.lower():
    await message.channel.send("И тебе привет")
</code></pre>
<p>Вот полный код нашего бота:</p>
<pre><code class="language-python">import discord
import logging

logger = logging.getLogger('discord')
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s'))
logger.addHandler(handler)

TOKEN = "BOT_TOKEN" # вставь свой токен


class YLBotClient(discord.Client):
    async def on_ready(self):
        logger.info(f'{self.user} has connected to Discord!')
        for guild in self.guilds:
            logger.info(
                f'{self.user} подключились к чату:\n'
                f'{guild.name}(id: {guild.id})')

    async def on_member_join(self, member):
        await member.create_dm()
        await member.dm_channel.send(
            f'Привет, {member.name}!'
        )

    async def on_message(self, message):
        if message.author == self.user:
            return
        if "привет" in message.content.lower():
            await message.channel.send("И тебе привет")
        else:
            await message.channel.send("Спасибо за сообщение")


intents = discord.Intents.default()
intents.members = True
intents.message_content = True
client = YLBotClient(intents=intents)
client.run(TOKEN)

    </code></pre>
</section>
<section class="material__chapter">
<h2 id="6">Команды</h2>
<p>Помимо простого анализа текста в&nbsp;Discord, как и&nbsp;в&nbsp;Telegram, можно создавать свои команды. При этом немного изменится структура программы: надо создавать уже не&nbsp;объект класса <var>Client</var>, а&nbsp;объект класса <var>Bot</var>, и&nbsp;использовать декоратор <var>bot.command</var>. Давайте сделаем бота, который будет возвращать случайное число от&nbsp;минимального до&nbsp;максимального, указанного пользователем.</p>
<p>Импортируем из&nbsp;модуля discord.ext модуль commands.</p>
<p>Сначала сделаем это с&nbsp;помощью отдельной функции:</p>
<pre><code class="language-python">import discord
from discord.ext import commands
import random, logging

logger = logging.getLogger('discord')
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s'))
logger.addHandler(handler)

intents = discord.Intents.default()
intents.members = True
intents.message_content = True

bot = commands.Bot(command_prefix='#!', intents=intents)


@bot.command(name='randint')
async def my_randint(ctx, min_int, max_int):
    num = random.randint(int(min_int), int(max_int))
    await ctx.send(num)


TOKEN = "BOT_TOKEN"

bot.run(TOKEN)
</code></pre>
<p>При создании бота необходимо указать подстроку <var>command_prefix</var>, с&nbsp;которой будут начинаться все команды. Параметры команды должны идти в&nbsp;сообщении через пробел после названия команды, но&nbsp;первым аргументом передается <strong>контекст</strong>, из&nbsp;которого мы&nbsp;можем получить чат и&nbsp;другую полезную информацию.</p>
<p>А&nbsp;теперь сделаем имитацию броска шестигранных кубиков, но&nbsp;уже с&nbsp;использованием объектно-ориентированного подхода:</p>
<pre><code class="language-python">import asyncio
import discord
from discord.ext import commands
import random, logging

logger = logging.getLogger('discord')
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s'))
logger.addHandler(handler)

intents = discord.Intents.default()
intents.members = True
intents.message_content = True
dashes = ['\u2680', '\u2681', '\u2682', '\u2683', '\u2684', '\u2685']


class RandomThings(commands.Cog):

    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='roll_dice')
    async def roll_dice(self, ctx, count):
        res = [random.choice(dashes) for _ in range(int(count))]
        await ctx.send(" ".join(res))

    @commands.command(name='randint')
    async def my_randint(self, ctx, min_int, max_int):
        num = random.randint(int(min_int), int(max_int))
        await ctx.send(num)


bot = commands.Bot(command_prefix='!#', intents=intents)

TOKEN = "BOTTOKEN"


async def main():
    await bot.add_cog(RandomThings(bot))
    await bot.start(TOKEN)


asyncio.run(main())
</code></pre>
<p>Обратите внимание: в&nbsp;таком случае нам надо наследоваться не&nbsp;от&nbsp;класса <var>Bot</var>, а&nbsp;от&nbsp;класса <var>Cog</var>, определять команды там, а&nbsp;потом добавлять их&nbsp;в&nbsp;бота методом <code>bot.add_cog</code>.</p>
</section>
<section class="material__chapter">
<h2 id="7">Заключение</h2>
<p>Возможности API Discord достаточно широкие, есть даже возможность подключаться к&nbsp;прослушиванию аудио-сообщений от&nbsp;пользователей канала. Простор для экспериментов действительно огромен.</p>
<p>Помимо рассмотренных, есть еще ряд платформ с&nbsp;хорошим API и&nbsp;библиотекам к&nbsp;нему на&nbsp;Python. К&nbsp;части из&nbsp;них доступ получить просто и&nbsp;мгновенно, где-то (например, для доступа к&nbsp;API Twitter) вас попросят написать мини-пояснение на&nbsp;тему &laquo;как вы&nbsp;хотите использовать API&raquo;, где-то&nbsp;&mdash; пройти дополнительную идентификацию и&nbsp;подтверждение личности.</p>
<p>Кроме того, рекомендуем посмотреть в&nbsp;сторону параллельного программирования. Такую парадигму поддерживает множество классных библиотек, например, веб-фреймворк <a class="material__link" href="https://www.tornadoweb.org/en/stable/index.html" target="_blank" rel="noopener noreferrer">Tornado</a>.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>