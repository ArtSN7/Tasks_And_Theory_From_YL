<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | QtDesigner </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок QtDesigner</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>QtDesigner, pyuic, два способа подключения uic-файла</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Установка QtDesigner и первый запуск</a></li>
<li><a class="material__link" href="#2">Подключение дизайна к программе</a></li>
<li><a class="material__link" href="#3">Размещение виджетов</a></li>
<li><a class="material__link" href="#4">Настройка PyCharm для работы с&nbsp;графическим интерфейсом</a></li>
<li><a class="material__link" href="#5">Экраны с высоким разрешением (HiRes)</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке разбирается популярный способ создания графических интерфейсов&nbsp;&mdash; с&nbsp;помощью программы QtDesigner.</p>
</section>
<section class="material__chapter">
<h2 id="1">Установка QtDesigner и первый запуск</h2>
<p>Когда на&nbsp;прошлом занятии мы&nbsp;создавали интерфейсы &laquo;руками&raquo; и&nbsp;размещали виджеты &laquo;на&nbsp;глазок&raquo;, вы&nbsp;наверняка подумали, что есть какой-то более простой способ. И&nbsp;он&nbsp;действительно есть. Это программа <strong>QtDesigner</strong>, которая включена в&nbsp;сборку PyQT5. Но&nbsp;для ее&nbsp;использования необходимо установить библиотек<strong>QtDesigner</strong>у <var>pyqt5-tools</var>.</p>
<pre><code>pip install pyqt5-tools
</code></pre>
<p>Теперь программа находится на&nbsp;вашем компьютере по&nbsp;адресу:</p>
<pre><code>Путь_к_папке_где_установлен_Python\Lib\site-packages\qt5_applications\Qt\bin\designer.exe
</code></pre>
<p>или (для старых версий):</p>
<pre><code>Путь_к_папке_где_установлен_Python\Lib\site-packages\pyqt5_tools\designer.exe
</code></pre>
<p>Создайте ярлык к&nbsp;этой программе, поскольку использовать ее&nbsp;придется часто.</p>
<p>Так же можно скачать и установить программу <strong>QtDesigner</strong> в виде отдельного приложения. Для этого перейдите по <a class="material__link" href="https://build-system.fman.io/qt-designer-download" target="_blank" rel="noopener noreferrer">ссылке</a> и скачайте установщик приложения дла вашей операционной системы.</p>
<p>Давайте запустим программу и&nbsp;посмотрим, что в&nbsp;ней можно сделать.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/pyqt-2-1.png" width="680" height="auto" /></div>
<p>При запуске открывается окно с&nbsp;предложением выбрать шаблон для формы или виджет, на&nbsp;основе которого мы&nbsp;будем делать свой интерфейс. Выберем <strong>Main Window</strong>. Откроется пустое окно.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/pyqt-2-2.png" width="680" height="auto" /></div>
<p>Теперь рассмотрим, что у&nbsp;нас есть, кроме пустой формы, которую мы&nbsp;будем заполнять.</p>
<p>Слева&nbsp;&mdash; меню виджетов, <strong>Widget Box</strong>. В&nbsp;нем они сгруппированы в&nbsp;зависимости от&nbsp;их&nbsp;функциональности. Отдельно кнопки, отдельно виджеты для ввода данных и&nbsp;так далее.</p>
<p>Справа&nbsp;&mdash; Инспектор объектов (<strong>Object Inspector</strong>), Редактор свойств (<strong>Property Editor</strong>) и&nbsp;Браузер ресурсов (<strong>Resourse Browser</strong>). Остановимся на&nbsp;первых двух. В&nbsp;<strong>Инспекторе объектов</strong> отображается информация об&nbsp;используемых виджетах. Для каждого виджета указывается его имя и&nbsp;класс. Кроме того, можно увидеть иерархическую структуру всего интерфейса.</p>
<p>Чтобы разместить виджет на&nbsp;форме, его надо просто перетащить из&nbsp;меню виджетов. При этом информация об&nbsp;этом виджете автоматически появится в&nbsp;Инспекторе объектов.</p>
<p><strong>Редактор свойств</strong> помогает изменять значения тех или иных атрибутов виджета (например, текст или размер). Расположение свойств меняется кнопкой с&nbsp;изображением гаечного ключа.</p>
<p>Попробуйте создать простейший интерфейс из&nbsp;кнопки (<var>PushButton</var>) и&nbsp;текстового поля (<var>TextLabel</var>), поиграйте с&nbsp;<strong>Редактором свойств</strong>, разберитесь, где поменять название и&nbsp;размеры кнопки, как изменить шрифт в&nbsp;<var>TextLabel</var>. После того как у&nbsp;вас вышло что-то похожее на&nbsp;картинку, ниже сохраните полученный дизайн. Для сохранения в&nbsp;меню <strong>Файл</strong> выберите вкладку <strong>Сохранить как</strong>, найдите папку проекта и&nbsp;впишите имя.</p>
<p>Помните: название объекта (атрибут <var>objectName</var>) и&nbsp;текст, который может быть на&nbsp;нем показан (атрибут <var>text</var>),&nbsp;&mdash; это разные вещи.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/pyqt-2-3.png" width="371" height="auto" /></div>
<p>Давайте посмотрим, как выглядит наш дизайн с&nbsp;точки зрения компьютера. Для этого откроем созданный нами файл с&nbsp;помощью любого текстового редактора. Лучше использовать не&nbsp;просто Блокнот, а, например, SublimeText, Notepad++ или VS&nbsp;Code. Содержимое файла будет примерно вот таким:</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ui version="4.0"&gt;
 &lt;class&gt;MainWindow&lt;/class&gt;
 &lt;widget class="QMainWindow" name="MainWindow"&gt;
  &lt;property name="geometry"&gt;
   &lt;rect&gt;
    &lt;x&gt;0&lt;/x&gt;
    &lt;y&gt;0&lt;/y&gt;
    &lt;width&gt;554&lt;/width&gt;
    &lt;height&gt;379&lt;/height&gt;
   &lt;/rect&gt;
  &lt;/property&gt;
  &lt;property name="windowTitle"&gt;
   &lt;string&gt;MainWindow&lt;/string&gt;
  &lt;/property&gt;
  &lt;widget class="QWidget" name="centralwidget"&gt;
   &lt;widget class="QPushButton" name="pushButton"&gt;
    &lt;property name="geometry"&gt;
     &lt;rect&gt;
      &lt;x&gt;210&lt;/x&gt;
      &lt;y&gt;200&lt;/y&gt;
      &lt;width&gt;93&lt;/width&gt;
      &lt;height&gt;28&lt;/height&gt;
     &lt;/rect&gt;
    &lt;/property&gt;
    &lt;property name="text"&gt;
     &lt;string&gt;Нажми меня&lt;/string&gt;
    &lt;/property&gt;
    &lt;property name="checkable"&gt;
     &lt;bool&gt;true&lt;/bool&gt;
    &lt;/property&gt;
   &lt;/widget&gt;
   &lt;widget class="QLabel" name="label"&gt;
    &lt;property name="geometry"&gt;
     &lt;rect&gt;
      &lt;x&gt;130&lt;/x&gt;
      &lt;y&gt;80&lt;/y&gt;
      &lt;width&gt;281&lt;/width&gt;
      &lt;height&gt;61&lt;/height&gt;
     &lt;/rect&gt;
    &lt;/property&gt;
    &lt;property name="font"&gt;
     &lt;font&gt;
      &lt;pointsize&gt;24&lt;/pointsize&gt;
     &lt;/font&gt;
    &lt;/property&gt;
    &lt;property name="text"&gt;
     &lt;string&gt;Текст на метке&lt;/string&gt;
    &lt;/property&gt;
    &lt;property name="textFormat"&gt;
     &lt;enum&gt;Qt::AutoText&lt;/enum&gt;
    &lt;/property&gt;
   &lt;/widget&gt;
  &lt;/widget&gt;
  &lt;widget class="QMenuBar" name="menubar"&gt;
   &lt;property name="geometry"&gt;
    &lt;rect&gt;
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;0&lt;/y&gt;
     &lt;width&gt;554&lt;/width&gt;
     &lt;height&gt;26&lt;/height&gt;
    &lt;/rect&gt;
   &lt;/property&gt;
  &lt;/widget&gt;
  &lt;widget class="QStatusBar" name="statusbar"/&gt;
 &lt;/widget&gt;
 &lt;resources/&gt;
 &lt;connections/&gt;
&lt;/ui&gt;
</code></pre>
<p>Если вы&nbsp;послушали наш совет и&nbsp;посмотрели в&nbsp;течение лета материалы по&nbsp;HTML, то&nbsp;наверняка увидите знакомые конструкции. Конечно, это не&nbsp;HTML, а&nbsp;язык разметки XML. Если присмотреться, мы&nbsp;увидим, что внутри этого документа описаны все наши виджеты и&nbsp;их&nbsp;свойства, а&nbsp;также показана их&nbsp;вложенность друг в&nbsp;друга.</p>
</section>
<section class="material__chapter">
<h2 id="2">Подключение дизайна к программе</h2>
<p>Теперь у&nbsp;нас есть дизайн, но&nbsp;нам надо подключить его к&nbsp;программе. Для этого есть два способа.</p>
<p><strong>Способ первый: загрузка ui-файла</strong></p>
<pre><code class="language-python">import sys

from PyQt5 import uic  # Импортируем uic
from PyQt5.QtWidgets import QApplication, QMainWindow


class MyWidget(QMainWindow):
    def __init__(self):
        super().__init__()
        uic.loadUi('01.ui', self)  # Загружаем дизайн
        self.pushButton.clicked.connect(self.run)
        # Обратите внимание: имя элемента такое же как в QTDesigner

    def run(self):
        self.label.setText("OK")
        # Имя элемента совпадает с objectName в QTDesigner


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = MyWidget()
    ex.show()
    sys.exit(app.exec_())
</code></pre>
<p>Для загрузки ui-файла импортируйте класс <var>uic</var>, а&nbsp;затем в&nbsp;конструкторе вызовите метод <var>loadUi</var>, где одним из&nbsp;параметров указывается файл с&nbsp;интерфейсом. В&nbsp;нашем примере он&nbsp;называется 01.ui и&nbsp;лежит в&nbsp;той&nbsp;же папке, что и&nbsp;запускаемый нами скрипт.</p>
<p>После выполнения метода <var>loadUi</var> все виджеты становятся полями класса, имена для которых мы&nbsp;задали в&nbsp;редакторе свойств. Затем можно работать с&nbsp;ними точно так&nbsp;же, как в&nbsp;предыдущем уроке. Что мы&nbsp;и&nbsp;делаем, подключая обработчик нажатия кнопки.</p>
<p><strong>Способ второй: использование pyuic</strong></p>
<p>Второй способ&nbsp;&mdash; конвертирование ui-файла в&nbsp;класс Python. Для этого нужна консольная утилита <strong>pyuic5</strong>.</p>
<p>Чтобы ею&nbsp;воспользоваться, нужно открыть командную строку (терминал), перейти в&nbsp;ту&nbsp;папку, где лежит ваш ui-файл, и&nbsp;выполнить следующую команду:</p>
<pre><code>pyuic5 ui_file.ui -o ui_file.py
</code></pre>
<p>Давайте посмотрим, что находится внутри получившегося файла. (В&nbsp;зависимости от&nbsp;того, что вы&nbsp;сделали в&nbsp;QtDesigner, содержимое файла будет отличаться, но&nbsp;смысл останется неизменным.)</p>
<pre><code class="language-python">
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '01.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(554, 379)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(180, 200, 111, 28))
        self.pushButton.setCheckable(True)
        self.pushButton.setObjectName("pushButton")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(130, 80, 281, 61))
        font = QtGui.QFont()
        font.setPointSize(24)
        self.label.setFont(font)
        self.label.setTextFormat(QtCore.Qt.AutoText)
        self.label.setObjectName("label")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 554, 28))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "Нажми меня"))
        self.label.setText(_translate("MainWindow", "Текст на метке"))
</code></pre>
<p>Очень похоже на&nbsp;то, что мы&nbsp;делали на&nbsp;прошлом уроке, не&nbsp;правда&nbsp;ли? Только весь код написан не&nbsp;в&nbsp;инициализаторе, а&nbsp;в&nbsp;методе <code>setupUi()</code>. Утилита pyuic5 конвертирует XML-описание разметки из&nbsp;ui-файла в&nbsp;класс Python с&nbsp;кодом, создающим точно такой&nbsp;же интерфейс.</p>
<p>В&nbsp;получившемся файле нет кода для запуска приложения и&nbsp;никаких обработчиков событий. Есть соблазн дописать код в&nbsp;получившийся файл, но&nbsp;делать этого не&nbsp;стоит, и&nbsp;вот почему: никто из&nbsp;нас не&nbsp;идеален и&nbsp;не&nbsp;может написать интерфейс сразу так, чтобы в&nbsp;него никогда потом не&nbsp;пришлось вносить изменения. Поэтому если мы&nbsp;перемешаем код интерфейса и&nbsp;наш код с&nbsp;логикой, а&nbsp;потом поправим дизайн, после конвертации вся наша работа пропадет. К&nbsp;счастью, есть простой выход из&nbsp;ситуации.</p>
<p>В&nbsp;блоке по&nbsp;ООП мы&nbsp;говорили про множественное наследование, и&nbsp;говорили, что использовать его надо аккуратно и&nbsp;далеко не&nbsp;всегда. Ситуация с&nbsp;разделением интерфейса и&nbsp;логики исполнения&nbsp;&mdash; как раз звездный час для множественного наследования.</p>
<p>Давайте создадим новый py-файл рядом с&nbsp;классом, который получился после конвертации интерфейса, вот с&nbsp;таким кодом:</p>
<pre><code class="language-python">import sys

from PyQt5.QtWidgets import QApplication, QMainWindow
from ui_01 import Ui_MainWindow


# Наследуемся от виджета из PyQt5.QtWidgets и от класса с интерфейсом
class MyWidget(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        # Вызываем метод для загрузки интерфейса из класса Ui_MainWindow,
        # остальное без изменений
        self.setupUi(self)
        self.pushButton.clicked.connect(self.run)

    def run(self):
        self.label.setText("OK")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = MyWidget()
    ex.show()
    sys.exit(app.exec_())

</code></pre>
<p>Предками нашего класса <var>MyWidget</var> являются и&nbsp;<var>QMainWindow</var>, и&nbsp;<var>Ui_MainWindow</var>. От&nbsp;первого унаследованы методы, а&nbsp;от&nbsp;второго&nbsp;&mdash; дизайн. В&nbsp;остальном работа схожа: мы&nbsp;вызываем метод <var>setupUi</var> из&nbsp;<var>Ui_MainWindow</var>, а&nbsp;затем просто работаем с&nbsp;полями.</p>
<p><strong>Какой способ лучше?</strong></p>
<p>Так какой&nbsp;же способ лучше? Ответ на&nbsp;этот вопрос неожиданный&nbsp;&mdash; оба метода уместны в&nbsp;определенных ситуациях.</p>
<p>Загрузка ui-файла очень удобна, когда наше приложение находится на&nbsp;стадии разработки и&nbsp;нам постоянно надо вносить какие-либо изменения в&nbsp;наш интерфейс. В&nbsp;таких случаях постоянная конвертация файла только замедляет процесс разработки. На&nbsp;самом деле конвертация происходит и&nbsp;в&nbsp;этом случае: метод <code>uic.loadUi()</code> выполняет эту конвертацию каждый раз при запуске приложения (а&nbsp;точнее каждый раз, когда выполняется эта строчка кода), что может сильно снизить производительность приложения.</p>
<p>Поэтому хорошим советом будет следующий:</p>
<ul>
<li>На&nbsp;этапе разработки подключайте интерфейс с&nbsp;помощью ui-файлов</li>
<li>Для релиза сконвертируйте весь интерфейс в&nbsp;классы Python</li>
</ul>
</section>
<section class="material__chapter">
<h2 id="3">Размещение виджетов</h2>
<p>Простое &laquo;накидывание&raquo; виджетов в&nbsp;QtDesigner или из&nbsp;кода работает неплохо. Проблемы начинаются, когда мы&nbsp;попытаемся каким-либо образом изменять размеры окна нашего приложения. В&nbsp;этом случае какие-то виджеты перестают частично или полностью попадать в&nbsp;поле зрения пользователя, и&nbsp;приложением становится неудобно пользоваться. Однако и&nbsp;с&nbsp;этой проблемой мы&nbsp;можем легко справиться, как программно, так и&nbsp;при помощи QtDesigner.</p>
<p>В&nbsp;QtDesigner можно размещать виджеты на&nbsp;экране не&nbsp;хаотично, а&nbsp;упорядоченно. Этот процесс называется разметкой. Для этого есть виджеты, которые называются <strong>Layout</strong> (Разметка): Vertical, Horizontal, Grid и&nbsp;Form Layout.</p>
<p>Но&nbsp;они нужны не&nbsp;только для красивого размещения элементов интерфейса, но&nbsp;и&nbsp;для создания групп из&nbsp;виджетов, например, для Radio Button (элемент интерфейса, который позволяет пользователю выбрать одну опцию (пункт) из предопределенного набора (группы)). Когда мы&nbsp;работаем с&nbsp;радиокнопками, можем выбрать только одну из&nbsp;них. А&nbsp;как поступить в&nbsp;том случае, когда у&nbsp;нас несколько логических групп, в&nbsp;каждой их&nbsp;которых нужно сделать выбор? Если мы&nbsp;просто разместим все Radio Button на&nbsp;нашем виджете, то&nbsp;никак не&nbsp;сможем выбрать два. А&nbsp;вот если часть из&nbsp;них поместить в&nbsp;какой-нибудь Layout&nbsp;&mdash; легко.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/pyqt-2-4.png" width="418" height="auto" /></div>
<p>Давайте посмотрим на&nbsp;то, как будут выглядеть привычные нам <var>PushButton</var> при применении к&nbsp;ним различных layout-ов.</p>
<p>Разместим изначально наши кнопки на&nbsp;форме в&nbsp;случайном порядке.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/qt-res-2-1.png" width="417" height="auto" /></div>
<p>Затем поместим их&nbsp;внутрь <strong>Vertical Layout</strong>.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/qt-res-2-2.png" width="416" height="auto" /></div>
<p>Теперь&nbsp;&mdash; в&nbsp;<strong>Horizontal Layout</strong>.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/qt-res-2-3.png" width="518" height="auto" /></div>
<p>В&nbsp;случае использования <strong>Grid Layout</strong> появляются различные варианты:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/qt-res-2-4.png" width="666" height="auto" /></div>
<p>А&nbsp;<strong>Form Layout</strong> является подвидом <strong>Grid Layout</strong>. У&nbsp;него фиксированное число столбцов, равное двум. Как можно догадаться по&nbsp;названию, такой layout удобнее всего использовать для создания форм, где в&nbsp;первый столбец размещаются подсказки для полей, а&nbsp;во&nbsp;второй&nbsp;&mdash; виджеты для ввода значения.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/qt-res-2-5.png" width="516" height="auto" /></div>
<p>Создавать Layout можно и&nbsp;из&nbsp;кода напрямую, точно также, как мы&nbsp;это делали с&nbsp;другими виджетами. Для добавления элементов в&nbsp;Layout у&nbsp;них всех существует метод <code>addWidget()</code>, который принимает виджет, который надо разместить, и&nbsp;дополнительные настройки размещения. Например, чтобы добавить виджет в&nbsp;Grid Layout, можно написать такой код: <code>grid.addWidget(elem, x, y)</code>. В&nbsp;качестве параметров метода выступают виджет, а&nbsp;также координаты ячейки, по&nbsp;которым его нужно расположить. Подробнее можно почитать в&nbsp;<a class="material__link" href="https://doc.qt.io/qtforpython/PySide2/QtWidgets/QLayout.html" target="_blank" rel="noopener noreferrer">документации</a>.</p>
<p>Кроме Layout, существуют и&nbsp;виджеты для создания виртуальных групп (вроде <var>QButtonGroup</var>). Чаще всего они нужны, когда у&nbsp;нас есть много виджетов с&nbsp;одинаковыми функциями. Например, у&nbsp;нас много Radio Button, но&nbsp;они все отвечают за&nbsp;один и&nbsp;тот&nbsp;же параметр&nbsp;&mdash; цвет. Чтобы объединить Radio Button в&nbsp;группу в&nbsp;QtDesigner, необходимо выделить&nbsp;их, нажать на&nbsp;правую кнопку мыши, кликнуть пункт меню <strong>Assign to&nbsp;button group</strong> и&nbsp;выбрать либо пункт создания новой группы (<strong>New button group</strong>), либо уже созданную. Чтобы &laquo;повесить&raquo; на&nbsp;всю группу обработчик событий, нужно вызвать уже знакомый нам метод <var>connect</var>.</p>
<pre><code class="language-python">self.buttonGroup.buttonClicked.connect(self.run)
</code></pre>
<p>А&nbsp;чтобы получить список всех кнопок группы, примените метод <code>.buttons()</code>.</p>
</section>
<section class="material__chapter">
<h2 id="4">Настройка PyCharm для работы с&nbsp;графическим интерфейсом</h2>
<p>Как&nbsp;вы, наверное, уже могли заметить, PyCharm &laquo;из&nbsp;коробки&raquo; не&nbsp;очень-то дружит с&nbsp;ui-файлами, а&nbsp;конвертация файлов, пусть и&nbsp;не&nbsp;сложная, но&nbsp;требует некоторых манипуляций в&nbsp;командной строке. Давайте попробуем немного облегчить себе жизнь.</p>
<p>Сначала добавим открытие ui-файлов в&nbsp;QtDesigner непосредственно из&nbsp;PyCharm. Для этого зайдем в&nbsp;настройки PyCharm, перейдем по&nbsp;пути Settings&nbsp;&rarr;&nbsp;Tools&nbsp;&rarr;&nbsp;External Editor и&nbsp;нажмем плюсик.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/pyqt-2-5.png" width="680" height="auto" /></div>
<p>В&nbsp;появившейся форме введем следующую информацию:</p>
<ul>
<li>Name: <strong>Qt Designer</strong></li>
<li>Program: <strong>Путь_к_папке_где_установлен_Python\Lib\site-packages\qt5_applications\Qt\bin\designer.exe</strong> (Например: C:\Python37\Lib\site-packages\qt5_applications\Qt\bin\designer.exe )</li>
<li>Arguments: <strong>$FileName$</strong></li>
<li>Working Directory: <strong>$FileDir$</strong></li>
</ul>
<p>Теперь добавим возможность быстрого конвертирования ui-файл в&nbsp;py-файл. Снова жмем плюсик, находясь в&nbsp;там&nbsp;же настройках (по&nbsp;пути Settings&nbsp;&rarr;&nbsp;Tools&nbsp;&rarr;&nbsp;External Editor):</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/pyqt-2-6.png" width="680" height="auto" /></div>
<p>В&nbsp;появившейся форме введем следующую информацию:</p>
<ul>
<li>Name: <strong>Pyuic</strong></li>
<li>Prorgam: <strong>&lt;Папка с питоном&gt;\Scripts\pyuic5.exe</strong> (Например: C:\Python37\Scripts\pyuic5.exe )</li>
<li>Arguments: <strong>$FileName$ -o $FileNameWithoutAllExtensions$.py</strong></li>
<li>Working Directory: <strong>$ProjectFileDir$</strong></li>
</ul>
<p>Теперь мы&nbsp;в&nbsp;проекте можем нажать правой кнопкой на&nbsp;ui-файл и, выбрав в&nbsp;меню External Tools, выбрать нужную опцию: либо открыть его для редактирования в&nbsp;QtDesigner, либо конвертировать в&nbsp;py-файл.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-2/pyqt-2-7.png" width="471" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="5">Экраны с высоким разрешением (HiRes)</h2>
На экранах с высоким разрешением некоторые интерфейсы, разработанные для стандартного разрешения, могут выглядеть не корректно или мелко. Есть много способов решения этой проблемы. Вот один из них. До начала запуска основного приложения Qt и до описания своих виджетов добавьте вот такие строки:
<pre><code class="language-python">from PyQt5 import QtCore, QtWidgets

if hasattr(QtCore.Qt, 'AA_EnableHighDpiScaling'):
    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)

if hasattr(QtCore.Qt, 'AA_UseHighDpiPixmaps'):
    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)
    </code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>