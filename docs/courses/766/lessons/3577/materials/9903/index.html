<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Чат-боты 1 (ВКонтакте) </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Чат-боты ВК</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Чат-боты 1</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Про чат-ботов</a></li>
<li><a class="material__link" href="#2">Выполнение запросов от&nbsp;имени пользователя</a></li>
<li><a class="material__link" href="#3">Загрузка файлов</a></li>
<li><a class="material__link" href="#4">Работа с&nbsp;событиями и&nbsp;чатами</a></li>
<li><a class="material__link" href="#5">Заключение</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом цикле дополнительных занятий мы&nbsp;поговорим о&nbsp;создании чат-ботов для различных популярных платформ и&nbsp;начнем, пожалуй, с&nbsp;самой популярной социальной сети в&nbsp;России и&nbsp;странах СНГ&nbsp;&mdash; vk.com.</p>
</section>
<section class="material__chapter">
<h2 id="1">Про чат-ботов</h2>
<p>Мы&nbsp;уже не&nbsp;раз использовали API сторонних сервисов для своих нужд, вызывая его из&nbsp;программ для встраивания в&nbsp;некоторый наш желаемый сценарий преобразования данных. Многие платформы пошли еще дальше и&nbsp;начали предоставлять разработчикам более продвинутое API, которое позволяет практически встроить свое приложение в&nbsp;эту платформу прозрачно для пользователя. При таком подходе пользователь получает функциональность вашего приложения, не&nbsp;покидая привычного интерфейса сервиса или социальной сети.</p>
<p>Последние годы такой подход набрал очень большую популярность, количество платформ с&nbsp;качественным API для разработки своих ботов растет. Сегодня мы&nbsp;рассмотрим API самой популярной социальной сети в&nbsp;России и&nbsp;странах СНГ&nbsp;&mdash; vk.com.</p>
<p>API для vk.com и&nbsp;для многих подобных платформ можно условно разделить на&nbsp;две части:</p>
<ul>
<li>Пользовательское API</li>
<li>API ботов</li>
</ul>
<p>Когда мы&nbsp;выполняем некоторое обращение к&nbsp;пользовательскому API, мы&nbsp;авторизуемся и&nbsp;выполняем действия от&nbsp;лица этого пользователя, то&nbsp;есть все изменения будут выполнены как&nbsp;бы руками самого пользователя: он&nbsp;будет автором сообщения, записи на&nbsp;стене, загруженного изображения и&nbsp;т.&nbsp;д. Такой подход позволяет создавать программы, имитирующие реальных людей или альтернативные клиенты для платформы. Чтобы снизить количество мошенников, которые разрабатывают &laquo;поддельных&raquo; пользователей, разработчики обычно накладывают ограничение на&nbsp;использование такого типа API, например, делают некоторые методы недоступными (совсем или без дополнительного подтверждения вашей личности).</p>
<p>API ботов, как правило, не&nbsp;имеют таких ограничений, но&nbsp;пользователь будет обязательно осведомлен, что он&nbsp;общается не&nbsp;с&nbsp;человеком, а&nbsp;с&nbsp;некоторой сущностью внутри системы. В&nbsp;случае vk&nbsp;такая сущность называется &laquo;Сообщество&raquo;. Это не&nbsp;обязательно именно программа, разбирать сообщения в&nbsp;сообществе могут и&nbsp;реальные люди, но&nbsp;именно разделение на&nbsp;пользователей и&nbsp;сообщества позволяет ввести особые возможности по&nbsp;автоматизации деятельности последних.</p>
<p>В&nbsp;описании API обязательно присутствует информация о&nbsp;том, кто может вызывать тот или иной сервис: пользователь и/или бот и/или кто-то еще. Для vk.com данная информация выглядит так:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-1/chat-bot-1.png" width="680" height="auto" /></div>
<p>Мы&nbsp;рассмотрим несколько примеров как разрабатывать программы на&nbsp;Python, которые действуют как от&nbsp;имени пользователя, так и&nbsp;от&nbsp;имени сообщества.</p>
<p>Никто не&nbsp;запрещает нам обращаться к&nbsp;API vk.com с&nbsp;использованием методов библиотеки requests, но&nbsp;зачастую в&nbsp;PyPi уже есть библиотеки, которые немного облегчают нам доступ к&nbsp;API популярных сервисов. Мы&nbsp;рассмотрим библиотеку vk_api: одну из&nbsp;самых популярных, но&nbsp;не&nbsp;единственную. Сначала ее&nbsp;надо установить:</p>
<pre><code>pip install vk_api
</code></pre>
</section>
<section class="material__chapter">
<h2 id="2">Выполнение запросов от&nbsp;имени пользователя</h2>
<p>Для выполнения запросов от&nbsp;имени пользователя необходимо указать его логин и&nbsp;пароль в&nbsp;своей программе (или ввести с&nbsp;клавиатуры, считать из&nbsp;файла).</p>
<p>У&nbsp;vk.com есть достаточно подробное описание сервисов, доступное <a class="material__link" href="https://vk.com/dev/manuals" target="_blank" rel="noopener noreferrer">тут</a>. Модуль vk_api представляет из&nbsp;себя некоторую обертку, которая делает часть работы по&nbsp;формированию запроса и&nbsp;разбору ответа за&nbsp;нас. Давайте получим три сообщения со&nbsp;стены пользователя, начиная со&nbsp;второго, то&nbsp;есть обратимся к&nbsp;методу <a class="material__link" href="https://vk.com/dev/wall.get" target="_blank" rel="noopener noreferrer">wall.get</a> API.</p>
<pre><code class="language-python">import vk_api


def main():
    login, password = LOGIN, PASSWORD
    vk_session = vk_api.VkApi(login, password)
    try:
        vk_session.auth(token_only=True)
    except vk_api.AuthError as error_msg:
        print(error_msg)
        return
    vk = vk_session.get_api()
    # Используем метод wall.get
    response = vk.wall.get(count=3, offset=1)
    if response['items']:
        for i in response['items']:
            print(i)


if __name__ == '__main__':
    main()
</code></pre>
<p>Для доступа к&nbsp;API необходимо создать объект типа <var>VkApi</var>, который принимает на&nbsp;вход два обязательных параметра&nbsp;&mdash; логин и&nbsp;пароль пользователя. После этого пытаемся авторизоваться, если нам это не&nbsp;удается, печатаем текст ошибки и&nbsp;завершаем работу программы. После успешной авторизации необходимо создать объект класса <var>VkApiMethod</var>, который позволит обращаться к&nbsp;методам API как к&nbsp;методам класса. То&nbsp;есть для обращения к&nbsp;сервису <var>wall.get</var> API необходимо написать код <code>vk.wall.get()</code>, где&nbsp;<code>vk: VkApiMethod</code>. В&nbsp;качестве аргументов метода надо передать параметры вызова сервиса.</p>
<p>Обратите внимание: все методы, которые отвечают за&nbsp;вызов сервисов API, не&nbsp;содержат позиционных аргументов, только именованные.</p>
<p>При вызове сервиса получения сообщений со&nbsp;стены указываем параметр <var>count</var>&nbsp;&mdash; количество записей, затем <var>offset</var>&nbsp;&mdash; необязательный параметр, который указывает на&nbsp;то, начиная с&nbsp;какой записи надо возвращать результат. При вызове метода можно также указать <var>owner_id</var>&nbsp;&mdash; идентификатор пользователя или сообщества, со&nbsp;стены которых надо вернуть записи. По&nbsp;умолчанию записи возвращаются для пользователя, чей логин и&nbsp;пароль мы&nbsp;ввели. Результат нам вернется в&nbsp;виде json, описание полей которого можно посмотреть в&nbsp;документации.</p>
<p>Проблема с&nbsp;авторизацией может возникнуть не&nbsp;только в&nbsp;случае неправильного логина или пароля. Приведенный пример не&nbsp;сработает, если у&nbsp;пользователя, под которым мы&nbsp;пытаемся авторизоваться, настроена двухфакторная аутентификация. В&nbsp;этом случае пользователю нужно дополнительно ввести одноразовый код для подтверждения полномочий нашей программы. Чтобы корректно обрабатывать двухфакторную аутентификацию, необходимо написать такой код:</p>
<pre><code class="language-python">import vk_api


def auth_handler():
    """ При двухфакторной аутентификации вызывается эта функция. """

    # Код двухфакторной аутентификации,
    # который присылается по смс или уведомлением в мобильное приложение
    key = input("Enter authentication code: ")
    # Если: True - сохранить, False - не сохранять.
    remember_device = True

    return key, remember_device


def main():
    login, password = LOGIN, PASSWORD
    vk_session = vk_api.VkApi(
        login, password,
        # функция для обработки двухфакторной аутентификации
        auth_handler=auth_handler
    )

    try:
        vk_session.auth(token_only=True)
    except vk_api.AuthError as error_msg:
        print(error_msg)
        return

    # ...


if __name__ == '__main__':
    main()
</code></pre>
<p>Рассмотрим еще несколько примеров обращения к&nbsp;API. Получим список своих друзей, то&nbsp;есть вызовем метод API <a class="material__link" href="https://vk.com/dev/friends.get" target="_blank" rel="noopener noreferrer">friends.get</a>. Помимо основных полей, которые возвращает сервис, попросим еще дату рождения и&nbsp;город:</p>
<pre><code class="language-python">    response = vk.friends.get(fields="bdate, city")
    if response['items']:
        for i in response['items']:
            print(i)
</code></pre>
<p>Получим информацию о&nbsp;каком-нибудь пользователе по&nbsp;id&nbsp;&mdash; <a class="material__link" href="https://vk.com/dev/users.get" target="_blank" rel="noopener noreferrer">users.get</a>:</p>
<pre><code class="language-python">    response = vk.users.get(user_id=идентификатор_пользователя)
    print(response)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Загрузка файлов</h2>
<p>API vk.com поддерживает загрузку разных типов файлов, причем для каждого из&nbsp;типов&nbsp;&mdash; изображения, видео, документы&nbsp;&mdash; используются разные сервисы. Однако вне зависимости от&nbsp;типа файла весь процесс сводится к&nbsp;тому, что надо загрузить файл на&nbsp;сервер и&nbsp;получить его идентификатор, а&nbsp;затем прикладывать идентификатор туда, куда мы&nbsp;хотим приложить изображение: в&nbsp;сообщение, на&nbsp;стену, в&nbsp;ленту сообщества и&nbsp;т.&nbsp;д. Подробное описание можно прочитать <a class="material__link" href="https://vk.com/dev/upload_files" target="_blank" rel="noopener noreferrer">тут</a>. В&nbsp;модуле vk_api все методы по&nbsp;загрузке файлов обернуты в&nbsp;класс <var>VkUpload</var>.</p>
<p>Рассмотрим, как это работает, на&nbsp;примере загрузки изображения и&nbsp;создания сообщения с&nbsp;ним на&nbsp;стену:</p>
<pre><code class="language-python">upload  = vk_api.VkUpload(vk_session)
photo = upload.photo_wall(['Picture1.png']
)

vk_photo_id = f"photo{photo[0]['owner_id']}_{photo[0]['id']}"

print(photo, vk_photo_id, sep="\n")
vk = vk_session.get_api()
vk.wall.post(message="Test", attachments=[vk_photo_id])
</code></pre>
<p>Для загрузки фотографии для стены создадим объект типа <var>VkUpload</var>, и&nbsp;потом вызовем у&nbsp;него метод <var>photo_wall</var>, который принимает список имен файлов, которые мы&nbsp;хотим загрузить (грузить можно сразу несколько штук), после чего получаем идентификатор изображения вида <code>&lt;type&gt;&lt;owner_id&gt;_&lt;media_id&gt;</code>, где тип&nbsp;&mdash; <var>photo</var>, а&nbsp;оставшиеся части можно получить из&nbsp;результата загрузки изображения. Вызываем сервис <a class="material__link" href="https://vk.com/dev/wall.post" target="_blank" rel="noopener noreferrer">wall.post</a> с&nbsp;помощью метода <var>wall.post</var> объекта типа <var>VkApiMethod</var>, где в&nbsp;качестве параметра указываем сообщение <var>message</var> и&nbsp;список идентификаторов вложений <var>attachments</var>.</p>
</section>
<section class="material__chapter">
<h2 id="4">Работа с&nbsp;событиями и&nbsp;чатами</h2>
<p>К&nbsp;сожалению, в&nbsp;настоящее время работа с&nbsp;событиями чатов для пользовательских программ ограничена из&nbsp;соображения безопасности (вам могут сделать доступ, если вы&nbsp;свяжетесь с&nbsp;vk.com и&nbsp;докажете, что делаете не&nbsp;мошенническую программу, а, например, альтернативный клиент сообщений), поэтому для работы с&nbsp;чатами нам надо будет создать сообщество, но&nbsp;большая часть событий, не&nbsp;связанных с&nbsp;чатами, работает и&nbsp;для клиентских программ.</p>
<p>Создадим сообщество.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-1/chat-bot-2.png" width="680" height="auto" /></div>
<p>После этого перейдите в&nbsp;управление сообществом в&nbsp;раздел <strong>Работа с&nbsp;API</strong>.</p>
<p>Включите там LongPoll API, укажите версию API (примеры ниже тестировались на&nbsp;версии API 5.103), выберите типы событий, оповещения о&nbsp;которых вы&nbsp;хотите получать, а&nbsp;затем создайте ключ доступа.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-1/chat-bot-3.png" width="680" height="auto" /></div>
<p>Также в&nbsp;настройках в&nbsp;пункте &laquo;Сообщения&raquo; включите эту функцию.</p>
<p>Кроме того, не&nbsp;забудьте на&nbsp;главной странице управления сообществом разрешить сообщения.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-1/chat-bot-4.png" width="300" height="auto" /></div>
<p>Подготовительные работы готовы. Теперь напишем такую программу:</p>
<pre><code class="language-python">import vk_api
from vk_api.bot_longpoll import VkBotLongPoll, VkBotEventType
import random


def main():
    vk_session = vk_api.VkApi(
        token=TOKEN)

    longpoll = VkBotLongPoll(vk_session, id_сообщества)

    for event in longpoll.listen():

        if event.type == VkBotEventType.MESSAGE_NEW:
            print(event)
            print('Новое сообщение:')
            print('Для меня от:', event.obj.message['from_id'])
            print('Текст:', event.obj.message['text'])
            vk = vk_session.get_api()
            vk.messages.send(user_id=event.obj.message['from_id'],
                             message="Спасибо, что написали нам. Мы обязательно ответим",
                             random_id=random.randint(0, 2 ** 64))


if __name__ == '__main__':
    main()
</code></pre>
<p>В&nbsp;этот раз при создании <var>VkAPi</var> мы&nbsp;используем не&nbsp;логин/пароль, а&nbsp;ключ доступа. После этого создаем очередь сообщений, которую мы&nbsp;хотим прослушивать. Для сообществ надо использовать класс <var>VkBotLongPoll</var>, который принимает сессию подключения и&nbsp;идентификатор сообщества (его можно посмотреть в&nbsp;ссылке на&nbsp;страницу сообщества&nbsp;&mdash; это только цифры). Если мы&nbsp;действуем не&nbsp;как сообщество, а&nbsp;как пользователь, надо использовать класс <var>VkLongPoll</var>. После чего запускаем бесконечный цикл ожидания сообщений в&nbsp;нашей очереди.</p>
<p>Если приходит сообщение типа <code>VkBotEventType.MESSAGE_NEW</code>, мы&nbsp;выводим само сообщение (там много интересной информации), затем&nbsp;&mdash; <var>id</var>&nbsp;пользователя-автора сообщения и&nbsp;текст сообщения. Кроме того, мы&nbsp;можем сразу ответить пользователю, вызвав сервис <a class="material__link" href="https://vk.com/dev/messages.send" target="_blank" rel="noopener noreferrer">messages.send</a>.</p>
<p>Для корректного вызова необходимо передать <var>user_id</var>&nbsp;&mdash; идентификатор пользователя или группового чата, куда мы&nbsp;пишем сообщение, текст сообщения <var>message</var>, а&nbsp;также большое случайное число <var>random_id</var>, которое нужно для того, чтобы не&nbsp;отправлять пользователю одни и&nbsp;те&nbsp;же сообщения несколько раз.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/chatbot-1/chat-bot-5.png" width="680" height="auto" /></div>
<p>В&nbsp;настоящий момент vk_api поддерживает следующие типы событий:</p>
<pre><code class="language-python">    MESSAGE_NEW = 'message_new'
    MESSAGE_REPLY = 'message_reply'
    MESSAGE_EDIT = 'message_edit'
    MESSAGE_TYPING_STATE = 'message_typing_state'
    MESSAGE_ALLOW = 'message_allow'
    MESSAGE_DENY = 'message_deny'
    PHOTO_NEW = 'photo_new'
    PHOTO_COMMENT_NEW = 'photo_comment_new'
    PHOTO_COMMENT_EDIT = 'photo_comment_edit'
    PHOTO_COMMENT_RESTORE = 'photo_comment_restore'
    PHOTO_COMMENT_DELETE = 'photo_comment_delete'
    AUDIO_NEW = 'audio_new'
    VIDEO_NEW = 'video_new'
    VIDEO_COMMENT_NEW = 'video_comment_new'
    VIDEO_COMMENT_EDIT = 'video_comment_edit'
    VIDEO_COMMENT_RESTORE = 'video_comment_restore'
    VIDEO_COMMENT_DELETE = 'video_comment_delete'
    WALL_POST_NEW = 'wall_post_new'
    WALL_REPOST = 'wall_repost'
    WALL_REPLY_NEW = 'wall_reply_new'
    WALL_REPLY_EDIT = 'wall_reply_edit'
    WALL_REPLY_RESTORE = 'wall_reply_restore'
    WALL_REPLY_DELETE = 'wall_reply_delete'
    BOARD_POST_NEW = 'board_post_new'
    BOARD_POST_EDIT = 'board_post_edit'
    BOARD_POST_RESTORE = 'board_post_restore'
    BOARD_POST_DELETE = 'board_post_delete'
    MARKET_COMMENT_NEW = 'market_comment_new'
    MARKET_COMMENT_EDIT = 'market_comment_edit'
    MARKET_COMMENT_RESTORE = 'market_comment_restore'
    MARKET_COMMENT_DELETE = 'market_comment_delete'
    GROUP_LEAVE = 'group_leave'
    GROUP_JOIN = 'group_join'
    USER_BLOCK = 'user_block'
    USER_UNBLOCK = 'user_unblock'
    POLL_VOTE_NEW = 'poll_vote_new'
    GROUP_OFFICERS_EDIT = 'group_officers_edit'
    GROUP_CHANGE_SETTINGS = 'group_change_settings'
    GROUP_CHANGE_PHOTO = 'group_change_photo'
    VKPAY_TRANSACTION = 'vkpay_transaction'
</code></pre>
<p>Например, так можно узнать, когда кто-то начал писать сообществу сообщение в&nbsp;чат:</p>
<pre><code class="language-python">if event.type == VkBotEventType.MESSAGE_TYPING_STATE:
    print(f'Печатает {event.obj.from_id} для {event.obj.to_id}')
</code></pre>
<p>А&nbsp;так, что пользователь добавился в&nbsp;сообщество:</p>
<pre><code class="language-python">if event.type == VkBotEventType.GROUP_JOIN:
    print(f'{event.obj.user_id} вступил в группу!')
</code></pre>
<p>Поэкспериментируйте с&nbsp;сообществом с&nbsp;запущенной программой обработки события, выводите их&nbsp;через <code>print(event.type)</code>, посмотрите, в&nbsp;каком случае возникают события того или иного вида (об&nbsp;этом достаточно просто догадаться по&nbsp;названию события).</p>
</section>
<section class="material__chapter">
<h2 id="5">Заключение</h2>
<p>API vk.com очень обширно и&nbsp;мы&nbsp;лишь немного прикоснулись к&nbsp;нему. Однако надеемся, что это даст вам импульс к&nbsp;самостоятельному изучению и&nbsp;написанию приложений для этой платформы.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>