<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Алиса — урок 2 </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Алиса 2</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Алиса&nbsp;&mdash; урок&nbsp;2</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Введение</a></li>
<li><a class="material__link" href="#2">Картинка в&nbsp;ответе</a></li>
<li><a class="material__link" href="#3">Навык, который знакомится</a></li>
<li><a class="material__link" href="#4">Игра</a></li>
<li><a class="material__link" href="#5">Пользуемся API Яндекс.Карт</a></li>
<li><a class="material__link" href="#6">Получаем координаты города</a></li>
<li><a class="material__link" href="#7">Получаем страну города</a></li>
<li><a class="material__link" href="#8">Рассчитываем расстояние от&nbsp;города до&nbsp;города</a></li>
<li><a class="material__link" href="#9">Программируем навык</a></li>
<li><a class="material__link" href="https://backend.lyceum.yandex.ru/admin/material/material/9794/change/10">Функции Яндекс.Облака</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Сегодня мы&nbsp;продолжим разрабатывать навыки для Алисы: научим ее&nbsp;знакомиться с&nbsp;пользователем и&nbsp;взаимодействовать с&nbsp;внешними API. В&nbsp;качестве бонуса расскажем, как разместить свой навык в&nbsp;Яндекс.Облаке.</p>
</section>
<section class="material__chapter">
<h2 id="1">Введение</h2>
<p>На&nbsp;этом уроке мы&nbsp;напишем игру &laquo;Угадай город&raquo;. Алиса показывает пользователю фотографию города, а&nbsp;он&nbsp;должен его отгадать.</p>
<p>Важный момент: перед игрой пользователь должен представиться, а&nbsp;Алиса&nbsp;&mdash; его поприветствовать. Это добавит нашему навыку немного человечности.</p>
<p>Находить именованные сущности (город и&nbsp;имя) мы&nbsp;уже умеем, осталось научиться отправлять пользователю картинку.</p>
<p>Итак, приступим.</p>
</section>
<section class="material__chapter">
<h2 id="2">Картинка в&nbsp;ответе</h2>
<p>Научимся показывать картинку в&nbsp;ответе. Например, для нашей игры нужно будет демонстрировать картинку города.</p>
<p>Для начала рассмотрим JSON ответа Алисы, в&nbsp;котором прикреплена картинка:</p>
<pre><code class="language-python">{
  "response": {
    "text": "Здравствуйте! Это мы, хороводоведы.",
    "tts": "Здравствуйте! Это мы, хоров+одо в+еды.",
    "card": {
      "type": "BigImage",
      "image_id": "1027858/46r960da47f60207e924",
      "title": "Заголовок для изображения",
      "description": "Описание изображения.",
      "button": {
        "text": "Надпись на кнопке",
        "url": "http://example.com/",
        "payload": {}
      }
    },
    "buttons": [
      {
        "title": "Надпись на кнопке",
        "payload": {},
        "url": "https://example.com/",
        "hide": true
      }
    ],
    "end_session": false
  },
  "session": {
    "session_id": "2eac4854-fce721f3-b845abba-20d60",
    "message_id": 4,
    "user_id": "AC9WC3DF6FCE052E45A4566A48E6B7193774B84814CE49A922E163B8B29881DC"
  },
  "version": "1.0"
}
</code></pre>
<p>В&nbsp;отличие от&nbsp;примера из&nbsp;предыдущего урока, в&nbsp;ответе появился раздел <var>card</var>. Он&nbsp;и&nbsp;содержит в&nbsp;себе картинку.</p>
<p>Рассмотрим подробно его содержание:</p>
<pre><code class="language-python">"card": {
      "type": "BigImage",
      "image_id": "1027858/46r960da47f60207e924",
      "title": "Заголовок для изображения",
      "description": "Описание изображения.",
      "button": {
        "text": "Надпись на кнопке",
        "url": "http://example.com/",
        "payload": {}
      }
</code></pre>
<p>Мы&nbsp;опишем только те&nbsp;поля, которые будем использовать. Про оставшиеся можно посмотреть в&nbsp;<a class="material__link" href="https://tech.yandex.ru/dialogs/alice/doc/protocol-docpage/#response" target="_blank" rel="noopener noreferrer">документации Алисы</a>.</p>
<p><var>card</var>&nbsp;&mdash; описание карточки-сообщения с&nbsp;поддержкой изображений. Если приложению удается отобразить карточку для пользователя, свойство <var>response.text</var> не&nbsp;используется</p>
<ul>
<li><var>type</var>&nbsp;&mdash; тип карточки. Поддерживаемые значения:
<ul>
<li><var>BigImage</var>&nbsp;&mdash; одно изображение</li>
<li><var>ItemsList</var>&nbsp;&mdash; галерея изображений (от&nbsp;1&nbsp;до&nbsp;5)</li>
Требуемый формат ответа зависит от&nbsp;типа карточки. Мы&nbsp;будем использовать BigImage</ul>
</li>
<li><var>image_id</var>&nbsp;&mdash; идентификатор изображения, который возвращается в&nbsp;ответ на&nbsp;запрос загрузки</li>
<li><var>title</var>&nbsp;&mdash; заголовок для изображения. Это на&nbsp;самом деле увидит пользователь</li>
</ul>
<p>В&nbsp;этом <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/cities.zip" target="_blank" rel="noopener noreferrer">архиве</a> мы&nbsp;собрали для вас картинки, которые можно использовать для решения задач урока (но&nbsp;можете использовать свои изображения). Подробно про&nbsp;то, как загружать ресурсы к&nbsp;своему навыку, мы&nbsp;говорили на&nbsp;прошлом уроке.</p>
<p>Вот как может выглядеть ответ Алисы с&nbsp;картинкой:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/alice-with-image.png" width="680" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="3">Навык, который знакомится</h2>
<p>Напишем простой навык, который ведет следующий диалог:</p>
<ul>
<li>Привет! Назови свое имя!</li>
<li>Саша.</li>
<li>Приятно познакомиться, Саша. Я&nbsp;&mdash; Алиса. Какой город хочешь увидеть?</li>
<li>Москва (Нью-йорк, Париж).</li>
<li>Этот город я&nbsp;знаю.&nbsp;<em>И&nbsp;показывает фото города</em></li>
</ul>
<p>Если вдруг пользователь не&nbsp;назвал имя, Алиса должна сказать:</p>
<ul>
<li>Не&nbsp;расслышала имя. Повтори, пожалуйста!</li>
</ul>
<p>Если пользователь не&nbsp;назвал город или назвал город, для которого нет картинки, Алиса должна сказать:</p>
<ul>
<li>Первый раз слышу об&nbsp;этом городе. Попробуй еще разок!</li>
</ul>
<p>Код приведен ниже:</p>
<pre><code class="language-python">from flask import Flask, request, jsonify
import logging
import json
import random

app = Flask(__name__)

logging.basicConfig(level=logging.INFO)

# создаем словарь, в котором ключ &mdash; название города,
# а значение &mdash; массив, где перечислены id картинок,
# которые мы записали в прошлом пункте.

cities = {
    'москва': ['1540737/daa6e420d33102bf6947',
               '213044/7df73ae4cc715175059e'],
    'нью-йорк': ['1652229/728d5c86707054d4745f',
                 '1030494/aca7ed7acefde2606bdc'],
    'париж': ["1652229/f77136c2364eb90a3ea8",
              '3450494/aca7ed7acefde22341bdc']
}

# создаем словарь, где для каждого пользователя
# мы будем хранить его имя
sessionStorage = {}


@app.route('/post', methods=['POST'])
def main():
    logging.info(f'Request: {request.json!r}')
    response = {
        'session': request.json['session'],
        'version': request.json['version'],
        'response': {
            'end_session': False
        }
    }
    handle_dialog(response, request.json)
    logging.info(f'Response: {response!r}')
    return jsonify(response)


def handle_dialog(res, req):
    user_id = req['session']['user_id']

    # если пользователь новый, то просим его представиться.
    if req['session']['new']:
        res['response']['text'] = 'Привет! Назови свое имя!'
        # создаем словарь в который в будущем положим имя пользователя
        sessionStorage[user_id] = {
            'first_name': None
        }
        return

    # если пользователь не новый, то попадаем сюда.
    # если поле имени пустое, то это говорит о том,
    # что пользователь еще не представился.
    if sessionStorage[user_id]['first_name'] is None:
        # в последнем его сообщение ищем имя.
        first_name = get_first_name(req)
        # если не нашли, то сообщаем пользователю что не расслышали.
        if first_name is None:
            res['response']['text'] = \
                'Не расслышала имя. Повтори, пожалуйста!'
        # если нашли, то приветствуем пользователя.
        # И спрашиваем какой город он хочет увидеть.
        else:
            sessionStorage[user_id]['first_name'] = first_name
            res['response'][
                'text'] = 'Приятно познакомиться, ' \
                          + first_name.title() \
                          + '. Я - Алиса. Какой город хочешь увидеть?'
            # получаем варианты buttons из ключей нашего словаря cities
            res['response']['buttons'] = [
                {
                    'title': city.title(),
                    'hide': True
                } for city in cities
            ]
    # если мы знакомы с пользователем и он нам что-то написал,
    # то это говорит о том, что он уже говорит о городе,
    # что хочет увидеть.
    else:
        # ищем город в сообщение от пользователя
        city = get_city(req)
        # если этот город среди известных нам,
        # то показываем его (выбираем одну из двух картинок случайно)
        if city in cities:
            res['response']['card'] = {}
            res['response']['card']['type'] = 'BigImage'
            res['response']['card']['title'] = 'Этот город я знаю.'
            res['response']['card']['image_id'] = random.choice(cities[city])
            res['response']['text'] = 'Я угадал!'
        # если не нашел, то отвечает пользователю
        # 'Первый раз слышу об этом городе.'
        else:
            res['response']['text'] = \
                'Первый раз слышу об этом городе. Попробуй еще разок!'


def get_city(req):
    # перебираем именованные сущности
    for entity in req['request']['nlu']['entities']:
        # если тип YANDEX.GEO то пытаемся получить город(city),
        # если нет, то возвращаем None
        if entity['type'] == 'YANDEX.GEO':
            # возвращаем None, если не нашли сущности с типом YANDEX.GEO
            return entity['value'].get('city', None)


def get_first_name(req):
    # перебираем сущности
    for entity in req['request']['nlu']['entities']:
        # находим сущность с типом 'YANDEX.FIO'
        if entity['type'] == 'YANDEX.FIO':
            # Если есть сущность с ключом 'first_name',
            # то возвращаем ее значение.
            # Во всех остальных случаях возвращаем None.
            return entity['value'].get('first_name', None)


if __name__ == '__main__':
    app.run()
</code></pre>
<p>Загружаем этот код в&nbsp;Glitch или делаем туннель в&nbsp;ngrok, заполняем данные в&nbsp;Алисе и&nbsp;отправляемся тестировать!</p>
</section>
<section class="material__chapter">
<h2 id="4">Игра</h2>
<p>Доработаем предыдущую программу до&nbsp;конца.</p>
<p>Рассмотрим блок-схему, чтобы понять логику общения нашего навыка с&nbsp;пользователем.</p>
<div class="material__content-positioner"><img src="https://yastatic.net/s3/lyceum/intensive2022/alice-2-4.png" alt="" width="557" height="815" /></div>
<p>Код игры приведен в&nbsp;<a class="material__link" href="https://yastatic.net/s3/lyceum/intensive2022/alice-2-game.py" target="_blank" rel="noopener noreferrer">файле</a>.</p>
</section>
<section class="material__chapter">
<h2 id="5">Пользуемся API Яндекс.Карт</h2>
<p>Сегодня мы&nbsp;попробуем совместить наш опыт по&nbsp;работе со&nbsp;сторонними API (Яндекс.Карты) и&nbsp;знания Алисы, чтобы создать новый навык, который будет сообщать пользователю, в&nbsp;какой стране находится загаданный город, а&nbsp;также вычислять расстояние от&nbsp;одного города до&nbsp;другого.</p>
<p>Алгоритм работы навыка следующий:</p>
<ul>
<li>Если мы&nbsp;пишем название одного города, Алиса сообщит нам, в&nbsp;какой стране находится этот город</li>
<li>Если мы&nbsp;пишем названия двух городов, Алиса посчитает расстояние между ними</li>
<li>Если мы&nbsp;вдруг напишем названия трех и&nbsp;более городов, Алиса возмутится и&nbsp;сообщит: &laquo;Слишком много городов. Я&nbsp;запуталась&raquo;</li>
</ul>
<p>Для получения информации о&nbsp;географических объектах мы&nbsp;воспользуемся <a class="material__link" href="https://tech.yandex.ru/maps/geocoder/" target="_blank" rel="noopener noreferrer">геокодером Яндекс.Карт</a>.</p>
</section>
<section class="material__chapter">
<h2 id="6">Получаем координаты города</h2>
<p>Мы&nbsp;уже знаем, что Алиса умеет вычленять из&nbsp;текста разные сущности, в&nbsp;том числе и&nbsp;названия городов.</p>
<p>Напишем функцию <code>get_coordinates(city_name)</code>, которая получает географические координаты города по&nbsp;его имени.</p>
<p>Напомним: надо отправить <strong>HTTP-запрос</strong>, например, такой <code>https://geocode-maps.yandex.ru/1.x/?geocode=Москва&amp;format=json</code> Яндекс.Картам, а&nbsp;потом разобрать ответ.</p>
<p>Возвращает эта функция кортеж с&nbsp;координатами города. В&nbsp;случае, если в&nbsp;процессе работы произошла <strong>любая ошибка</strong>, мы&nbsp;вернем исключение.</p>
<pre><code class="language-python">import requests


def get_coordinates(city_name):
    try:
        # url, по которому доступно API Яндекс.Карт
        url = "https://geocode-maps.yandex.ru/1.x/"
        # параметры запроса
        params = {
            "apikey": "40d1649f-0493-4b70-98ba-98533de7710b",
            # город, координаты которого мы ищем
            'geocode': city_name,
            # формат ответа от сервера, в данном случае JSON
            'format': 'json'
        }
        # отправляем запрос
        response = requests.get(url, params)
        # получаем JSON ответа
        json = response.json()
        # получаем координаты города
        # (там написаны долгота(longitude), широта(latitude) через пробел)
        # посмотреть подробное описание JSON-ответа можно
        # в документации по адресу https://tech.yandex.ru/maps/geocoder/
        coordinates_str = json['response']['GeoObjectCollection'][
            'featureMember'][0]['GeoObject']['Point']['pos']
        # Превращаем string в список, так как
        # точка - это пара двух чисел - координат
        long, lat = map(float, coordinates_str.split())
        # Вернем ответ
        return long, lat
    except Exception as e:
        return e
</code></pre>
</section>
<section class="material__chapter">
<h2 id="7">Получаем страну города</h2>
<p>Функция <code>get_country(city_name)</code> вернет нам страну, в&nbsp;которой находится указанный город. Отличие от&nbsp;предыдущей функции заключается лишь в&nbsp;получении других данных из&nbsp;ответа геокодера.</p>
<pre><code class="language-python">def get_country(city_name):
    try:
        url = "https://geocode-maps.yandex.ru/1.x/"
        params = {
            "apikey": "40d1649f-0493-4b70-98ba-98533de7710b",
            'geocode': city_name,
            'format': 'json'
        }
        data = requests.get(url, params).json()
        # все отличие тут, мы получаем имя страны
        return data['response']['GeoObjectCollection'][
            'featureMember'][0]['GeoObject']['metaDataProperty'][
            'GeocoderMetaData']['AddressDetails']['Country']['CountryName']
    except Exception as e:
        return e
</code></pre>
</section>
<section class="material__chapter">
<h2 id="8">Рассчитываем расстояние от&nbsp;города до&nbsp;города</h2>
<p>А&nbsp;вот для вычисления расстояний между двумя точками необходимы знания <strong>тригонометрических</strong> функций. Ведь Земля&nbsp;&mdash; круглая!</p>
<p>Подробно о&nbsp;расчете коротких расстояний на&nbsp;Земле можно прочитать <a class="material__link" href="https://en.wikipedia.org/wiki/Haversine_formula" target="_blank" rel="noopener noreferrer">тут</a>. Пока&nbsp;же можно просто воспользоваться приведенной функцией.</p>
<pre><code class="language-python">import math


def get_distance(p1, p2):
    # p1 и p2 - это кортежи из двух элементов - координаты точек
    radius = 6373.0

    lon1 = math.radians(p1[0])
    lat1 = math.radians(p1[1])
    lon2 = math.radians(p2[0])
    lat2 = math.radians(p2[1])

    d_lon = lon2 - lon1
    d_lat = lat2 - lat1

    a = math.sin(d_lat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(d_lon / 2) ** 2
    c = 2 * math.atan2(a ** 0.5, (1 - a) ** 0.5)

    distance = radius * c
    return distance
</code></pre>
</section>
<section class="material__chapter">
<h2 id="9">Программируем навык</h2>
<p>Наша программа будет состоять из&nbsp;двух файлов.</p>
<p>В&nbsp;первом файле мы&nbsp;разместим код, который будет отвечать за&nbsp;общение с&nbsp;Алисой, а&nbsp;во&nbsp;втором&nbsp;&mdash; функции, которые связаны с&nbsp;общением с&nbsp;API Яндекс.Карт.</p>
<p>Всю функциональность общения с&nbsp;картами мы&nbsp;уже реализовали, поэтому осталось объединить все функции в&nbsp;один файл&nbsp;&mdash; <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/geo.py" target="_blank" rel="noopener noreferrer">geo.py</a>.</p>
<p>А&nbsp;во&nbsp;втором файле мы&nbsp;расположим код, который отвечает за&nbsp;общение с&nbsp;Алисой&nbsp;&mdash; <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/app.py" target="_blank" rel="noopener noreferrer">app.py</a>.</p>
<p>Многое из&nbsp;того, что мы&nbsp;делаем тут, уже было сделано в&nbsp;других уроках. Так что объясним только новые моменты.</p>
<pre><code class="language-python">from flask import Flask, request, jsonify
import logging
import json
# импортируем функции из нашего второго файла geo
from geo import get_country, get_distance, get_coordinates

app = Flask(__name__)

# Добавляем логирование в файл. 
# Чтобы найти файл, перейдите на pythonwhere в раздел files, 
# он лежит в корневой папке
logging.basicConfig(level=logging.INFO, filename='app.log',
                    format='%(asctime)s %(levelname)s %(name)s %(message)s')


@app.route('/post', methods=['POST'])
def main():
    logging.info('Request: %r', request.json)
    response = {
        'session': request.json['session'],
        'version': request.json['version'],
        'response': {
            'end_session': False
        }
    }
    handle_dialog(response, request.json)
    logging.info('Request: %r', response)
    return jsonify(response)


def handle_dialog(res, req):
    user_id = req['session']['user_id']
    if req['session']['new']:
        res['response']['text'] = \
            'Привет! Я могу показать город или сказать расстояние между городами!'
        return
    # Получаем города из нашего
    cities = get_cities(req)
    if not cities:
        res['response']['text'] = 'Ты не написал название не одного города!'
    elif len(cities) == 1:
        res['response']['text'] = 'Этот город в стране - ' + \
                                  get_country(cities[0])
    elif len(cities) == 2:
        distance = get_distance(get_coordinates(
            cities[0]), get_coordinates(cities[1]))
        res['response']['text'] = 'Расстояние между этими городами: ' + \
                                  str(round(distance)) + ' км.'
    else:
        res['response']['text'] = 'Слишком много городов!'


def get_cities(req):
    cities = []
    for entity in req['request']['nlu']['entities']:
        if entity['type'] == 'YANDEX.GEO':
            if 'city' in entity['value']:
                cities.append(entity['value']['city'])
    return cities


if __name__ == '__main__':
    app.run()
</code></pre>
<p>Осталось протестировать и&nbsp;задеплоить наш навык.</p>
</section>
<section class="material__chapter">
<h2 id="10">Функции Яндекс.Облака</h2>
<p>Яндекс.Облако добавило возможность создавать свои функции в&nbsp;облаке без необходимости настраивать виртуальную машину и&nbsp;различные права доступа. У&nbsp;функций ограниченная функциональность, но&nbsp;вполне достаточная для, например, небольших навыков для голосового помощника Алиса. Большим плюсом использования функций с&nbsp;этой целью является&nbsp;то, что в&nbsp;этом случае они <strong>не&nbsp;тарифицируются</strong>, то&nbsp;есть пользователь может размещать сколько угодно таких функций бесплатно.</p>
<p>Давайте посмотрим, как сделать свою функцию. Зайдем в&nbsp;Яндекс.Облако и&nbsp;выберем пункт меню Cloud Functions.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/alice-cloud-1.png" width="349" height="auto" /></div>
<p>Мы&nbsp;рассмотрим пример создания функции для самого простого навыка, который просто повторяет пользовательский ввод. Поэтому введем название и&nbsp;описание навыка исходя из&nbsp;его функциональности:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/alice-cloud-2.png" width="680" height="auto" /></div>
<p>После этого создадим функцию. Файл можно создать как в&nbsp;редакторе, так и&nbsp;сделать его на&nbsp;своем компьютере, а&nbsp;потом загрузить в&nbsp;облако zip-архив.</p>
<p>Сама функция будет немного отличаться от&nbsp;того кода, который мы&nbsp;привыкли делать с&nbsp;использованием flask. Вот пример кода файла main.py:</p>
<pre><code class="language-python">def handler(event, context):
    """
    Точка входа для облачной функции.
    :param event: содержимое request.json().
    :param context: информация о текущем контексте выполнения.
    :return: ответ будет представлен в виде json автоматически.
    """
    text = 'Привет, я повторю все, что вы скажете'
    if 'request' in event and \
            'original_utterance' in event['request'] \
            and len(event['request']['original_utterance']) &gt; 0:
        text = event['request']['original_utterance']
    return {
        'version': event['version'],
        'session': event['session'],
        'response': {
            'text': text,
            'end_session': 'false'
        },
    }
</code></pre>
<p>Обратите внимание: flask тут нам уже не&nbsp;нужен. Мы&nbsp;просто делаем функцию с&nbsp;определенной сигнатурой. Запрос к&nbsp;ней обработает Яндекс.Облако и&nbsp;положит все, что было, в&nbsp;<code>request.json()</code> в&nbsp;параметр <var>event</var>. Кроме того, нет необходимости самостоятельно формировать json в&nbsp;ответ, это произойдет автоматически.</p>
<p>Для того чтобы наша функция работала корректно, надо указать еще следующие значения в&nbsp;настройках:</p>
<ul>
<li>Среда выполнения&nbsp;&mdash; python37</li>
<li>Точка входа&nbsp;&mdash; main.handler (имя файла без py + имя функции в&nbsp;этом файле, которую надо запускать)</li>
</ul>
<p>После этого можно нажать кнопку &laquo;Создать версию&raquo;.</p>
<p>На&nbsp;вкладке &laquo;Тестирование&raquo; можно отправить тестовый запрос в&nbsp;нашу функцию почти как в&nbsp;Postman, причем есть возможность указать шаблон данных в&nbsp;формате запроса Алисы.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/alice-cloud-3.png" width="680" height="auto" /></div>
<p>Протестируйте функцию.</p>
<p>Для того чтобы Алиса смогла отправить запрос к&nbsp;функции, ее&nbsp;надо сделать <strong>публичной</strong>. Этот переключатель находится на&nbsp;вкладке <strong>Обзор</strong>. Ссылку для Алисы копировать необязательно.</p>
<p>Теперь перейдем в&nbsp;настройки навыка Алисы и&nbsp;вместо Webhook выберем нужную публичную функцию в&nbsp;Яндекс.Облаке из&nbsp;списка:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/alice-cloud-4.png" width="680" height="auto" /></div>
<p>Убедимся, что все работает:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/alice-cloud-5.png" width="680" height="auto" /></div>
<p>То, что функция не&nbsp;использует flask, немного неудобно для локальной отладки. Но&nbsp;достаточно просто вынести ее&nbsp;в&nbsp;отдельный файл так, чтобы обработчик URL из&nbsp;flask вызывал&nbsp;ее, подстраивая данные до&nbsp;нужной сигнатуры и&nbsp;затем превращая ответ в&nbsp;json. Таким образом будет удобно и&nbsp;локально тестировать функцию, и&nbsp;затем заливать ее&nbsp;в&nbsp;Яндекс.Облако.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>