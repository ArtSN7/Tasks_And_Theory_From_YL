<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Знакомство с flask-sqlalchemy </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок sqlalchemy</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Знакомство с&nbsp;flask-sqlalchemy</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Базы данных и&nbsp;ORM</a></li>
<li><a class="material__link" href="#2">Установка</a></li>
<li><a class="material__link" href="#3">Постановка задачи для первого примера</a></li>
<li><a class="material__link" href="#4">Начальный каркас приложения</a></li>
<li><a class="material__link" href="#5">Таблица с&nbsp;пользователями</a></li>
<li><a class="material__link" href="#6">Таблица с&nbsp;новостями</a></li>
<li><a class="material__link" href="#7">Взаимодействие с&nbsp;базой данных</a></li>
<li><a class="material__link" href="#8">Небольшая шпаргалка по&nbsp;filter</a></li>
<li><a class="material__link" href="#9">Отображение публичных записей</a></li>
<li><a class="material__link" href="#10">Регистрация пользователей</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;этом и&nbsp;следующем занятиях мы&nbsp;создадим полноценное веб-приложение с&nbsp;регистрацией и&nbsp;авторизацией пользователей, работающее с&nbsp;базой данных через ORM.</p>
</section>
<section class="material__chapter">
<h2 id="1">Базы данных и&nbsp;ORM</h2>
<p>Мы&nbsp;уже достаточно тесно познакомились с&nbsp;реляционными базами данных: решали задачи с&nbsp;использованием&nbsp;БД, многие из&nbsp;вас уже использовали&nbsp;БД в&nbsp;своих проектах для хранения информации. Однако пока мы&nbsp;работали с&nbsp;данными исключительно с&nbsp;помощью запросов на&nbsp;языке SQL, которые составляли самостоятельно. Для небольших проектов это вполне оправдано и&nbsp;достаточно часто используется в&nbsp;реальной жизни. Flask &laquo;из&nbsp;коробки&raquo; не&nbsp;имеет собственных инструментов для работы с&nbsp;базами данных (в&nbsp;отличие, например, от&nbsp;Django) и&nbsp;предоставляет нам полную свободу выбора инструментов для работы.</p>
<p>Согласитесь: очень хочется перейти на&nbsp;более высокий уровень работы с&nbsp;данными. Представьте, что в&nbsp;вашем распоряжении есть объект, который связан с&nbsp;базой данных. Этот объект берет на&nbsp;себя всю работу по&nbsp;организации общения с&nbsp;данными. Вам лишь остается давать ему команды: получить данные, отфильтровать их&nbsp;по&nbsp;заданному условию, записать данные и&nbsp;т.&nbsp;д., а&nbsp;преобразование команд в&nbsp;SQL-запросы&nbsp;&mdash; это уже забота объекта. Работать с&nbsp;данными как с&nbsp;объектами чрезвычайно удобно&nbsp;&mdash; не&nbsp;зря&nbsp;же мы&nbsp;так много времени уделяем изучению объектного подхода.</p>
<p>К&nbsp;сожалению, написать универсальный модуль, который преобразовывает результат SQL-запроса в&nbsp;объекты и&nbsp;наоборот, достаточно нетривиальная задача. Хорошо, что она уже решена за&nbsp;нас.</p>
<p>В&nbsp;больших приложениях (не&nbsp;только для web) достаточно часто используется технология <a class="material__link" href="https://ru.wikipedia.org/wiki/ORM" target="_blank" rel="noopener noreferrer">ORM</a> (Object-Relational Mapping&nbsp;&mdash; объектно-реляционное отображение)&nbsp;&mdash; прослойка, позволяющая работать с&nbsp;базой данных через объекты языка. Кроме того, большинство ORM позволяют генерировать скрипты миграции базы данных для поддержания версионности (отдаленно можно сравнить c&nbsp;git, но&nbsp;для баз данных), а&nbsp;также предоставляют разработчику еще немало другой полезной функциональности. Мы&nbsp;будем использовать библиотеку sqlalchemy. Ее&nbsp;можно использовать не&nbsp;только при создании веб-приложений, но&nbsp;и&nbsp;при разработке любых программ, которые взаимодействуют с&nbsp;базами данных.</p>
</section>
<section class="material__chapter">
<h2 id="2">Установка</h2>
<p>Прежде чем мы&nbsp;начнем что-то делать, давайте установим sqlalchemy:</p>
<pre><code>pip install sqlalchemy
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Постановка задачи для первого примера</h2>
<p>Давайте создадим веб-приложение, которое будет использовать базу данных и&nbsp;ORM для работы с&nbsp;ней. Для начала определимся с&nbsp;функциональностью.</p>
<p>У&nbsp;нас будет простое веб-приложение, в&nbsp;котором пользователи могут авторизовываться, просматривать, добавлять и&nbsp;удалять новости&nbsp;&mdash; такой мини-вариант личных блогов. Получается, нам надо хранить информацию о&nbsp;двух сущностях:</p>
<ol>
<li>Пользователи</li>
<li>Новости</li>
</ol>
<p>Причем каждая новость должна быть связана с&nbsp;автором новости, который ее&nbsp;написал.</p>
</section>
<section class="material__chapter">
<h2 id="4">Начальный каркас приложения</h2>
<p>Начнем создавать наше приложение с&nbsp;создания основного файла, который назовем main.py. Для начала разместим в&nbsp;нем уже привычный код:</p>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)
app.config['SECRET_KEY'] = 'yandexlyceum_secret_key'


def main():
    app.run()


if __name__ == '__main__':
    main()
</code></pre>
<p>Создадим папки:</p>
<ul>
<li>db&nbsp;&mdash; для хранения одного единственного файла базы данных</li>
<li>data&nbsp;&mdash; для хранения классов, необходимых для взаимодействия с&nbsp;базой данных</li>
</ul>
<p>Внутри папки data создадим два файла, один назовем __all_models.py (в&nbsp;нем будем хранить модели для работы с&nbsp;базой данных), а&nbsp;&mdash; другой db_session.py&nbsp;&mdash; будет отвечать за&nbsp;подключение к&nbsp;базе данных и&nbsp;создание сессии для работы с&nbsp;ней.</p>
<p>Следующий шаг самый сложный. Не&nbsp;переживайте, этот код будет стандартным для всех ваших приложений и&nbsp;может переезжать от&nbsp;одного проекта к&nbsp;другому. Напишем в&nbsp;db_session.py вот такой код:</p>
<pre><code class="language-python">import sqlalchemy as sa
import sqlalchemy.orm as orm
from sqlalchemy.orm import Session
import sqlalchemy.ext.declarative as dec

SqlAlchemyBase = dec.declarative_base()

__factory = None
</code></pre>
<p>Сначала импортируем необходимое&nbsp;&mdash; саму библиотеку sqlalchemy (в&nbsp;принципе, этого достаточно, остальные импорты нужны только для избавления от&nbsp;длинных путей), затем часть библиотеки, которая отвечает за&nbsp;функциональность ORM, потом объект <var>Session</var>, отвечающий за&nbsp;соединение с&nbsp;базой данных, и&nbsp;модуль declarative&nbsp;&mdash; он&nbsp;поможет нам объявить нашу базу данных.</p>
<p>Создадим две переменные: <var>SqlAlchemyBase</var>&nbsp;&mdash; некоторую абстрактную декларативную базу, в&nbsp;которую позднее будем наследовать все наши модели, и <var>__factory</var>, которую будем использовать для получения сессий подключения к&nbsp;нашей базе данных.</p>
<p>Кроме того, в&nbsp;файле db_session.py нам понадобится сделать еще две функции <var>global_init</var> и&nbsp;<var>create_session</var>.</p>
<pre><code class="language-python">def global_init(db_file):
    global __factory

    if __factory:
        return

    if not db_file or not db_file.strip():
        raise Exception("Необходимо указать файл базы данных.")

    conn_str = f'sqlite:///{db_file.strip()}?check_same_thread=False'
    print(f"Подключение к базе данных по адресу {conn_str}")

    engine = sa.create_engine(conn_str, echo=False)
    __factory = orm.sessionmaker(bind=engine)

    from . import __all_models

    SqlAlchemyBase.metadata.create_all(engine)
</code></pre>
<p><var>global_init</var> принимает на&nbsp;вход адрес базы данных, затем проверяет, не&nbsp;создали&nbsp;ли мы&nbsp;уже фабрику подключений (то&nbsp;есть не&nbsp;вызываем&nbsp;ли мы&nbsp;функцию не&nbsp;первый раз). Если уже создали, то&nbsp;завершаем работу, так как начальную инициализацию надо проводить только единожды.</p>
<p>Проверяем, что нам указали непустой адрес базы данных, а&nbsp;затем создаем строку подключения <var>conn_str</var> (она состоит из&nbsp;типа базы данных, адреса до&nbsp;базы данных и&nbsp;параметров подключения), которую передаем Sqlalchemy для того, чтобы она выбрала правильный движок работы с&nbsp;базой данных (переменная <var>engine</var>). В&nbsp;нашем случае это будет движок для работы с&nbsp;SQLite базами данных.</p>
<p>Если в&nbsp;функцию <code>create_engine()</code> передать параметр <var>echo</var> со&nbsp;значением True, в&nbsp;консоль будут выводиться все SQL-запросы, которые сделает SQLAlchemy, что очень удобно для отладки.</p>
<p>Наконец, создаем фабрику подключений к&nbsp;нашей базе данных, которая будет работать с&nbsp;нужным нам движком.</p>
<p>Импортируем все из&nbsp;файла __all_models.py&nbsp;&mdash; именно тут SQLalchemy узнает о&nbsp;всех наших моделях.</p>
<p>Наконец, заставляем нашу базу данных создать все объекты, которые она пока не&nbsp;создала. Обратите внимание: все таблицы, которые были уже созданы в&nbsp;базе данных, останутся без изменений.</p>
<pre><code class="language-python">def create_session() -&gt; Session:
    global __factory
    return __factory()
</code></pre>
<p>Функция <var>create_session</var> нужна для получения сессии подключения к&nbsp;нашей базе данных. Часть <code>-&gt; Session</code> нужна лишь для того, чтобы явно указать PyCharm, что наша функция возвращает объект типа <code>sqlalchemy.orm.Session</code> и&nbsp;среда могла показывать нам подсказки далее.</p>
<p>В&nbsp;качестве завершающего штриха давайте добавим в&nbsp;main.py импорт содержимого файла db_session:</p>
<pre><code class="language-python">from data import db_session
</code></pre>
<p>И&nbsp;перед запуском приложения <code>app.run()</code> добавим вызов глобальной инициализации всего, что связано с&nbsp;базой данных:</p>
<pre><code class="language-python">db_session.global_init("db/blogs.db")
</code></pre>
<p>В результате должна получиться примерно такая структура папок и&nbsp;файлов:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/sqlalchemy-struct.png" width="680" height="auto" /></div>
<p>Запустим наше приложение. Мы&nbsp;увидим, что оно работает и&nbsp;после запуска создало пустую базу данных по&nbsp;адресу db/blogs.db.</p>
<p>Теперь давайте создадим таблицы.</p>
</section>
<section class="material__chapter">
<h2 id="5">Таблица с&nbsp;пользователями</h2>
<p>Так как мы&nbsp;используем ORM, никакого SQL мы&nbsp;писать не&nbsp;будем и&nbsp;позволим sqlalchemy сделать всю работу за&nbsp;нас, а&nbsp;сами лишь опишем те&nbsp;классы, которые хотим получить для работы с&nbsp;базой в&nbsp;Python.</p>
<p>Давайте создадим в&nbsp;папке data файл users.py и&nbsp;опишем в&nbsp;нем класс <var>User</var>&nbsp;&mdash; модели для работы с&nbsp;таблицей, которая будет содержать информацию о&nbsp;пользователях нашего веб-приложения.</p>
<p>Подумаем, какая информация нам нужна о&nbsp;наших пользователях:</p>
<ol>
<li>Уникальный идентификатор пользователя&nbsp;&mdash; некоторый его номер в&nbsp;нашей базе данных, желательно, чтобы он&nbsp;генерировался автоматически без нашего участия.</li>
<li>Имя пользователя&nbsp;&mdash; некоторое строковое значение.</li>
<li>Описание пользователя&nbsp;&mdash; некоторая текстовая информация, которой пользователь хочет поделиться о&nbsp;себе.</li>
<li>Адрес электронной почты&nbsp;&mdash; уникальная строка (чтобы мы&nbsp;могли точно знать, для какого пользователя восстанавливать пароль). Так как мы&nbsp;достаточно часто будем искать пользователя по&nbsp;адресу электронной почты (как минимум, при логине), было&nbsp;бы здорово, если&nbsp;бы база могла как-то ускорить такой поиск.</li>
<li>Зашифрованный пароль пользователя&nbsp;&mdash; строка. <strong>Ни&nbsp;в&nbsp;коем случае нельзя хранить пароль пользователя в&nbsp;открытом виде!</strong></li>
<li>Дата создания пользователя&nbsp;&mdash; потому что нам хочется знать, когда пользователь зарегистрировался в&nbsp;нашем веб-приложении.</li>
</ol>
<pre><code class="language-python">import datetime
import sqlalchemy
from .db_session import SqlAlchemyBase


class User(SqlAlchemyBase):
    __tablename__ = 'users'

    id = sqlalchemy.Column(sqlalchemy.Integer, 
                           primary_key=True, autoincrement=True)
    name = sqlalchemy.Column(sqlalchemy.String, nullable=True)
    about = sqlalchemy.Column(sqlalchemy.String, nullable=True)
    email = sqlalchemy.Column(sqlalchemy.String, 
                              index=True, unique=True, nullable=True)
    hashed_password = sqlalchemy.Column(sqlalchemy.String, nullable=True)
    created_date = sqlalchemy.Column(sqlalchemy.DateTime, 
                                     default=datetime.datetime.now)
</code></pre>
<p>Чтобы обозначить, что <var>User</var>&nbsp;&mdash; не&nbsp;обычный класc, а&nbsp;именно класс модели, его необходимо унаследовать от&nbsp;объекта класса <var>SqlAlchemyBase</var>, который мы&nbsp;создали ранее.</p>
<p>В&nbsp;служебном атрибуте <var>__tablename__</var> указывается таблица, которая будет создана для хранения данных этой модели. Название таблицы можно не&nbsp;указывать, тогда sqlalchemy сделает таблицу сама, исходя из&nbsp;названия класса.</p>
<p>Для каждого из&nbsp;атрибутов типа <var>sqlalchemy.Column</var> будет создан одноименный столбец в&nbsp;базе данных согласно его описанию:</p>
<ul>
<li><code>sqlalchemy.Integer</code> (<code>sqlalchemy.String</code>, <code>sqlalchemy.DateTime</code> и&nbsp;т.&nbsp;д.)&nbsp;&mdash; указания типа данных</li>
<li><code>primary_key=True</code>&nbsp;&mdash; указание на&nbsp;то, что столбец является первичным ключом. Обычно первичный ключ&nbsp;&mdash; некоторый числовой идентификатор, который однозначно идентифицирует каждую запись в&nbsp;таблице</li>
<li><code>autoincrement=True</code>&nbsp;&mdash; признак автоинкрементного поля. Используется для увеличения значения первичного ключа на&nbsp;единицу при вставке каждой новой записи</li>
<li><code>nullable=True/False</code>&nbsp;&mdash; может&nbsp;ли поле не&nbsp;содержать никакой информации и&nbsp;быть пустым</li>
<li><code>unique=True/False</code>&nbsp;&mdash; содержит&nbsp;ли поле только уникальные значения или они могут повторяться</li>
<li><code>default=datetime.datetime.now</code>&nbsp;&mdash; значение по&nbsp;умолчанию. В&nbsp;данном случае мы&nbsp;говорим, что при вставке нового пользователя будет вставлена дата и&nbsp;время на&nbsp;момент его создания. Обратите внимание: мы&nbsp;не&nbsp;вызываем функцию, а&nbsp;передаем&nbsp;ее. Если&nbsp;бы мы&nbsp;вызвали функцию, то&nbsp;текущее время было&nbsp;бы вычислено только один раз при запуске сервера и&nbsp;было&nbsp;бы одинаковое для всех пользователей, которые были&nbsp;бы созданы после этого</li>
<li><code>index=True</code>&nbsp;&mdash; создать индекс по&nbsp;этому полю. <a class="material__link" href="https://ru.wikipedia.org/wiki/Индекс_(базы_данных)" target="_blank" rel="noopener noreferrer">Индекс</a>, если говорить упрощенно, позволяет значительно повысить скорость поиска по&nbsp;одному или нескольким полям базы данных. Цена этого&nbsp;&mdash; уменьшение скорости вставки данных, поэтому не&nbsp;стоит делать индексы на&nbsp;абсолютно все поля, а&nbsp;только на&nbsp;те (и&nbsp;ту&nbsp;их&nbsp;комбинацию), по&nbsp;которым будет часто осуществляться поиск</li>
</ul>
<p>Запустим наше приложение. Но&nbsp;почему ничего не&nbsp;произошло? Почему не&nbsp;создалась таблица?</p>
<p>На&nbsp;самом деле все просто. Наша база пока не&nbsp;знает про нашу модель. Давайте добавим информацию о&nbsp;ней в&nbsp;файл __all_models.py.</p>
<pre><code class="language-python">from . import users
</code></pre>
<p>Запустим еще раз.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/sqlalchemy-1.png" width="388" height="auto" /></div>
<p>Ура, все заработало!</p>
</section>
<section class="material__chapter">
<h2 id="6">Таблица с&nbsp;новостями</h2>
<p>По&nbsp;аналогии рядом с&nbsp;файлом users.py создадим файл news.py, а&nbsp;в&nbsp;нем&nbsp;&mdash; класс <var>News</var> для хранения следующей информации о&nbsp;новости:</p>
<ul>
<li>Уникальный идентификатор</li>
<li>Заголовок новости</li>
<li>Текст новости</li>
<li>Дата создания новости</li>
<li>Приватность новости (показывать&nbsp;ли ее&nbsp;всем или только автору)</li>
<li>Идентификатор автора новости</li>
</ul>
<pre><code class="language-python">import datetime
import sqlalchemy
from sqlalchemy import orm

from .db_session import SqlAlchemyBase


class News(SqlAlchemyBase):
    __tablename__ = 'news'

    id = sqlalchemy.Column(sqlalchemy.Integer, 
                           primary_key=True, autoincrement=True)
    title = sqlalchemy.Column(sqlalchemy.String, nullable=True)
    content = sqlalchemy.Column(sqlalchemy.String, nullable=True)
    created_date = sqlalchemy.Column(sqlalchemy.DateTime, 
                                     default=datetime.datetime.now)
    is_private = sqlalchemy.Column(sqlalchemy.Boolean, default=True)

    user_id = sqlalchemy.Column(sqlalchemy.Integer, 
                                sqlalchemy.ForeignKey("users.id"))
    user = orm.relationship('User')
</code></pre>
<p>Здесь стоит обратить внимание на&nbsp;поля <var>user_id</var> и&nbsp;<var>user</var>.</p>
<p><var>user_id</var>&nbsp;&mdash; колонка, в&nbsp;которой указывается, что она ссылается на&nbsp;поле <var>id</var>&nbsp;таблицы <var>users</var>. А&nbsp;<var>user</var>&nbsp;&mdash; атрибут, который позволит нам получить для новости полноценный объект класса <var>User</var>.</p>
<p>Немного модифицируем наш класс с&nbsp;пользователями, добавим туда строчку:</p>
<pre><code class="language-python">news = orm.relationship("News", back_populates='user')
</code></pre>
<p>И в блок импортов строчку:</p>
<pre><code class="language-python">from sqlalchemy import orm
</code></pre>
<p>Это позволит нам легко получать для пользователя все его новости. Обратите внимание: значение параметра <var>back_populates</var> должно указывать не&nbsp;на&nbsp;таблицу, а&nbsp;на&nbsp;атрибут класса <var>orm.relationship</var>.</p>
<p>Чтобы подключить модель <var>News</var> к&nbsp;нашей базе данных, в&nbsp;файл __all_models.py надо добавить строку:</p>
<pre><code class="language-python">from . import news
</code></pre>
<p>Удалим базу данных и&nbsp;запустим наше приложение заново, чтобы все таблицы пересоздались. Вот какие две таблицы у&nbsp;нас получились в&nbsp;базе данных:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/sqlalchemy-2.png" width="576" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="7">Взаимодействие с&nbsp;базой данных</h2>
<p>Давайте ненадолго сместим фокус от&nbsp;создания веб-приложения на&nbsp;взаимодействие с&nbsp;базой данных с&nbsp;помощью sqlalchemy.</p>
<p>Можно пока временно закомментировать строку <code>app.run()</code> в&nbsp;файле main.py.</p>
<p>Давайте напишем код, который создает пользователя в&nbsp;нашей базе данных.</p>
<p>Добавьте в секцию импортов строку</p>
<pre><code class="language-python">from data.users import User
</code></pre>
<p>чтобы можно было использовать класс <var>User</var>.</p>
<p>За&nbsp;добавление объектов отвечает метод <var>add</var> у&nbsp;объекта <var>session</var>.</p>
<pre><code class="language-python">user = User()
user.name = "Пользователь 1"
user.about = "биография пользователя 1"
user.email = "email@email.ru"
db_sess = db_session.create_session()
db_sess.add(user)
db_sess.commit()
</code></pre>
<p>Создадим еще нескольких пользователей, чтобы данные в&nbsp;таблице выглядели примерно вот так:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/sqlalchemy-3.png" width="680" height="auto" /></div>
<p>За&nbsp;получение данных отвечает метод <var>query</var> объекта <var>session</var>. В&nbsp;качестве параметра передаются классы объектов, которые мы&nbsp;хотим достать. Например, давайте достанем первого пользователя в&nbsp;выборке:</p>
<pre><code class="language-python">user = db_sess.query(User).first()
print(user.name)
</code></pre>
<pre><samp>Пользователь 1</samp></pre>
<p>А&nbsp;теперь пройдемся вообще по&nbsp;всем пользователям в&nbsp;таблице. Для более красивого представления переопределите метод <var>__repr__</var> у&nbsp;класса <var>User</var>:</p>
<pre><code class="language-python">for user in db_sess.query(User).all():
    print(user)
</code></pre>
<pre><samp>&lt;User&gt; 1&nbsp;Пользователь 1&nbsp;email@email.ru
&lt;User&gt; 2&nbsp;Пользователь 2&nbsp;email2@email.ru
&lt;User&gt; 3&nbsp;Пользователь 3&nbsp;email1@email.ru</samp></pre>
<p>Метод <code>filter()</code> позволяет отфильтровать результаты с&nbsp;помощью оператора WHERE, примененного к&nbsp;запросу. Он&nbsp;принимает колонку, оператор или значение. Например, давайте отфильтруем пользователей и&nbsp;выберем только тех, у&nbsp;которых id &gt; 1, а&nbsp;почта не&nbsp;содержит&nbsp;1.</p>
<pre><code class="language-python">for user in db_sess.query(User).filter(User.id &gt; 1, User.email.notilike("%1%")):
    print(user)
</code></pre>
<pre><samp>&lt;User&gt; 2&nbsp;Пользователь 2&nbsp;email2@email.ru</samp></pre>
<p>Условия, перечисленные в&nbsp;скобках <var>filter</var> через запятую, соединяются в&nbsp;запросе через AND. Давайте изменим запрос, чтобы условия фильтра соединялись через&nbsp;OR:</p>
<pre><code class="language-python">for user in db_sess.query(User).filter((User.id &gt; 1) | (User.email.notilike("%1%"))):
    print(user)
</code></pre>
<p>Обратите внимание: в&nbsp;этом случае скобки вокруг частей фильтра <strong>обязательны</strong>.</p>
<p>Разумеется, sqlalchemy позволяет нам изменять и&nbsp;удалять записи в&nbsp;таблицах. Изменение записи сделать очень просто, надо выбрать нужную запись, поменять нужные атрибуты, а&nbsp;потом вызвать у&nbsp;сессии метод <var>commit</var>. Переименуем пользователя с&nbsp;id&nbsp;1:</p>
<pre><code class="language-python">user = db_sess.query(User).filter(User.id == 1).first()
print(user)
user.name = "Измененное имя пользователя"
user.created_date = datetime.datetime.now()
db_sess.commit()
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/sqlalchemy-4.png" width="680" height="auto" /></div>
<p>За&nbsp;удаление записей отвечает метод <code>delete()</code>.</p>
<p>Мы&nbsp;можем удалить как несколько записей по&nbsp;фильтру:</p>
<pre><code class="language-python">db_sess.query(User).filter(User.id &gt;= 3).delete()
db_sess.commit()
</code></pre>
<p>Так и&nbsp;какую-то уже заранее выбранную запись:</p>
<pre><code class="language-python">user = db_sess.query(User).filter(User.id == 2).first()
db_sess.delete(user)
db_sess.commit()
</code></pre>
<p>После всех изменений в&nbsp;базе данных не&nbsp;забывайте сделать <var>commit</var>.</p>
<p>После всех этих операций у&nbsp;нас должен остаться в&nbsp;базе всего один пользователь. Давайте добавим ему записи. Это можно сделать несколькими способами. Мы&nbsp;можем создать объект класса <var>News</var> и&nbsp;заполнить его поля, в&nbsp;том числе указать явно <var>id</var>&nbsp;записи автора:</p>
<pre><code class="language-python">news = News(title="Первая новость", content="Привет блог!", 
            user_id=1, is_private=False)
db_sess.add(news)
db_sess.commit()
</code></pre>
<p>Можем в&nbsp;качестве <var>user</var> указать объект класса <var>User</var>, выбранный (или созданный) заранее:</p>
<pre><code class="language-python">user = db_sess.query(User).filter(User.id == 1).first()
news = News(title="Вторая новость", content="Уже вторая запись!", 
            user=user, is_private=False)
db_sess.add(news)
db_sess.commit()
</code></pre>
<p>И&nbsp;самый удобный на&nbsp;наш взгляд вариант&nbsp;&mdash; использовать&nbsp;то, что через объект класса <var>User</var> мы&nbsp;можем взаимодействовать с&nbsp;его записями в&nbsp;таблице <var>News</var> почти как со&nbsp;списком:</p>
<pre><code class="language-python">user = db_sess.query(User).filter(User.id == 1).first()
news = News(title="Личная запись", content="Эта запись личная", 
            is_private=True)
user.news.append(news)
db_sess.commit()
</code></pre>
<p>Так&nbsp;же легко мы&nbsp;можем обойти все новости конкретного пользователя:</p>
<pre><code class="language-python">for news in user.news:
    print(news)
</code></pre>
<p>sqlalchemy&nbsp;&mdash; невероятно мощный и&nbsp;гибкий инструмент. Обязательно загляните в&nbsp;<a class="material__link" href="https://docs.sqlalchemy.org/en/13/" target="_blank" rel="noopener noreferrer">документацию</a>, потому что мы&nbsp;рассмотрели только самый минимум, необходимый для создания небольших веб-приложений и&nbsp;учебных проектов.</p>
</section>
<section class="material__chapter">
<h2 id="8">Небольшая шпаргалка по&nbsp;filter</h2>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<thead>
<tr>
<th>Операция</th>
<th>Синтаксис ORM</th>
</tr>
</thead>
<tbody>
<tr>
<td>EQUALS</td>
<td>query(User).filter(User.name == 'Иван')</td>
</tr>
<tr>
<td>NOT EQUAL</td>
<td>query(User).filter(User.name != 'Иван')</td>
</tr>
<tr>
<td>LIKE</td>
<td>query(User).filter(User.name.like('%Иван%'))</td>
</tr>
<tr>
<td>NOT LIKE</td>
<td>query(User).filter(User.name.notlike('%Иван%'))</td>
</tr>
<tr>
<td>IN</td>
<td>query(User).filter(User.name.in_(['Иван', 'Петр', 'Максим']))</td>
</tr>
<tr>
<td>NOT IN</td>
<td>query(User).filter(User.name.notin_(['Иван', 'Петр', 'Максим'])) или <br />query(User).filter(~User.name.in_(['Иван', 'Петр', 'Максим']))</td>
</tr>
<tr>
<td>NULL</td>
<td>query(User).filter(User.name == None)</td>
</tr>
<tr>
<td>AND</td>
<td>query(User).filter(User.name == 'Иван', User.id &gt; 3) или query(User).filter(User.name == 'Иван').filter(User.id &gt; 3)</td>
</tr>
<tr>
<td>OR</td>
<td>query(User).filter((User.name == 'Иван') | (User.id &gt; 3)) или <br />query(User).filter(or_(User.name == 'Иван', User.id &gt; 3))</td>
</tr>
</tbody>
</table>
</div>
</section>
<section class="material__chapter">
<h2 id="9">Отображение публичных записей</h2>
<p>Воспользуемся наработками прошлых уроков и&nbsp;создадим новый шаблон index.html на&nbsp;основе базового шаблона base.html, который мы&nbsp;делали на&nbsp;прошлом уроке. Скопируйте папку templates со&nbsp;всем ее содержимым из&nbsp;материалов, созданных на&nbsp;прошлом уроке, и&nbsp;отредактируйте файл index.html, чтобы он&nbsp;выглядел так:</p>
<pre><code class="language-python">{% extends "base.html" %}

{% block content %}
&lt;h1&gt;Записи в блоге&lt;/h1&gt;
{% for item in news%}
&lt;div class="col-md6 border rounded"&gt;
    &lt;h2&gt;{{item.title}}&lt;/h2&gt;
    &lt;div&gt;
        {{item.content}}
    &lt;/div&gt;
    &lt;div&gt;
        Автор - {{item.user.name}}, Дата написания - {{item.created_date}}
    &lt;/div&gt;
&lt;/div&gt;
{% endfor %}
{% endblock %}
</code></pre>
<p>Обратите внимание: из&nbsp;каждой записи мы&nbsp;можем легко добраться до&nbsp;имени автора этой записи. А&nbsp;теперь добавим обработчик, чтобы при попадании на&nbsp;главную страницу нашего приложения все пользователи видели все публичные записи от&nbsp;всех авторов.</p>
<pre><code class="language-python">@app.route("/")
def index():
    db_sess = db_session.create_session()
    news = db_sess.query(News).filter(News.is_private != True)
    return render_template("index.html", news=news)
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/sqlalchemy-5.png" width="680" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="10">Регистрация пользователей</h2>
<p>Редко какое веб-приложение обходится без функциональности, доступной лишь зарегистрированным пользователям. Давайте добавим возможность пользователям регистрироваться в&nbsp;нашем приложении. Все классы для форм разместим в&nbsp;отдельном каталоге forms. Создадим в&nbsp;каталоге forms файл user.py, а&nbsp;в&nbsp;нем&nbsp;&mdash; класс, описывающий форму <var>RegisterForm</var>, в&nbsp;которую добавим все поля, которые будут в&nbsp;форме регистрации:</p>
<pre><code class="language-python">from flask_wtf import FlaskForm
from wtforms import PasswordField, StringField, TextAreaField, SubmitField, EmailField
from wtforms.validators import DataRequired


class RegisterForm(FlaskForm):
    email = EmailField('Почта', validators=[DataRequired()])
    password = PasswordField('Пароль', validators=[DataRequired()])
    password_again = PasswordField('Повторите пароль', validators=[DataRequired()])
    name = StringField('Имя пользователя', validators=[DataRequired()])
    about = TextAreaField("Немного о себе")
    submit = SubmitField('Войти')
</code></pre>
<p>Спросим пароль у&nbsp;пользователя несколько раз, чтобы убедиться, что он&nbsp;нигде не&nbsp;опечатался.</p>
<p>Теперь в папке templates создадим шаблон register.html для отображения нашей формы, он&nbsp;может выглядеть так:</p>
<pre><code class="language-python">{% extends "base.html" %}

{% block content %}
&lt;h1&gt;Регистрация&lt;/h1&gt;
&lt;form action="" method="post"&gt;
    {{ form.hidden_tag() }}
    &lt;p&gt;
        {{ form.email.label }}&lt;br&gt;
        {{ form.email(class="form-control", type="email") }}&lt;br&gt;
        {% for error in form.email.errors %}
            &lt;p class="alert alert-danger" role="alert"&gt;
                {{ error }}
            &lt;/p&gt;
        {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;
        {{ form.password.label }}&lt;br&gt;
        {{ form.password(class="form-control", type="password") }}&lt;br&gt;
        {% for error in form.password.errors %}
            &lt;p class="alert alert-danger" role="alert"&gt;
                {{ error }}
            &lt;/p&gt;
        {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;
        {{ form.password_again.label }}&lt;br&gt;
        {{ form.password_again(class="form-control", type="password") }}&lt;br&gt;
        {% for error in form.password_again.errors %}
            &lt;p class="alert alert-danger" role="alert"&gt;
                {{ error }}
            &lt;/p&gt;
        {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;
        {{ form.name.label }}&lt;br&gt;
        {{ form.name(class="form-control") }}&lt;br&gt;
        {% for error in form.name.errors %}
            &lt;p class="alert alert-danger" role="alert"&gt;
                {{ error }}
            &lt;/p&gt;
        {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;
        {{ form.about.label }}&lt;br&gt;
        {{ form.about(class="form-control") }}&lt;br&gt;
        {% for error in form.about.errors %}
            &lt;p class="alert alert-danger" role="alert"&gt;
                {{ error }}
            &lt;/p&gt;
        {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;{{ form.submit(type="submit", class="btn btn-primary") }}&lt;/p&gt;
    {{message}}
&lt;/form&gt;
{% endblock %}
</code></pre>
<p>Прежде чем создавать обработчик URL, который будет отвечать за&nbsp;форму регистрации, давайте немного доработаем наш класс <var>User</var>. Как мы&nbsp;уже говорили, хранить пароль в&nbsp;открытом виде нельзя, поэтому во&nbsp;Flask есть инструменты, которые позволяют получить хешированное значение по&nbsp;строке и&nbsp;проверить, соответствует&nbsp;ли пароль хешу, который хранится в&nbsp;нашей базе данных. Функции <var>generate_password_hash</var> и&nbsp;<var>check_password_hash</var> хранятся в&nbsp;модуле werkzeug.security. Для большего удобства добавим в&nbsp;класс <var>User</var> две функции:</p>
<pre><code class="language-python">def set_password(self, password):
    self.hashed_password = generate_password_hash(password)

def check_password(self, password):
    return check_password_hash(self.hashed_password, password)
</code></pre>
<p>Первая устанавливает значение хэша пароля для переданной строки. А&nbsp;вторая проверяет, правильный&nbsp;ли пароль ввел пользователь. Одна понадобится нам для регистрации пользователя, а&nbsp;другая&nbsp;&mdash; позднее, когда мы&nbsp;будем делать авторизацию пользователей в&nbsp;нашем приложении.</p>
<p>А в раздел импортов добавим:</p>
<pre><code class="language-python">from werkzeug.security import generate_password_hash, check_password_hash
</code></pre>
<p>Добавим обработчик на&nbsp;адрес /register.</p>
<pre><code class="language-python">@app.route('/register', methods=['GET', 'POST'])
def reqister():
    form = RegisterForm()
    if form.validate_on_submit():
        if form.password.data != form.password_again.data:
            return render_template('register.html', title='Регистрация',
                                   form=form,
                                   message="Пароли не совпадают")
        db_sess = db_session.create_session()
        if db_sess.query(User).filter(User.email == form.email.data).first():
            return render_template('register.html', title='Регистрация',
                                   form=form,
                                   message="Такой пользователь уже есть")
        user = User(
            name=form.name.data,
            email=form.email.data,
            about=form.about.data
        )
        user.set_password(form.password.data)
        db_sess.add(user)
        db_sess.commit()
        return redirect('/login')
    return render_template('register.html', title='Регистрация', form=form)
</code></pre>
<p>Не забудьте импортировать форму:</p>
<pre><code class="language-python">from forms.user import RegisterForm
</code></pre>
<p>После отправки формы на&nbsp;сервер проверяем, что пароли совпадают, а&nbsp;также что пользователя с&nbsp;таким адресом электронной почты пока нет в&nbsp;нашей базе данных.</p>
<p>Если все хорошо, добавляем пользователя в&nbsp;базу данных и&nbsp;отправляем его на&nbsp;страницу авторизации, которую сделаем на&nbsp;следующем уроке.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/sqlalchemy-6.png" width="680" height="auto" /></div>
<p>После добавления всех необходимых файлов в&nbsp;проект он&nbsp;должен выглядеть так:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/sqlalchemy-proj.png" width="230" height="auto" /></div>
<p><strong>Заключение.</strong></p>
<p>На&nbsp;этом уроке мы&nbsp;научились работать с&nbsp;ORM sqlalchemy и&nbsp;написали каркас нашего приложения, страницу отображения новостей, а&nbsp;также страницу регистрации пользователей. На&nbsp;следующем уроке мы&nbsp;сделаем авторизацию и&nbsp;ее&nbsp;проверку и&nbsp;поговорим еще о&nbsp;нескольких важных вещах.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>