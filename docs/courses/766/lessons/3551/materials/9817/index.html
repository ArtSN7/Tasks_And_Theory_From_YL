<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Клетчатое поле </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок PG. Поле</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Клетчатое поле</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Что такое клетчатое поле?</a></li>
<li><a class="material__link" href="#2">Создание класса</a></li>
<li><a class="material__link" href="#3">Реакция поля на&nbsp;события мыши</a></li>
<li><a class="material__link" href="#4">Пример</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Мы&nbsp;начинаем рассматривать игры на&nbsp;клетчатом поле. Это занятие посвящено идеологии клетчатых игр и&nbsp;реализации простейших алгоритмов. Продолжим на&nbsp;следующем занятии.</p>
</section>
<section class="material__chapter">
<h2 id="1">Что такое клетчатое поле?</h2>
<p>В&nbsp;основе очень многих игр лежит клетчатое поле. Оно встречается не&nbsp;только в&nbsp;шахматах, шашках и&nbsp;&laquo;крестиках-ноликах&raquo;. Это и&nbsp;стакан тетриса, и&nbsp;поле змейки. Даже обычная стратегия редко обходится без клеток.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-3-1.png" width="495" height="auto" /></div>
<p><em>Age of&nbsp;Empires тоже разделена на&nbsp;клетки-тайлы.</em></p>
<p>Поэтому очень важно научиться работать &laquo;с&nbsp;клеточками&raquo;.</p>
</section>
<section class="material__chapter">
<h2 id="2">Создание класса</h2>
<p>В&nbsp;любом большом проекте (а&nbsp;игра&nbsp;&mdash; это достаточно большая программа) проще мыслить объектно. Поэтому мы&nbsp;будем строить <strong>класс</strong> клетчатого поля. Чаще всего используется прямоугольное поле с&nbsp;квадратными клетками.</p>
<p>Давайте подумаем, какие поля и&nbsp;какие методы будут в&nbsp;проектируемом классе? Что общего между всеми полями всех игр?</p>
<p>На&nbsp;этот вопрос можно отвечать немного по-разному, но&nbsp;неоспоримым фактом остается&nbsp;то, что у&nbsp;поля есть <strong>размер</strong>, который можно измерить в&nbsp;клетках. Кроме того, важные параметры игрового поля&nbsp;&mdash; это размер клетки, а&nbsp;также положение его верхнего левого угла на&nbsp;экране.</p>
<p>Поле должно уметь как минимум <strong>создаваться</strong> и&nbsp;<strong>рисоваться</strong> (отображать свое текущее состояние).</p>
<p>Для того чтобы программа была гибкой, реализуем принципы рисования отдельно.</p>
<p>Само поле можно представить двумерным списком. Для большинства задач достаточно хранить в&nbsp;этом списке обычные целые числа.</p>
<p>Класс можно определить примерно так:</p>
<pre><code class="language-python">class Board:
    # создание поля
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.board = [[0] * width for _ in range(height)]
        # значения по умолчанию
        self.left = 10
        self.top = 10
        self.cell_size = 30

    # настройка внешнего вида
    def set_view(self, left, top, cell_size):
        self.left = left
        self.top = top
        self.cell_size = cell_size
</code></pre>
<p><em>На&nbsp;этом занятии мы&nbsp;не&nbsp;будем рассматривать практически ничего нового из&nbsp;возможностей библиотеки Pygame, и&nbsp;в&nbsp;процессе занятия вам сразу предстоит решать задачи.</em></p>
<p>Для упрощения дальнейшей работы стоит отрисовывать поле не&nbsp;линиями, а&nbsp;квадратами. В&nbsp;этом случае мы&nbsp;пройдем по&nbsp;всем клеткам, а&nbsp;ведь именно с&nbsp;клетками и&nbsp;нужно будет работать. Например, такой способ необходим, когда надо нарисовать не&nbsp;&laquo;чистый&raquo; квадрат, а&nbsp;какую-то осмысленную картинку, как в&nbsp;случае с&nbsp;Age of&nbsp;Empires.</p>
<p>Добавьте в&nbsp;класс <var>Board</var> метод <code>render(screen)</code>, принимающий в&nbsp;себя холст так, чтобы следующий фрагмент:</p>
<pre><code class="language-python"># поле 5 на 7
board = Board(5, 7)
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False                
    screen.fill((0, 0, 0))
    board.render(screen)
    pygame.display.flip()
</code></pre>
<p>нарисовал вот такую картинку:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-3-2.png" width="502" height="auto" /></div>
<p>А&nbsp;если заменить строку инициализации <var>board</var> и&nbsp;добавить вызов метода <code>set_view()</code> следующим образом:</p>
<pre><code class="language-python">board = Board(4, 3)
board.set_view(100, 100, 50)
</code></pre>
<p>то&nbsp;такую:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-3-3.png" width="502" height="auto" /></div>
<p>Обратите внимание, что внутри поля получается <strong>удвоение</strong> линий. Это естественно, потому что каждая клетка занимает свой собственный размер, и&nbsp;граница входит в&nbsp;размер клетки.</p>
</section>
<section class="material__chapter">
<h2 id="3">Реакция поля на&nbsp;события мыши</h2>
<p>При щелчке по&nbsp;клетке поле должно &laquo;понять&raquo;, где именно произошло нажатие, и&nbsp;среагировать на&nbsp;это событие.</p>
<p>Это удобно оформить при помощи трех дополнительных методов:</p>
<ul>
<li>Метода <code>get_cell(self, mouse_pos)</code>, который <strong>возвращает координаты клетки в&nbsp;виде кортежа</strong> по&nbsp;переданным координатам мыши. Он&nbsp;должен вернуть None, если координаты мыши оказались вне поля</li>
<li>Метода <code>on_click(self, cell_coords)</code>, который как-то изменяет поле, опираясь на&nbsp;полученные координаты клетки</li>
<li>Метода <code>get_click(self, mouse_pos)</code>&nbsp;&mdash; &laquo;диспетчера&raquo;, который получает событие нажатия и&nbsp;вызывает первые два метода</li>
</ul>
<p>Реализуйте все три описанных метода.</p>
<p>Например, метод <code>get_click()</code> может быть реализован так:</p>
<pre><code class="language-python">def get_click(self, mouse_pos):
    cell = self.get_cell(mouse_pos)
    self.on_click(cell)
</code></pre>
<p>Следуя описанной выше технологии, можно достаточно легко реализовывать логику различных игр на&nbsp;клетчатом поле. Достаточно получать координаты мыши в&nbsp;главном цикле программы и&nbsp;просто передавать ее&nbsp;полю:</p>
<pre><code class="language-python">...      
    if event.type == pygame.MOUSEBUTTONDOWN:
        board.get_click(event.pos)
...
</code></pre>
<p>А&nbsp;дальше поле сделает все само!</p>
</section>
<section class="material__chapter">
<h2 id="4">Пример</h2>
<p>Теперь надо &laquo;оживить&raquo; поле. До&nbsp;этого момента мы&nbsp;никак не&nbsp;задействовали список <var>board</var>. Что мы&nbsp;можем с&nbsp;ним делать?</p>
<p>Допустим, что в&nbsp;нашем списке хранятся нули и&nbsp;единицы. Ноль означает, что клетка <strong>черная</strong>, а&nbsp;единица&nbsp;&mdash; <strong>белая</strong>. Тогда мы&nbsp;можем, например, менять цвет клетки по&nbsp;нажатию клавиш мышки на&nbsp;противоположный, с&nbsp;черного на&nbsp;белый и&nbsp;обратно.</p>
<p>Получится монохромная интерактивная мозаика:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-3-4.png" width="274" height="auto" /></div>
<p>Кажется, что сделано очень мало. Но&nbsp;это не&nbsp;так. Построен фундамент, и&nbsp;на&nbsp;базе нашего простого класса получится достаточно быстро реализовать самые разные клеточные игры.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>