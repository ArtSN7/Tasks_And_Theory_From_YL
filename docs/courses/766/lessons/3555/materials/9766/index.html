<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Изображения. Спрайты </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок PG. Спрайты</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Изображения. Спрайты</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Изображения</a></li>
<li><a class="material__link" href="#2">Спрайты</a></li>
<li><a class="material__link" href="#3">Наследование спрайтов</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке мы&nbsp;начнем разговор об&nbsp;изображениях и&nbsp;спрайтах&nbsp;&mdash; анимационных элементах игры.</p>
</section>
<section class="material__chapter">
<h2 id="1">Изображения</h2>
<p>До&nbsp;этого момента мы&nbsp;только рисовали на&nbsp;холсте. Однако игры, в&nbsp;которых не&nbsp;используются созданные профессиональными художниками изображения, встречаются очень редко.</p>
<p>Поэтому в&nbsp;Pygame есть модуль <var>image</var> для работы с&nbsp;изображениями разных форматов. Документация на&nbsp;него находится <a class="material__link" href="http://pygame.org/docs/ref/image.html" target="_blank" rel="noopener noreferrer">здесь</a>.</p>
<p>При этом в&nbsp;Pygame нет специального класса <var>Image</var> (как, например, в&nbsp;PIL или в&nbsp;PyQT), а&nbsp;изображения представлены объектами класса <var>Surface</var>, с&nbsp;которым мы&nbsp;познакомились еще на&nbsp;самом первом занятии. Чтобы создать простую картинку и&nbsp;вывести ее&nbsp;на&nbsp;экран, можно поступить так:</p>
<pre><code class="language-python"># загруженные изображения &mdash; это, фактически, обычный Surface
image = pygame.Surface([100, 100])
image.fill(pygame.Color("red"))
...
screen.blit(image, (10, 10))
</code></pre>
<p>Но, конечно, для нас интерес представляет именно <em>загрузка</em> готовых изображений. Это делается с&nbsp;помощью функции <code>load()</code> модуля <var>image</var>. Давайте напишем к&nbsp;ней собственную функцию-обертку, которая будет загружать изображение по&nbsp;имени файла, в&nbsp;котором оно хранится.</p>
<p>Пусть ее&nbsp;сигнатура будет следующей:</p>
<pre><code class="language-python">def load_image(name, colorkey=None)
</code></pre>
<p>Помимо имени изображения у&nbsp;функции будет еще один необязательный параметр&nbsp;&mdash; <var>colorkey</var>, который мы&nbsp;будем использовать чуть позже, чтобы обрезать фон изображения.</p>
<p>Игровые ресурсы (картинки, звуковые файлы, видеофрагменты) принято хранить в&nbsp;специальной папке отдельно от&nbsp;кода программы.</p>
<p>Условимся, что мы&nbsp;<strong>храним все ресурсы в&nbsp;папке data</strong>.</p>
<p>Кроме того, нужно учесть, что если файла с&nbsp;указанным именем не&nbsp;существует, нужно вывести сообщение об&nbsp;ошибке.</p>
<p>В&nbsp;результате фрагмент загрузки изображения будет выглядеть следующим образом:</p>
<pre><code class="language-python">import os
import sys

import pygame

# Изображение не получится загрузить 
# без предварительной инициализации pygame
pygame.init()
size = width, height = 500, 500
screen = pygame.display.set_mode(size)


def load_image(name, colorkey=None):
    fullname = os.path.join('data', name)
    # если файл не существует, то выходим
    if not os.path.isfile(fullname):
        print(f"Файл с изображением '{fullname}' не найден")
        sys.exit()
    image = pygame.image.load(fullname)
    return image
</code></pre>
<p>Обычно картинки должны быть с&nbsp;прозрачным фоном. Чтобы человечек выглядел именно человечком, а&nbsp;не&nbsp;черным или белым квадратиком, на&nbsp;котором нарисован человечек.</p>
<p>Если при этом изображение уже прозрачно (это обычно бывает у&nbsp;картинок форматов png и&nbsp;gif), то&nbsp;после загрузки вызываем функцию <code>convert_alpha()</code>, и&nbsp;загруженное изображение сохранит прозрачность.</p>
<p>Если изображение было непрозрачным, то&nbsp;используем функцию <var>Surface</var> <code>set_colorkey(colorkey)</code>, и&nbsp;тогда переданный ей&nbsp;цвет станет прозрачным.</p>
<p>Сделаем функцию удобной: если мы&nbsp;передадим в&nbsp;качестве <var>colorkey</var> специальное значение (скажем, &minus;1), функция сама возьмет прозрачным цветом левый верхний угол изображения (обычно это будет цвет фона, который хочется сделать прозрачным).</p>
<pre><code class="language-python">if colorkey is not None:
    image = image.convert()
    if colorkey == -1:
        colorkey = image.get_at((0, 0))
    image.set_colorkey(colorkey)
else:
    image = image.convert_alpha()
return image
</code></pre>
<p>Наша функция <code>load_image()</code> возвращает <var>Surface</var>, на&nbsp;котором расположено изображение &laquo;в&nbsp;натуральную величину&raquo;.</p>
<p>Лучше сразу подготавливать правильный размер изображения в&nbsp;графическом редакторе, но&nbsp;при необходимости можно изменить его с&nbsp;помощью функции <code>scale()</code> модуля <var>transform</var>:</p>
<pre><code class="language-python">image = load_image("owls.png")
image1 = pygame.transform.scale(image, (200, 100))
image2 = pygame.transform.scale(image, (100, 200))
</code></pre>
<p>Созданные изображения будут выглядеть так:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-5-1.png" width="600" height="auto" /></div>
<p>Если присмотреться, то&nbsp;видно, что у&nbsp;измененных изображений появляются артефакты. Именно поэтому предварительная подгонка изображений под нужные размеры является очень важным этапом создания игры.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-5-2.png" width="216" height="auto" /></div>
<p>На&nbsp;странице <a class="material__link" href="https://www.pygame.org/docs/ref/transform.html" target="_blank" rel="noopener noreferrer">документации модуля transform</a> есть много других функций по&nbsp;преобразованию изображений.</p>
</section>
<section class="material__chapter">
<h2 id="2">Спрайты</h2>
<p>До&nbsp;этого момента мы&nbsp;работали с&nbsp;&laquo;клеточными&raquo; играми, в&nbsp;которых каждый объект занимал свою клетку на&nbsp;игровом поле.</p>
<p>Но&nbsp;во&nbsp;многих играх объекты имеют произвольные размеры (не&nbsp;привязаны к&nbsp;клеткам), и&nbsp;при этом важно управлять движением и&nbsp;взаимоотношениями нескольких объектов (например, столкновениями: выстрел попадает в&nbsp;танк, человечек подходит к&nbsp;лестнице и&nbsp;т.д.). В&nbsp;этом нам помогут <strong>спрайты</strong>.</p>
<p>Назовем <strong>спрайтом</strong> произвольный игровой графический объект. Этот объект может перемещаться по&nbsp;игровому полю или быть неподвижным, им&nbsp;может управлять игрок, или&nbsp;же его поведение контролируется непосредственно алгоритмом игры.</p>
<p><strong>У&nbsp;спрайтов нет функции draw().</strong> Для того чтобы работать со&nbsp;спрайтами, их&nbsp;объединяют в&nbsp;группы. Потом достаточно отрисовать группу, и&nbsp;все спрайты, принадлежащие группе, будут отрисованы (мы&nbsp;уже сталкивались с&nbsp;подобным принципом). Спрайт может и&nbsp;обычно принадлежит нескольким группам одновременно.</p>
<p>При создании спрайта нужно <strong>не&nbsp;забыть</strong> задать его вид (<var>image</var>) и&nbsp;размер (<var>rect</var>). Обычно для определения размеров берут прямоугольник, ограничивающий загруженное изображение.</p>
<p>Для работы со&nbsp;спрайтами в&nbsp;Pygame есть специальный модуль&nbsp;&mdash; <a class="material__link" href="https://www.pygame.org/docs/ref/sprite.html" target="_blank" rel="noopener noreferrer">sprite</a>. По&nbsp;ссылке есть много интересной информации и&nbsp;дополнительных примеров.</p>
<p>В&nbsp;простейшем случае спрайт можно создать так:</p>
<pre><code class="language-python"># создадим группу, содержащую все спрайты
all_sprites = pygame.sprite.Group()

# создадим спрайт
sprite = pygame.sprite.Sprite()
# определим его вид
sprite.image = load_image("bomb.png")
# и размеры
sprite.rect = sprite.image.get_rect()
# добавим спрайт в группу
all_sprites.add(sprite)
</code></pre>
<p>Для размещения спрайта на&nbsp;холсте надо задать координаты его левого верхнего угла:</p>
<pre><code class="language-python">sprite.rect.x = 5
sprite.rect.y = 20
</code></pre>
<p>При этом размеры спрайта нигде не&nbsp;указываются, а&nbsp;определяются размерами картинки, которая спрайт создает.</p>
<p>Как уже говорилось, для изменения размеров самой картинки можно применять функцию <code>scale()</code> модуля <var>transform</var>, но&nbsp;такой способ не&nbsp;рекомендуется.</p>
<p>Соответственно, если мы&nbsp;хотим разбросать пятьдесят бомбочек по&nbsp;экрану, нам поможет такой код:</p>
<pre><code class="language-python"># изображение должно лежать в папке data
bomb_image = load_image("bomb.png")

for i in range(50):
    # можно сразу создавать спрайты с указанием группы
    bomb = pygame.sprite.Sprite(all_sprites)
    bomb.image = bomb_image
    bomb.rect = bomb.image.get_rect()

    # задаём случайное местоположение бомбочке
    bomb.rect.x = random.randrange(width)
    bomb.rect.y = random.randrange(height)
</code></pre>
<p>В&nbsp;главном игровом цикле достаточно отрисовать группу одной командой:</p>
<pre><code class="language-python"># в главном игровом цикле
all_sprites.draw(screen)
</code></pre>
<p>Попробуйте собрать все &laquo;кусочки&raquo; программы и&nbsp;получить следующий результат:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-5/pygame-5-3.png" width="500" height="auto" /></div>
<p>Можно заметить, что некоторые бомбочки не&nbsp;только залезают за&nbsp;край экрана, но&nbsp;и&nbsp;накладываются друг на&nbsp;друга. Пока закроем на&nbsp;это глаза. На&nbsp;следующем занятии мы&nbsp;подробно поговорим о&nbsp;пересечениях спрайтов. Это очень просто решит проблему наложения.</p>
</section>
<section class="material__chapter">
<h2 id="3">Наследование спрайтов</h2>
<p>Код работы со&nbsp;спрайтами выглядит достаточно громоздким. Например, после создания спрайта его нужно &laquo;донастраивать&raquo; отдельными командами.</p>
<p>Работа со&nbsp;спрайтами станет значительно проще, если использовать &laquo;объектный&raquo; подход и&nbsp;унаследовать новый класс-спрайт от&nbsp;<code>pygame.sprite.Sprite</code>.</p>
<p>При наследовании важно не&nbsp;забыть вызвать конструктор базового класса. Иначе мы&nbsp;получим ошибку:</p>
<pre><code class="language-python">AttributeError: 'mysprite' instance has no attribute '_Sprite__g'
</code></pre>
<p>В&nbsp;производном классе можно добавить свои функции, а&nbsp;также переопределить функцию <code>update()</code>. Тогда при вызове этой функции для группы, произойдет вызов <code>update()</code> для каждого спрайта, который входит в&nbsp;нее.</p>
<p>Наши бомбочки в&nbsp;виде класса оформляются так:</p>
<pre><code class="language-python">class Bomb(pygame.sprite.Sprite):
    image = load_image("bomb.png")

    def __init__(self, *group):
        # НЕОБХОДИМО вызвать конструктор родительского класса Sprite. 
        # Это очень важно!!!
        super().__init__(*group)
        self.image = Bomb.image
        self.rect = self.image.get_rect()
        self.rect.x = random.randrange(width)
        self.rect.y = random.randrange(height)

    def update(self):
        self.rect = self.rect.move(random.randrange(3) - 1, 
                                   random.randrange(3) - 1)
</code></pre>
<p>Тогда код создания упростится:</p>
<pre><code class="language-python">for _ in range(50):
    Bomb(all_sprites)
</code></pre>
<p>И&nbsp;при обновлении группы в&nbsp;главном игровом цикле</p>
<pre><code class="language-python"># в главном игровом цикле
all_sprites.draw(screen)
all_sprites.update()
</code></pre>
<p>бомбочки начинают дрожать.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-5-4.gif" width="296" height="auto" /></div>
<p>Весь игровой мир можно реализовать на&nbsp;спрайтах.</p>
<p>Чтобы мир стал интерактивным, спрайтам можно добавлять свои функции, в&nbsp;которые передавать события из&nbsp;главного игрового цикла.</p>
<p>Но&nbsp;это не&nbsp;очень удобно: для вызова метода у&nbsp;всех спрайтов в&nbsp;группе придется перебирать все элементы в&nbsp;цикле (допустим, мы&nbsp;назвали наш метод <code>get_event()</code>):</p>
<pre><code class="language-python">if event.type == pygame.MOUSEBUTTONDOWN:
    for bomb in all_sprites:
        bomb.get_event(event)
</code></pre>
<p>Гораздо удобнее использовать для этого уже упомянутый метод <var>update</var>, который может принимать и&nbsp;дополнительные аргументы:</p>
<pre><code class="language-python">class Bomb(pygame.sprite.Sprite):
    image = load_image("bomb.png")
    image_boom = load_image("boom.png")

    def __init__(self, group):
        # НЕОБХОДИМО вызвать конструктор родительского класса Sprite. 
        # Это очень важно !!!
        super().__init__(group)
        self.image = Bomb.image
        self.rect = self.image.get_rect()
        self.rect.x = random.randrange(width)
        self.rect.y = random.randrange(height)

    def update(self, *args):
        self.rect = self.rect.move(random.randrange(3) - 1, 
                                   random.randrange(3) - 1)
        if args and args[0].type == pygame.MOUSEBUTTONDOWN and \
                self.rect.collidepoint(args[0].pos):
            self.image = self.image_boom
</code></pre>
<p>Функция <code>rect.collidepoint(pos)</code> проверяет, находится&nbsp;ли точка с&nbsp;координатами <var>pos</var> внутри прямоугольника.</p>
<p>Тогда код вызова проверки, стоит&nbsp;ли взрывать бомбочки, приобретет уже знакомый вид:</p>
<pre><code class="language-python">all_sprites.update(event)
</code></pre>
<p>Переданный <var>event</var> попадет в&nbsp;функции <var>update</var> всех элементов группы <var>all_sprites</var>.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-5/bombs3.gif" width="500" height="auto" /></div>
<p>Станет еще удобнее, если получится сделать класс группы спрайтов (своего рода &laquo;продвинутый&raquo; контейнер), принимающий события, и&nbsp;уже эта группа будет раздавать события своим элементам.</p>
<p>Программирование игр очень редко обходится без готовых изображений. Мы&nbsp;полагаем, что и&nbsp;в&nbsp;вашем проекте обязательно должны использоваться спрайты.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>