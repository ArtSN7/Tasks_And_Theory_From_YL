<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Работа с простыми таблицами (csv). Работа с табличными данными в PyQT </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок QT csv</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Работа с&nbsp;простыми таблицами (csv). Работа с&nbsp;табличными данными в&nbsp;PyQT</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Хранение записей в&nbsp;файлах</a></li>
<li><a class="material__link" href="#2">Форматы с&nbsp;фиксированной длиной записи</a></li>
<li><a class="material__link" href="#3">Форматы с&nbsp;произвольной длиной записи</a></li>
<li><a class="material__link" href="#4">Формат TSV</a></li>
<li><a class="material__link" href="#5">Формат CSV</a></li>
<li><a class="material__link" href="#6">Библиотека CSV</a></li>
<li><a class="material__link" href="#7">Использование графического интерфейса. Чтение из .csv файла</a></li>
<li><a class="material__link" href="#8">PyQT. Запись из&nbsp;таблицы в .csv файл</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Урок посвящен технологии хранения однотипных записей в&nbsp;файлах, форматам с&nbsp;фиксированной и&nbsp;с&nbsp;произвольной длиной записи (DSV, TSV, CSV). Особое внимание уделено форматам с&nbsp;произвольной длиной записи, методам работы с&nbsp;ними при помощи строковых функций, а&nbsp;также специализированной библиотеки csv и&nbsp;PyQT.</p>
</section>
<section class="material__chapter">
<h2 id="1">Хранение записей в&nbsp;файлах</h2>
<p>Любой файл может содержать последовательность байт, которая интерпретируется человеком и&nbsp;прикладными программами различным образом. Например, байт с&nbsp;десятичным значением 65&nbsp;может означать и&nbsp;число&nbsp;65, и&nbsp;код латинской буквы&nbsp;A в&nbsp;зависимости от&nbsp;договоренности по&nbsp;формату. При разработке приложений очень быстро возникла необходимость хранения в файлах больших массивов однородных объектов (записей), имеющих некоторый набор полей или характеристик. По&nbsp;сути такой массив представляет собой таблицу со&nbsp;строками и&nbsp;столбцами. Каждый столбец имеет свой, как правило, примитивный тип: целое или вещественное число, строка и&nbsp;т.&nbsp;д.</p>
<p>Очень важно, что формат при этом может быть совершенно различным. Главное, чтобы все программы, которые с&nbsp;ним работают, были написаны в&nbsp;соответствии со&nbsp;спецификацией этого формата, то&nbsp;есть <strong>понимали</strong> его.</p>
<p>В&nbsp;процессе эволюции из&nbsp;всех форматов для хранения массивов записей прижились два: с&nbsp;фиксированной и&nbsp;произвольной длиной записи. А&nbsp;подлинного искусства обработка и&nbsp;хранение таблиц достигли в&nbsp;<a class="material__link" href="https://ru.wikipedia.org/wiki/Реляционная_база_данных" target="_blank" rel="noopener noreferrer">реляционных базах данных</a>, о&nbsp;которых мы&nbsp;поговорим уже очень скоро.</p>
</section>
<section class="material__chapter">
<h2 id="2">Форматы с&nbsp;фиксированной длиной записи</h2>
<p>Такие форматы практически всегда имеют байтовую, а&nbsp;не&nbsp;текстовую структуру.</p>
<p>Размер каждого поля фиксируется таким образом, чтобы иметь минимальную, но&nbsp;достаточную длину в&nbsp;байтах для представления всего диапазона значений. Как правило, на&nbsp;этом этапе возникают проблемы с&nbsp;выбором длины строковых данных.</p>
<p>Для примера рассмотрим расшифровку записи для хранения информации о&nbsp;школьнике:</p>
<ul>
<li><code>Имя: строка(50)</code></li>
<li><code>Фамилия: строка(50)</code></li>
<li><code>Возраст: однобайтовое число</code></li>
<li><code>Пол: строка(1)</code></li>
<li><code>Адрес: строка(100)</code></li>
</ul>
<p>Как видно из&nbsp;примера, в&nbsp;мире нашей программы существует ряд ограничений, например, нет адресов, которые содержат более 100&nbsp;символов.</p>
<p>Преимущества бинарных форматов с&nbsp;фиксированной длиной записи аналогичны преимуществам по&nbsp;работе с&nbsp;массивами: мы&nbsp;за&nbsp;константное время можем взять любую по&nbsp;счету запись, просто вычислив, по&nbsp;какому смещению в&nbsp;файле она располагается относительно его начала.</p>
<p>Примером файлов такого рода является, например, <a class="material__link" href="https://upload.wikimedia.org/wikipedia/commons/c/c4/BMPfileFormat.png" target="_blank" rel="noopener noreferrer">BMP-файл</a>.</p>
<p>Его структура такова: в&nbsp;первых 54&nbsp;байтах хранится так называемый <strong>заголовок</strong>. <em>Иногда его еще называют мета-данными, то&nbsp;есть данными о&nbsp;данных.</em> Он&nbsp;информирует о&nbsp;размере изображения, сжатии и&nbsp;других характеристиках всего файла. После заголовка подряд записывается информация о&nbsp;каждом пикселе изображения, на&nbsp;каждый пиксель отводится ровно 3&nbsp;байта, по&nbsp;одному байту на&nbsp;каналы R, G, B. То&nbsp;есть информация об&nbsp;изображении представляет собой массив (список) кортежей из&nbsp;трех чисел&nbsp;&mdash; значений red, green и&nbsp;blue составляющих цвета пикселя.</p>
<p>Фиксированный формат имеет и&nbsp;недостатки. Один из&nbsp;самых больших в&nbsp;том, что, как только появляется запись, одно из&nbsp;полей которой <strong>не&nbsp;влезает</strong> в&nbsp;предопределенную длину, мы&nbsp;не&nbsp;сможем использовать данный формат или вынуждены будем его видоизменить.</p>
<p>Причем, расширяя размер поля для данной записи, мы&nbsp;расширяем ее&nbsp;и&nbsp;для всех остальных, расходуя понапрасну ресурсы памяти.</p>
<p>Одна из&nbsp;самых широко известных ситуаций, связанных с&nbsp;фиксированным форматом,&nbsp;&mdash; <a class="material__link" href="https://ru.wikipedia.org/wiki/Проблема_2000_года" target="_blank" rel="noopener noreferrer">проблема 2000&nbsp;года</a>.</p>
</section>
<section class="material__chapter">
<h2 id="3">Форматы с&nbsp;произвольной длиной записи</h2>
<p>Если длина полей в&nbsp;одной записи не&nbsp;фиксирована (например, мы&nbsp;говорим, что адрес клиента может быть любой длины), нам нужно решить две проблемы:</p>
<ol>
<li>Как мы&nbsp;будем понимать, где <strong>границы полей</strong>.</li>
<li>Как мы&nbsp;будем понимать, где <strong>границы записей</strong>.</li>
</ol>
<p>Решать их&nbsp;можно по-разному: например, перед каждым полем делать служебное поле из&nbsp;4&nbsp;байт, которое показывает размер в&nbsp;байтах следующего поля. Таким образом, в&nbsp;нашем случае поле не&nbsp;сможет содержать более 4&nbsp;Гб данных.</p>
<p>Можно пойти другим путем и&nbsp;ввести специальные разделители. Поговорим про этот случай. Воспользуемся модельным примером и&nbsp;рассмотрим <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/ikea.txt" target="_blank" rel="noopener noreferrer">прайс-лист</a> товаров в&nbsp;магазине &laquo;Икея&raquo;.</p>
<p>Вот небольшой фрагмент этого файла:</p>
<pre><code>&gt; keywords	price	product_name

&gt; МОРУМ, Ковёр, безворсовый	6999	МОРУМ

&gt; МОРУМ, Ковёр, безворсовый	6999	МОРУМ

&gt; ИДБИ, Придверный коврик	649	ИДБИ

&gt; ХОДДЕ, Ковёр, безворсовый	1399	ХОДДЕ

&gt; ОПЛЕВ, Придверный коврик	599	ОПЛЕВ

&gt; ОПЛЕВ, Придверный коврик	599	ОПЛЕВ
</code></pre>
<p>Разделителем записей был выбран символ <strong>новой строки</strong>, а&nbsp;разделителем полей&nbsp;&mdash; <strong>табуляция</strong> (хотя на&nbsp;самом деле увидеть символы табуляции можно с&nbsp;трудом).</p>
<p>В&nbsp;результате мы&nbsp;получили текстовый файл, который легко читается и&nbsp;человеком, и&nbsp;компьютерной программой.</p>
<p>Назовем такой формат <strong>TSV</strong>.</p>
</section>
<section class="material__chapter">
<h2 id="4">Формат TSV</h2>
<section class="material__note">
<p class="material__note-heading"><strong>TSV</strong></p>
<p>TSV (англ. tab separated values&nbsp;&mdash; &laquo;значения, разделенные табуляцией&raquo;)&nbsp;&mdash; текстовый формат для представления таблиц баз данных. Каждая запись в&nbsp;таблице&nbsp;&mdash; строка текстового файла. Каждое поле записи отделяется от&nbsp;других символом табуляции, а&nbsp;точнее&nbsp;&mdash; горизонтальной табуляции.</p>
</section>
<p><strong>TSV</strong>&nbsp;&mdash; форма более общего формата <strong>DSV</strong> (&laquo;значения, разграниченные разделителем&raquo;, от англ. delimiter separated values).</p>
<p>Программы для работы с&nbsp;электронными таблицами (MS&nbsp;Excel, LibreOffice Calc) поддерживают импорт из&nbsp;такого формата.</p>
<details>
<summary>Импорт из&nbsp;текстового файла в&nbsp;Excel</summary>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/excel-1.png" width="680" height="auto" /></div>
<p>Шаг 1:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/excel-2.png" width="680" height="auto" /></div>
<p>Шаг 2:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/excel-3.png" width="680" height="auto" /></div>
<p>Шаг 3:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/excel-4.png" width="680" height="auto" /></div>
<p>Результат:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/excel-5.png" width="680" height="auto" /></div>
</details>
<p>Посмотрим, как работать с&nbsp;таким форматом в&nbsp;Python. Тут нет ничего сложного, поскольку у&nbsp;нас есть мощная функциональность по&nbsp;работе со&nbsp;строками, в&nbsp;частности, метод <var>split</var>.</p>
<pre><code class="language-python">data = open('files/ikea.txt', encoding='utf-8').read()
for row in data.split('\n')[:10]:
    print(row.split('\t'))
</code></pre>
<pre><samp>['keywords', 'price', 'product_name']
['МОРУМ, Ковёр, безворсовый', '6999', 'МОРУМ']
['МОРУМ, Ковёр, безворсовый', '6999', 'МОРУМ']
['ИДБИ, Придверный коврик', '649', 'ИДБИ']
['ХОДДЕ, Ковёр, безворсовый', '1399', 'ХОДДЕ']
['ОПЛЕВ, Придверный коврик', '599', 'ОПЛЕВ']
['ОПЛЕВ, Придверный коврик', '599', 'ОПЛЕВ']
['ЮНКЭН, Брикеты', '89', 'ЮНКЭН']
['БУНСЁ, Детское садовое кресло', '1199', 'БУНСЁ']
['ИКЕА ПС ВОГЭ, Садовое лёгкое кресло', '1999', 'ИКЕА ПС ВОГЭ']</samp></pre>
<p>Вспомним списочные выражения и&nbsp;сразу сделаем &laquo;двумерный массив&raquo;, а&nbsp;потом обратимся к&nbsp;цене пятого по&nbsp;счету товара:</p>
<pre><code class="language-python">table = [r.split('\t') for r in data.split('\n')]
print(table[5][1])
</code></pre>
<pre><samp>599</samp></pre>
<p>Мы&nbsp;можем также отсортировать элементы по&nbsp;цене и&nbsp;напечатать 10&nbsp;самых дешевых товаров:</p>
<pre><code class="language-python">table = table[1:]
table.sort(key=lambda x: int(x[1]))
for r in table[:10]:
    print(r)
</code></pre>
<pre><samp>['СМОРИСКА, Стопка', '6', 'СМОРИСКА']
['СМОРИСКА, Стакан', '12', 'СМОРИСКА']
['ДИСТАНС, Контейнер', '12', 'ДИСТАНС']
['ДИСТАНС, Контейнер', '12', 'ДИСТАНС']
['ОППЕН, Миска', '25', 'ОППЕН']
['ДАРРОКА, Стакан', '25', 'ДАРРОКА']
['АНТАГЕН, Щетка для мытья посуды', '25', 'АНТАГЕН']
['ВАНКИВА, Рама', '25', 'ВАНКИВА']
['ХОППЛЁС, Доска разделочная', '27', 'ХОППЛЁС']
['ДАРРОКА, Стакан д/виски', '29', 'ДАРРОКА']</samp></pre>
</section>
<section class="material__chapter">
<h2 id="5">Формат CSV</h2>
<p>Одним из&nbsp;самых распространенных форматов <strong>DSV</strong> стал <strong>CSV</strong>&nbsp;&mdash; формат с&nbsp;разделителем полей&nbsp;&mdash; запятой (англ. comma separated values). Наш файл будет выглядеть в&nbsp;нем <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/ikea.csv" target="_blank" rel="noopener noreferrer">вот так</a>:</p>
<pre><code>&gt; keywords,price,product_name

&gt;"МОРУМ, Ковёр, безворсовый",6999,МОРУМ

&gt;"МОРУМ, Ковёр, безворсовый",6999,МОРУМ

&gt;"ИДБИ, Придверный коврик",649,ИДБИ

&gt;"ХОДДЕ, Ковёр, безворсовый",1399,ХОДДЕ

&gt;"ОПЛЕВ, Придверный коврик",599,ОПЛЕВ

&gt;"ОПЛЕВ, Придверный коврик",599,ОПЛЕВ

&gt;"ЮНКЭН, Брикеты",89,ЮНКЭН

&gt;"БУНСЁ, Детское садовое кресло",1199,БУНСЁ

&gt;"ИКЕА ПС ВОГЭ, Садовое лёгкое кресло",1999,ИКЕА ПС ВОГЭ
</code></pre>
<p>Для всех форматов DSV проблемой является символ-разделитель полей в&nbsp;данных. В&nbsp;этом случае вводят так называемый <strong>разделитель текста</strong>, в&nbsp;качестве которого выступают двойные кавычки, а&nbsp;если в&nbsp;поле встречается сам разделитель текста, то&nbsp;его удваивают. Например, <strong>ООО "Светлана"</strong> при записи в&nbsp;файл превращается в&nbsp;<strong>"ООО ""Светлана"""</strong>.</p>
<p>Вот почему в&nbsp;приведенном фрагменте CSV-файла первое поле в&nbsp;кавычках&nbsp;&mdash; внутри него есть запятые.</p>
<p>Нужно отметить, что в&nbsp;CSV могут быть другие разделители, например, точка с&nbsp;запятой. Очень часто это регулируется настройками операционной системы (параметр &laquo;Разделитель элементов списка&raquo; в&nbsp;ОС&nbsp;Windows):</p>
<p>Параметры&nbsp;&mdash; Время и&nbsp;язык&nbsp;&mdash; Язык:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/windows-params.png" width="680" height="auto" /></div>
<p>Дополнительные параметры:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/qt-5-2.png" width="567" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="6">Библиотека CSV</h2>
<p>Несмотря на&nbsp;то, что DSV-форматы просты, отсутствие четких стандартов в&nbsp;выборе разделителей и&nbsp;экранировании символов привели к&nbsp;тому, что с&nbsp;ними лучше работать при помощи специализированных библиотек, а&nbsp;не&nbsp;в&nbsp;стиле &laquo;использования функции&raquo; <var>split()</var>.</p>
<p>Для работы с&nbsp;такими форматами в&nbsp;Python есть модуль <a class="material__link" href="https://docs.python.org/3/library/csv.html" target="_blank" rel="noopener noreferrer">csv</a>.</p>
<p>В&nbsp;модуле есть два основных объекта: <var>reader</var> и&nbsp;<var>writer</var>, созданные, чтобы читать и&nbsp;создавать csv-файлы соответственно.</p>
<p>Приведем пример использования <strong>читателя</strong> с&nbsp;почти полным набором значений, указав:</p>
<ul>
<li>Кодировку файла</li>
<li>Символ-разделитель</li>
<li>Разделитель текста</li>
</ul>
<p>Объект <var>reader</var> дает доступ к&nbsp;построчному итератору полностью аналогично работе с&nbsp;файлом или списком.</p>
<p>Общности ради в&nbsp;следующем примере мы&nbsp;покажем, что разделителем может быть любой символ.</p>
<pre><code class="language-python">import csv

with open('files/ikea.csv', encoding="utf8") as csvfile:
    reader = csv.reader(csvfile, delimiter=';', quotechar='"')
    for index, row in enumerate(reader):
        if index &gt; 10:
            break
        print(row)
</code></pre>
<pre><samp>['keywords', 'price', 'product_name']
['МОРУМ, Ковёр, безворсовый', '6999', 'МОРУМ']
['МОРУМ, Ковёр, безворсовый', '6999', 'МОРУМ']
['ИДБИ, Придверный коврик', '649', 'ИДБИ']
['ХОДДЕ, Ковёр, безворсовый', '1399', 'ХОДДЕ']
['ОПЛЕВ, Придверный коврик', '599', 'ОПЛЕВ']
['ОПЛЕВ, Придверный коврик', '599', 'ОПЛЕВ']
['ЮНКЭН, Брикеты', '89', 'ЮНКЭН']
['БУНСЁ, Детское садовое кресло', '1199', 'БУНСЁ']
['ИКЕА ПС ВОГЭ, Садовое лёгкое кресло', '1999', 'ИКЕА ПС ВОГЭ']
['КУНГСХОЛЬМЕН, Садовый табурет', '5500', 'КУНГСХОЛЬМЕН']</samp></pre>
<p>Давайте разберем построчно, что происходит в&nbsp;этом коде.</p>
<p>Мы&nbsp;пользуемся менеджером контекста <var>with</var>, чтобы просто открыть наш файл с&nbsp;кодировкой UTF-8, а&nbsp;потом создаем объект <var>reader</var>, говоря ему про символы-разделители полей и&nbsp;строк.</p>
<p>Объект <var>reader</var> может служить итератором (и&nbsp;использоваться в&nbsp;цикле <var>for</var>) по&nbsp;строкам, каждая из&nbsp;которых представляет собой список. При создании <var>reader </var>мы&nbsp;указываем, что символ-разделитель записей <var>delimiter</var> в&nbsp;нашем файле&nbsp;&mdash; точка с&nbsp;запятой, а&nbsp;символ кавычек <var>quotechar</var>&nbsp;&mdash; двойные кавычки. Кроме того, мы&nbsp;используем <var>enumerate</var>, чтобы посчитать строки.</p>
<p>Отметим, что исходный файл содержит подписи полей в&nbsp;первой строке, что будет снова нам мешать (например, при сортировке строк). Для корректной работы мы&nbsp;должны были&nbsp;бы исключить первую строку из&nbsp;обработки.</p>
<p>Но&nbsp;в&nbsp;модуле csv есть специальный объект <strong>DictReader</strong>, который поддерживает создание объекта-словаря на&nbsp;основе подписей к&nbsp;полям.</p>
<p><strong>DictReader</strong> не&nbsp;просто словарь, а&nbsp;словарь, который отслеживает порядок ключей после их&nbsp;добавления,&nbsp;&mdash; <strong>OrderDict</strong>, что будет дальше видно в&nbsp;примере. Дополнительно почитать про <strong>OrderDict</strong> можно <a class="material__link" href="https://docs.python.org/3.6/library/collections.html" target="_blank" rel="noopener noreferrer">тут</a>.</p>
<p>Теперь мы&nbsp;можем обращаться к&nbsp;полям не&nbsp;по&nbsp;индексу, а&nbsp;по&nbsp;<strong>названию</strong>, что делает программу еще более понятной.</p>
<p>Найдем топ-10 самых дорогих товаров (как вы&nbsp;думаете, какая запись более понятна: <code>int(x['price'])</code> или <code>int(x[1])</code>?):</p>
<pre><code class="language-python">with open('files/ikea.csv', encoding="utf8") as csvfile:
    reader = csv.DictReader(csvfile, delimiter=';', quotechar='"')
    expensive = sorted(reader, key=lambda x: int(x['price']), reverse=True)

for record in expensive[:10]:
    print(record)
</code></pre>
<pre><samp>{'keywords': 'ГРИЛЬЕРА, Плита', 'price': '99999', 'product_name': 'ГРИЛЬЕРА'}
{'keywords': 'ГРИЛЬЕРА, Плита', 'price': '99999', 'product_name': 'ГРИЛЬЕРА'}
{'keywords': 'КИВИК, Диван-кровать 3-местный', 'price': '79999', 'product_name': 'КИВИК'}
{'keywords': 'КИВИК, Диван-кровать 3-местный', 'price': '79999', 'product_name': 'КИВИК'}
{'keywords': 'СТОКГОЛЬМ, Диван 3-местный', 'price': '69999', 'product_name': 'СТОКГОЛЬМ'}
{'keywords': 'ИСАНДЕ, Встраив холодильник/морозильник А++', 'price': '59999', 'product_name': 'ИСАНДЕ'}
{'keywords': 'КУЛИНАРИСК, Комбинир СВЧ с горячим обдувом', 'price': '54999', 'product_name': 'КУЛИНАРИСК'}
{'keywords': 'ХОГКЛАССИГ, Индукц варочн панель', 'price': '49999', 'product_name': 'ХОГКЛАССИГ'}
{'keywords': 'ГРЭНСЛЁС, Комбинир СВЧ с горячим обдувом', 'price': '49999', 'product_name': 'ГРЭНСЛЁС'}
{'keywords': 'КУЛИНАРИСК, Духовка/пиролитическая самоочистка', 'price': '49999', 'product_name': 'КУЛИНАРИСК'}</samp></pre>
<p>Мы&nbsp;привели цены к&nbsp;типу <var>int</var>, потому что строки сравниваются в&nbsp;лексикографическом порядке (по&nbsp;алфавиту). Например:</p>
<pre><code class="language-python">print('11' &gt; '100')
</code></pre>
<pre><samp>True</samp></pre>
<pre><code class="language-python">print(11 &gt; 100)
</code></pre>
<pre><samp>False</samp></pre>
<p>Использование объекта для записи (<var>writer</var>) аналогично &laquo;читателю&raquo; (<var>reader</var>):</p>
<pre><code class="language-python">with open('files/квадраты.csv', 'w', newline='', encoding="utf8") as csvfile:
    writer = csv.writer(
        csvfile, delimiter=';', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    for i in range(10):
        writer.writerow([i, i ** 2, "Квадрат числа %d равен %d" % (i, i ** 2)])
</code></pre>
<p>В&nbsp;этом случае использовался опциональный параметр функции <code>open() newline</code>. Он&nbsp;отвечает за&nbsp;переводы строк при чтении или записи в&nbsp;текстовый файл. По&nbsp;умолчанию имеет значение None, в&nbsp;этом случае все разделители строк преобразуются в <code>\n</code>. Если в&nbsp;файле оказывается лишний перевод строки, то&nbsp;следует использовать этот параметр в&nbsp;режиме <code>newline=''</code>, тогда <code>\n</code> будет преобразован в&nbsp;пустую строку.</p>
<p>Выполните этот код и&nbsp;посмотрите, что получилось.</p>
<p>Записывать в&nbsp;csv-файл можно и&nbsp;с&nbsp;помощью <var>DictWriter</var>, аналогичного <var>DictReader</var>. Но&nbsp;нужно ему указать, какие заголовки должны быть в&nbsp;файле и&nbsp;какие значения им&nbsp;соответствуют у&nbsp;каждой записи. Для этого сначала подготовим список словарей:</p>
<pre><code class="language-python">import csv

data = [{
    'lastname': 'Иванов',
    'firstname': 'Пётр',
    'class_number': 9,
    'class_letter': 'А'
}, {
    'lastname': 'Кузнецов',
    'firstname': 'Алексей',
    'class_number': 9,
    'class_letter': 'В'
}, {
    'lastname': 'Меньшова',
    'firstname': 'Алиса',
    'class_number': 9,
    'class_letter': 'А'
}, {
    'lastname': 'Иванова',
    'firstname': 'Татьяна',
    'class_number': 9,
    'class_letter': 'Б'
}]

with open('dictwriter.csv', 'w', newline='', encoding="utf8") as f:
    writer = csv.DictWriter(
        f, fieldnames=list(data[0].keys()),
        delimiter=';', quoting=csv.QUOTE_NONNUMERIC)
    writer.writeheader()
    for d in data:
        writer.writerow(d)
</code></pre>
<p>Результат:</p>
<pre><samp>"lastname";"firstname";"class_number";"class_letter"
"Иванов";"Пётр";9;"А"
"Кузнецов";"Алексей";9;"В"
"Меньшова";"Алиса";9;"А"
"Иванова";"Татьяна";9;"Б"</samp></pre>
<p>Скачать файл ikea.csv можно по&nbsp;<a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/ikea.csv" target="_blank" rel="noopener noreferrer">ссылке</a>.</p>
</section>
<section class="material__chapter">
<h2 id="7">Использование графического интерфейса. Чтение из .csv файла</h2>
<p>Поскольку большинство программ используются людьми без опыта работы в&nbsp;командной строке, в&nbsp;пакетах, отвечающих за&nbsp;создание графического интерфейса, существуют специальные модули для работы с&nbsp;табличными данными. Для работы с&nbsp;таблицами в&nbsp;PyQT существует класс <strong>Table Widget</strong>. Давайте рассмотрим несколько примеров его использования.</p>
<p>Создадим простое приложение, которое будет отображать содержимое таблицы, которая хранится в&nbsp;формате .csv.</p>
<p>Для этого создадим в&nbsp;QtDesigner новую форму, добавим на&nbsp;нее <strong>Table Widget</strong>, а&nbsp;затем подключим интерфейс к&nbsp;нашей программе (в&nbsp;виде ui-файла или конвертируем полученный GUI в&nbsp;файл с&nbsp;расширением .py).</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/qt-res-5-1.png" width="392" height="auto" /></div>
<pre><code class="language-python">import csv
import sys

from PyQt5 import uic
from PyQt5.QtWidgets import QApplication
from PyQt5.QtWidgets import QMainWindow, QTableWidgetItem


class MyWidget(QMainWindow):
    def __init__(self):
        super().__init__()
        uic.loadUi('UI1.ui', self)
        self.loadTable('Data.csv')

    def loadTable(self, table_name):
        with open(table_name, encoding="utf8") as csvfile:
            reader = csv.reader(csvfile, delimiter=',', quotechar='"')
            title = next(reader)
            self.tableWidget.setColumnCount(len(title))
            self.tableWidget.setHorizontalHeaderLabels(title)
            self.tableWidget.setRowCount(0)
            for i, row in enumerate(reader):
                self.tableWidget.setRowCount(
                    self.tableWidget.rowCount() + 1)
                for j, elem in enumerate(row):
                    self.tableWidget.setItem(
                        i, j, QTableWidgetItem(elem))
        self.tableWidget.resizeColumnsToContents()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = MyWidget()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>В&nbsp;методе <var>loadTable()</var> класса <var>MyWidget</var> происходит загрузка содержимого в&nbsp;виджет таблицы. Давайте посмотрим более детально.</p>
<p>Для отображения таблицы необходимо указать ее&nbsp;размеры: количество строк и&nbsp;столбцов. Если&nbsp;бы у&nbsp;нас была фиксированная матрица, мы&nbsp;бы легко узнали ее&nbsp;размеры, но&nbsp;в&nbsp;случае работы с .csv мы&nbsp;используем итератор, поэтому необходимо применить некоторые &laquo;лайфхаки&raquo;.</p>
<p>Сначала, так&nbsp;же, как и&nbsp;в&nbsp;прошлых примерах, мы&nbsp;открываем файл для чтения. Поскольку <var>reader</var> является итератором, то, для того чтобы получить первую строку, необходимо воспользоваться функцией <code>next()</code>.</p>
<p>Чтобы отобразить заголовки в&nbsp;виджете, воспользуемся методом <var>setHorizontalHeaderLabels()</var>. Кстати, существует также функция <var>setVerticalHeaderLabels()</var>&nbsp;&mdash; для задания вертикальных заголовков. По&nbsp;умолчанию, если программист не&nbsp;задает текст заголовков, это просто номера. Если в&nbsp;функцию передано недостаточное количество заголовков, после того как они &laquo;закончатся&raquo;, следующие заголовки будут цифровыми. Например:</p>
<pre><code class="language-python">self.tableWidget.setVerticalHeaderLabels(['A', 'B', 'C', 'D'])
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/qt-res-5-2.png" width="392" height="auto" /></div>
<p>Зная количество заголовков, можно установить количество столбцов в&nbsp;нашей таблице, используя метод <var>setColumnCount()</var>. Но&nbsp;так как мы&nbsp;не&nbsp;знаем (если не&nbsp;преобразовали <var>reader</var> в&nbsp;список), сколько элементов в&nbsp;нашем итераторе, установим изначальное количество, равное&nbsp;0, а&nbsp;затем будем на&nbsp;каждом шаге увеличивать его на&nbsp;единицу.</p>
<p>Основным методом при работе с&nbsp;<var>QTableWidget</var> является <code>tableWidget.setItem(i, j, QTableWidgetItem(elem))</code>. Он помещает в&nbsp;заданную с&nbsp;помощью координат ячейку соответствующее значение. Важно не&nbsp;забыть, что в&nbsp;таблице хранятся не&nbsp;текстовые, не&nbsp;числовые и&nbsp;не&nbsp;какие-либо другие данные, а&nbsp;данные типа <var>QTableWidgetItem</var>, поэтому не&nbsp;забывайте приводить значения к&nbsp;этому типу.</p>
<p>Очень часто непонятно заранее, какого размера будет содержимое той или иной ячейки в&nbsp;таблице. Для того чтобы размеры ячеек соответствовали длине текста, используем метод <code>resizeColumnsToContents()</code> после того, как заполним таблицу данными. Он растянет или сузит, при необходимости, размеры ячейки, чтобы пользователю был виден весь текст.</p>
<p>Согласитесь, что сейчас таблица выглядит блекло и&nbsp;неинтересно. Давайте раскрасим&nbsp;ее. Для этого нам понадобится импортировать модуль, отвечающий за&nbsp;работу с&nbsp;цветом: <code>from PyQt5.QtGui import QColor</code>. К&nbsp;сожалению, по&nbsp;умолчанию в&nbsp;PyQT нет функции, чтобы изменить цвет целого ряда таблицы, а&nbsp;есть только для одной ячейки. Так что придется написать такой метод самостоятельно.</p>
<pre><code class="language-python">def color_row(self, row, color):
    for i in range(self.tableWidget.columnCount()):
        self.tableWidget.item(row, i).setBackground(color)
</code></pre>
<p>И&nbsp;теперь, если мы&nbsp;захотим выделить нулевой ряд цветом, нам достаточно лишь вызвать этот метод:</p>
<pre><code class="language-python">self.color_row(0, QColor(0, 150,  100))
</code></pre>
<p>Получим такой результат:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/qt-res-5-3.png" width="392" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="8">PyQT. Запись из&nbsp;таблицы в .csv файл</h2>
<p>Мы&nbsp;уже научились читать данные из&nbsp;файла и&nbsp;отображать их&nbsp;с&nbsp;помощью таблицы. Теперь попробуем обратный процесс. Для этого напишем программу, которая может использоваться при выставлении баллов команде за&nbsp;различные этапы на&nbsp;каком-нибудь соревновании. Известно, что и&nbsp;команд, и&nbsp;испытаний фиксированное число. Так что можно создать сетку для нашей таблицы, используя QtDesigner. Для этого необходимо навести курсор на&nbsp;виджет, нажать правую кнопку мыши, выбрать пункт меню <strong>Edit Items...</strong>, а&nbsp;затем указать данные.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/qt-res-5-4.png" width="488" height="auto" /></div>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/qt-res-5-5.png" width="445" height="auto" /></div>
<p>Для сохранения данных напишем метод <var>save_2_csv</var>:</p>
<pre><code class="language-python">def save_2_csv(self):
    with open('results.csv', 'w', newline='') as csvfile:
        writer = csv.writer(
            csvfile, delimiter=';', quotechar='"',
            quoting=csv.QUOTE_MINIMAL)
        # Получение списка заголовков    
        writer.writerow(
            [self.tableWidget.horizontalHeaderItem(i).text()
             for i in range(self.tableWidget.columnCount())])
        for i in range(self.tableWidget.rowCount()):
            row = []
            for j in range(self.tableWidget.columnCount()):
                item = self.tableWidget.item(i, j)
                if item is not None:
                    row.append(item.text())
            writer.writerow(row)
</code></pre>
<p>К&nbsp;сожалению, в&nbsp;PyQT нет встроенной функции, которая возвращает список заголовков, так что пришлось использовать генератор и&nbsp;встроенный метод <code>horizontalHeaderItem(i)</code>, который возвращает <var>i</var>-й заголовок. А&nbsp;затем каждая строка переносится в&nbsp;список, а&nbsp;этот список уже записывается в&nbsp;файл.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-5/qt-res-5-6.png" width="443" height="auto" /></div>
<p>Результатом будет такой .csv-файлик:</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse;" border="1" cellpadding="5px">
<tbody>
<tr>
<td>Название</td>
<td>Испытание №1</td>
<td>Испытание №2</td>
<td>Испытание №3</td>
</tr>
<tr>
<td>Альтаир</td>
<td>5</td>
<td>8</td>
<td>7</td>
</tr>
<tr>
<td>Бригантина</td>
<td>5</td>
<td>3</td>
<td>9</td>
</tr>
<tr>
<td>Будильник</td>
<td>4</td>
<td>6</td>
<td>10</td>
</tr>
<tr>
<td>220 Вольт</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>Непоседы</td>
<td>5</td>
<td>10</td>
<td>6</td>
</tr>
<tr>
<td>Трубодуры</td>
<td>1</td>
<td>9</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>