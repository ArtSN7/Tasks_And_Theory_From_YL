<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Файлы в Python. Типы файлов и работа с ними. Внутреннее устройство файлов </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок QT Файлы</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Файлы в&nbsp;Python. Типы файлов и&nbsp;работа с&nbsp;ними. Внутреннее устройство файлов</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Общие сведения о&nbsp;файлах</a></li>
<li><a class="material__link" href="#2">Перевод строки</a></li>
<li><a class="material__link" href="#3">Файловый путь. Относительные и&nbsp;абсолютные пути</a></li>
<li><a class="material__link" href="#4">Кодировки файлов</a></li>
<li><a class="material__link" href="#5">Типичные операции с&nbsp;файлами</a></li>
<li><a class="material__link" href="#6">Чтение файла</a></li>
<li><a class="material__link" href="#7">Запись в&nbsp;файл</a></li>
<li><a class="material__link" href="#8">Закрытие файлов</a></li>
<li><a class="material__link" href="#9">PyQT</a></li>
<li><a class="material__link" href="#10">Важная информация о текстовых файлах.</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке даются общие сведения о&nbsp;файлах и&nbsp;их&nbsp;хранении в&nbsp;современных ОС. Затрагиваются наиболее общие аспекты работы с&nbsp;файлами в&nbsp;Python: открытие, чтение/запись, закрытие текстовых и&nbsp;бинарных файлов. Обзорно рассмотрены вспомогательные функции (&laquo;перемотка&raquo;, работа с&nbsp;кодировками, построчное чтение).</p>
</section>
<section class="material__chapter">
<h2 id="1">Общие сведения о&nbsp;файлах</h2>
<p>Для работы с&nbsp;блоками логически объединенной информации, их&nbsp;хранения, обработки и&nbsp;передачи широко используются файлы.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Файл</strong></p>
<p>Файл (англ. <em>file</em>) &mdash; именованная область данных на носителе информации.</p>
</section>
<p>Конкретная физическая организация файлов, их&nbsp;группировка по&nbsp;каталогам (папкам), устройство процедур доступа к&nbsp;информации, механизмы кеширования очень сильно зависят от&nbsp;операционной системы и&nbsp;применяемой в&nbsp;ней файловой системы. Как правило, при работе с&nbsp;файлами прикладные программисты работают на&nbsp;верхнем уровне <strong>абстракции</strong>.</p>
<p>Это означает, что файл представляет просто собой поток байт или текста заданного размера, а&nbsp;его реальное физическое устройство программиста абсолютно не&nbsp;интересует. Но&nbsp;грамотный программист должен хорошо представлять себе некоторые особенности работы с&nbsp;файлами, чтобы не&nbsp;совершать ошибки, связанные с&nbsp;оптимизацией и&nbsp;ускорением работы программы.</p>
<p>О&nbsp;чем надо всегда помнить:</p>
<ol>
<li>Файлы обычно располагаются на&nbsp;носителях, которые работают медленнее, чем оперативная память. Поэтому работа с&nbsp;ними идет в&nbsp;буферизированном режиме. Даже если вы&nbsp;запросите один байт из&nbsp;файла, то&nbsp;считается целый блок (до&nbsp;нескольких килобайт). Затем он&nbsp;переместится в&nbsp;буфер оперативной памяти. Дальше файл читается оттуда, поскольку это быстрее (даже если у&nbsp;вас SSD) и&nbsp;экономит ресурсы чтения/записи внешних носителей. Небольшой файл, к&nbsp;которому часто обращаются, можно (прозрачно для прикладных программ) полностью поместить в&nbsp;оперативную память. На&nbsp;самом жестком диске располагаются буферные зоны с&nbsp;более быстрым доступом&nbsp;&mdash; в&nbsp;общем случае мы&nbsp;имеем дело с&nbsp;многоуровневой буферизацией. Поэтому <strong>очень плохо</strong> считывать файл небольшими порциями коротких блоков (до&nbsp;нескольких мегабайт) якобы для уменьшения затрачиваемой памяти.</li>
<li>То, как файлы и&nbsp;каталоги (папки) располагаются на&nbsp;жестком диске, зависит от&nbsp;типа файловой системы. Она может поддерживать сжатие, шифрование, разграничение доступа к&nbsp;данным. Никогда файл, кроме совсем маленьких, не&nbsp;размещается полностью и&nbsp;подряд в&nbsp;определенной области диска. Он&nbsp;разбивается на&nbsp;блоки для рационального расходования места. У&nbsp;блоков есть минимальный размер. Поэтому, даже если вы&nbsp;создадите файл из&nbsp;одного байта, он&nbsp;все равно займет целый блок данных (например, 4 Кб).
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-3-1.png" width="550" height="auto" /></div>
</li>
<li>Вся работа по&nbsp;буферизации, чтению, записи, открытию, закрытию файла идет через операционную систему. Чаще всего прикладной программист не&nbsp;работает с&nbsp;файловой системой напрямую.</li>
<li>Во&nbsp;многих операционных системах понятие файла как некоторой области данных на&nbsp;носителе, поддерживающих операции чтения/записи, расширено до&nbsp;областей в&nbsp;оперативной памяти, ресурсов сети, оборудования и&nbsp;т.&nbsp;д. Эта концепция называется <strong>&laquo;все есть файл&raquo;</strong>. Например, в&nbsp;Python есть &laquo;файл&raquo; sys.stdin, который ассоциирован с&nbsp;клавиатурным вводом и&nbsp;не&nbsp;является классическим файлом.</li>
</ol>
<p>Есть некоторые различия в&nbsp;именовании файлов в&nbsp;unix-подобных ОС&nbsp;и&nbsp;Windows.</p>
<p>Например, в&nbsp;Linux системные файлы, как правило, не&nbsp;имеют расширения. Все устройства и&nbsp;диски добавлены в&nbsp;общее дерево, корень которого обозначается "/".</p>
<p>Для отделения имен папок используется прямой слеш "/", а&nbsp;не&nbsp;обратный, как в&nbsp;Windows.</p>
<p>Приведем примеры специальных &laquo;файлов&raquo; в&nbsp;ОС&nbsp;Linux:</p>
<ul>
<li>/dev/sd{буква}&nbsp;&mdash; жесткий диск (в&nbsp;системах на&nbsp;ядре Linux)</li>
<li>/dev/sd{буква}{номер}&nbsp;&mdash; раздел диска (в&nbsp;системах на&nbsp;ядре Linux)</li>
<li>/dev/sr{номер} или /dev/scd{номер}&nbsp;&mdash; CD-ROM</li>
<li>/dev/eth{номер}&nbsp;&mdash; сетевые интерфейсы Ethernet</li>
<li>/dev/wlan{номер}&nbsp;&mdash; сетевые интерфейсы Wireless</li>
<li>/dev/lp{номер}&nbsp;&mdash; принтеры</li>
<li>/dev/video{номер}&nbsp;&mdash; устройства изображений, камеры, фотоаппараты и&nbsp;т.&nbsp;д.</li>
<li>/dev/bus/usb/000/{номер}&nbsp;&mdash; устройство номер на&nbsp;шине USB первого контроллера (000) (в&nbsp;системах на&nbsp;ядре Linux)</li>
<li>/dev/tty{номер}&nbsp;&mdash; текстовый терминал</li>
<li>/dev/dsp&nbsp;&mdash; звуковой вывод</li>
<li>/dev/random&nbsp;&mdash; случайные данные (псевдоустройство)</li>
<li>/dev/null&nbsp;&mdash; пусто (псевдоустройство)</li>
<li>/dev/zero&nbsp;&mdash; нулевые байты (псевдоустройство)</li>
</ul>
<p><em>{номер}&nbsp;&mdash; это порядковый номер устройства</em></p>
</section>
<section class="material__chapter">
<h2 id="2">Перевод строки</h2>
<p>Существует два символа <code>\n</code> и <code>\r</code>, смысл которых взят из&nbsp;эпохи печатных машинок. Посмотрим, какие у&nbsp;них коды:</p>
<pre><code class="language-python"># LINE FEED. Перемещает позицию печати на одну строку вниз 
# (изначально &ndash; без возврата каретки машинки).
print(ord("\n"))
# CARRIAGE RETURN. Перемещает позицию печати в крайнее левое положение 
# (изначально &mdash; без перехода на следующую строку).
print(ord("\r"))
</code></pre>
<pre><samp>10
13</samp></pre>
<p>В&nbsp;ОС&nbsp;Windows для перевода строки принимается последовательность <code>\r\n</code>, в&nbsp;MacOS (до&nbsp;версии X)&nbsp;&mdash; <code>\r</code>, а&nbsp;в&nbsp;Linux&nbsp;&mdash; <code>\n</code>.</p>
<p>Сейчас все чаще во&nbsp;всех&nbsp;ОС используется одиночный <code>\n</code>.</p>
<p>Поэтому программисту надо быть внимательным и&nbsp;помнить все варианты перевода строки на&nbsp;той&nbsp;ОС, где будет работать его программа.</p>
</section>
<section class="material__chapter">
<h2 id="3">Файловый путь. Относительные и&nbsp;абсолютные пути</h2>
<p>Путь файла (или путь к&nbsp;файлу)&nbsp;&mdash; последовательное указание имен каталогов, через которые надо пройти, чтобы добраться до&nbsp;объекта. Каталоги в&nbsp;записи пути разделяются <strong>слешем</strong>. В&nbsp;зависимости от&nbsp;вида&nbsp;ОС слеши могут быть как прямыми, так и&nbsp;обратными.</p>
<p>На&nbsp;ОС&nbsp;Windows путь выглядит так:</p>
<pre><code class="language-python">f = open('C:\\users\\user\\1.txt')
</code></pre>
<p>Обратный слеш удваивается как служебный символ. Значит, если он&nbsp;нужен сам по&nbsp;себе, его нужно &laquo;экранировать&raquo;. Вспомните, что в&nbsp;языке Python есть служебные символы (<code>\n</code>, <code>\t</code>).</p>
<p>Для того чтобы сделать работу с&nbsp;файлами универсальнее, в&nbsp;путях файлов в&nbsp;Windows в&nbsp;python-программах рекомендуется ставить прямой слеш. В&nbsp;наших примерах мы&nbsp;так и&nbsp;будем делать.</p>
<pre><code class="language-python">f = open('C:/users/user/1.txt')
</code></pre>
<p>Если мы&nbsp;укажем относительные пути, например:</p>
<pre><code class="language-python">f = open("user/1.txt")
</code></pre>
или
<pre><code class="language-python">f = open("./user/1.txt")
</code></pre>
<p>то&nbsp;Python будет искать файл в&nbsp;каталоге, начав отсчет с&nbsp;папки, в&nbsp;которой находится файл с&nbsp;основной python-программой. Это важно помнить в&nbsp;проектах, где много файлов и&nbsp;происходит импорт модулей или функций.</p>
В относительных путях используют обозначения <code class="language-python">"./"</code> для обозначения текущего каталога и <code class="language-python">"../"</code> для обозначения родительского каталога или каталога на один уровень выше по отношению к текущему.
<pre><code class="language-python">f = open("../user/1.txt")</code></pre>
<p>Здесь Python будет искать файл в&nbsp;каталоге, начав отсчет с&nbsp;папки, в&nbsp;которой находится файл с&nbsp;основной python-программой, затем поднимется на уровень выше, будет искать там папку <code class="language-python">"user"</code>, а уже в ней файл <code class="language-python">"1.txt"</code></p>
</section>
<section class="material__chapter">
<h2 id="4">Кодировки файлов</h2>
<p>Сейчас принято использовать одну из&nbsp;самых распространенных кодировок&nbsp;&mdash; <strong>UTF-8</strong>. Мы&nbsp;поступим так&nbsp;же.</p>
<p>UTF-8&nbsp;&mdash; сложная кодировка, в&nbsp;которой символ кодируется от&nbsp;одного до&nbsp;шестью байтами. Подробнее про эту кодировку можно почитать <a class="material__link" href="https://ru.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener noreferrer">здесь</a>.</p>
<p>Но&nbsp;помните, что до&nbsp;сих пор существуют и&nbsp;старые однобайтовые кодировки:</p>
<ul>
<li><a class="material__link" href="https://ru.wikipedia.org/wiki/Windows-1251" target="_blank" rel="noopener noreferrer">Windows-1251</a>;</li>
<li><a class="material__link" href="https://ru.wikipedia.org/wiki/CP866" target="_blank" rel="noopener noreferrer">cp-866</a>;</li>
<li><a class="material__link" href="https://ru.wikipedia.org/wiki/КОИ-8" target="_blank" rel="noopener noreferrer">КОИ-8</a>.</li>
</ul>
<p>Они по&nbsp;умолчанию используются в&nbsp;некоторых&nbsp;ОС, например, в&nbsp;Windows.</p>
<p>У&nbsp;пользователей, работающих на&nbsp;компьютерах под управлением ОС&nbsp;Windows, могут возникнуть проблемы с&nbsp;созданием текстовых файлов в&nbsp;кодировке UTF-8. Это происходит из-за того, что ОС&nbsp;Windows до&nbsp;сих по&nbsp;умолчанию использует однобайтовую кодировку Windows-1251. В&nbsp;редакторе Notepad (&laquo;Блокнот&raquo;) можно при сохранении указывать ту&nbsp;кодировку, в&nbsp;которой на&nbsp;самом деле хочется сохранить файл, однако все об&nbsp;этом забывают.</p>
<p>Вообще, текстовые файлы стоит открывать в&nbsp;самой IDE PyCharm, что проще всего. При этом нужно помнить, что IDE не&nbsp;добавляет расширение файла автоматически, его нужно указывать явно или выбирать тип из&nbsp;предложенного списка. В&nbsp;этом случае не&nbsp;будет проблем с&nbsp;кодировками. Также можно использовать сторонний текстовый редактор, например, Sublime.</p>
<p>При работе с&nbsp;ОС&nbsp;Linux и&nbsp;MacOS таких проблем не&nbsp;возникает вовсе, поскольку в&nbsp;них кодировка UTF-8 применяется по&nbsp;умолчанию.</p>
<p>Есть еще один вариант, как решить проблему с&nbsp;кодировкой в&nbsp;коде. Надо в&nbsp;первой строке программы написать</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
</code></pre>
<p>Это даст интерпретатору указание, что дальнейший код надо воспринимать именно в&nbsp;этой кодировке.</p>
</section>
<section class="material__chapter">
<h2 id="5">Типичные операции с&nbsp;файлами</h2>
<p>Все файлы на&nbsp;диске&nbsp;&mdash; последовательность байт. Операционной системе все равно, какой смысл у&nbsp;содержимого файла: это видео, чертеж, картинка, текстовый документ и&nbsp;т.&nbsp;д. Все это остается в&nbsp;компетенции прикладной программы.</p>
<p>Единственное исключение сделано для текстовых файлов, потому что их&nbsp;состав максимально прост (до&nbsp;внедрения Юникода одному символу соответствовал 1&nbsp;байт). Поэтому если программа знает, что файл текстовый, то&nbsp;сразу читает из&nbsp;файла символы, а&nbsp;не&nbsp;поток байт.</p>
<p>Таким образом, все файлы искусственно разделены на&nbsp;<strong>текстовые</strong> и&nbsp;<strong>бинарные</strong>. Но&nbsp;не&nbsp;забывайте, что любой текстовый файл является бинарным.</p>
<p>Так как общение с&nbsp;файлами идет не&nbsp;напрямую, а&nbsp;через&nbsp;OC, общепринятая последовательность операций с&nbsp;файлом следующая:</p>
<ol>
<li>Попросить ОС&nbsp;открыть файл в&nbsp;различных режимах для чтения или записи, в&nbsp;бинарном или текстовом режиме.</li>
<li>Поработать с&nbsp;информацией из&nbsp;файла, используя в&nbsp;том числе операции чтения/записи.</li>
<li>Закрыть файл.</li>
</ol>
<p>После успешного завершения python-программы все файлы закрываются автоматически. Но&nbsp;важно все равно закрывать файл, как только он&nbsp;перестает быть вам нужным. Это поможет избежать конфликтов совместного доступа или риска получить неконсистентный (испорченный) файл, если программа завершится аварийно.</p>
</section>
<section class="material__chapter">
<h2 id="6">Чтение файла</h2>
<p>Возьмем файл с&nbsp;<a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/Толстой.txt" target="_blank" rel="noopener noreferrer">первым томом</a> &laquo;Войны и&nbsp;мира&raquo; Льва Толстого.</p>
<p>Для открытия файлов в&nbsp;Python есть функция <code>open()</code>.</p>
<p>Выполним <code>help(open)</code> для получения справки по&nbsp;этой функции.</p>
<pre><code class="language-python">help(open)
</code></pre>
<pre><samp>Help on built-in function open in module io:
    
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
    Open file and return a stream.  Raise IOError upon failure.
        
    file is either a text or byte string giving the name (and the path
    if the file isn't in the current working directory) of the file to
    be opened or an integer file descriptor of the file to be
    wrapped. (If a file descriptor is given, it is closed when the
    returned I/O object is closed, unless closefd is set to False.)
        
...</samp></pre>
<p>Из&nbsp;всех параметров мы&nbsp;используем следующие:</p>
<ul>
<li><var>file</var>&nbsp;&mdash; имя открываемого файла. Оно может быть задано с&nbsp;использованием и&nbsp;относительных и&nbsp;абсолютных путей</li>
<li><var>mode</var>&nbsp;&mdash; режим открытия.&nbsp;<var>r</var>&nbsp;(или&nbsp;<var>rt</var>)&nbsp;&mdash; чтение в&nbsp;текстовом режиме, <var>rb</var>&nbsp;&mdash; чтение в&nbsp;бинарном режиме, <var>w</var>&nbsp;&mdash; запись, <var>wb</var>&nbsp;&mdash; запись в&nbsp;бинарном режиме. По&nbsp;умолчанию файл открывается в&nbsp;режиме&nbsp;<var>r</var></li>
<li><var>encoding</var>&nbsp;&mdash; если работа идет в&nbsp;текстовом режиме, Python должен получить имя кодировки, чтобы корректно работать с&nbsp;данными. Независимо от&nbsp;кодировки файла, в&nbsp;результате чтения будет возвращаться стандартная юникод-строка Python</li>
</ul>
<p>Пожалуйста, прочтите полное описание параметров в&nbsp;<a class="material__link" href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener noreferrer">документации</a> по&nbsp;функции <var>open</var>.</p>
<p>Теперь откроем файл в&nbsp;бинарном режиме и&nbsp;прочитаем первые 20&nbsp;байт:</p>
<pre><code class="language-python">f = open("files/Толстой.txt", mode="rb")
print(f.read(20))
f.close()
</code></pre>
<pre><samp>b'               -- \xd0\x95'</samp></pre>
<p>Перед строкой стоит модификатор&nbsp;<var>b</var>. Он&nbsp;говорит о&nbsp;том, что перед нами поток байт. Поток байт в&nbsp;языке Python представляется классом <var>bytes</var>. Если вы&nbsp;открываете файл для чтения в&nbsp;бинарном режиме, результат метода <code>read()</code> имеет тип <var>bytes</var>.</p>
<pre><code class="language-python">f = open("files/Толстой.txt", mode="rb")
data = f.read()
print(type(data))
print(data[19])
f.close()
</code></pre>
<pre><samp>&lt;class 'bytes'&gt;
149</samp></pre>
<p>Еще раз обратите внимание на&nbsp;то, что в&nbsp;путях до&nbsp;файла используются прямые слеши (/). Можно использовать и&nbsp;обратные, но&nbsp;тогда их&nbsp;придется экранировать либо применять модификатор строки&nbsp;<var>r</var>. Кроме того, в&nbsp;unix-подобных ОС&nbsp;принято использовать именно прямой слеш.</p>
<p>Чтобы понять, что делает модификатор&nbsp;<var>r</var>, рассмотрим пример:</p>
<pre><code class="language-python">print("ab\n12")
print(r"ab\n12")
</code></pre>
<pre><samp>ab
12
ab\n12</samp></pre>
<p>В&nbsp;первом случае специальный символ <code>\n</code> &laquo;отработал&raquo; и&nbsp;перевел строку, а&nbsp;во&nbsp;втором&nbsp;&mdash; вывелся на&nbsp;экран как есть. Модификатор <var>r</var>&nbsp;отключает спецсимволы, если он&nbsp;указан перед строкой. То&nbsp;есть каждый символ означает сам себя и&nbsp;&mdash; ничего более.</p>
<p>Объект, который возвращает нам функция <var>open</var>, ассоциирован (связан) с&nbsp;открытым файлом и&nbsp;содержит следующие поля и&nbsp;методы:</p>
<pre><code class="language-python">from pprint import pprint
f = open("files/Толстой.txt", mode="rb")
pprint(dir(f))
f.close()
</code></pre>
<pre><samp>['__class__',
 '__del__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__enter__',
 '__eq__',
 '__exit__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__getstate__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__iter__',
 '__le__',
 '__lt__',
 '__ne__',
 '__new__',
 '__next__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '_checkClosed',
 '_checkReadable',
 '_checkSeekable',
 '_checkWritable',
 '_dealloc_warn',
 '_finalizing',
 'close',
 'closed',
 'detach',
 'fileno',
 'flush',
 'isatty',
 'mode',
 'name',
 'peek',
 'raw',
 'read',
 'read1',
 'readable',
 'readinto',
 'readinto1',
 'readline',
 'readlines',
 'seek',
 'seekable',
 'tell',
 'truncate',
 'writable',
 'write',
 'writelines']</samp></pre>
<p>Напоминаем, что функция <var>pprint</var> (pretty-print, &laquo;изящный вывод&raquo;) старается сделать печать больших объектов (списков, словарей) более удобной и&nbsp;читаемой для человека.</p>
<p>Назначение почти всех из&nbsp;них легко определяется из&nbsp;названий.</p>
<pre><code class="language-python">f = open("files/Толстой.txt", mode="rb")
f.read(20)
print(f.name)
print(f.readable())
print(f.tell())
print(f.writable())
print(f.seekable())
print(f.mode)
f.close()
</code></pre>
<pre><samp>files/Толстой.txt
True
20
False
True
rb</samp></pre>
<p>Теперь откроем файл в&nbsp;текстовом режиме и&nbsp;проверим работу некоторых методов:</p>
<pre><code class="language-python">f = open("files/Толстой.txt", encoding="utf-8")
print(f.read(100))
print(f.tell())
print(f.seek(1245))
print(f.read(100))
print(f.tell())
f.close()
</code></pre>
<pre><samp>               -- Еh bien, mon prince. G&ecirc;nes et Lucques ne sont plus que des apanages,
            des
103
1245
ла (грипп  был тогда  новое
          слово, употреблявшееся только  редкими).  В записочках, разосл
1416</samp></pre>
<p>Что&nbsp;же произошло:</p>
<ul>
<li>Если мы&nbsp;открываем файл в&nbsp;текстовом режиме, чтение происходит посимвольно (символ может занимать физически 1, 2, 4&nbsp;и&nbsp;даже 6&nbsp;байт в&nbsp;некоторых случаях в&nbsp;зависимости от&nbsp;кодировки). За&nbsp;одну операцию можно прочитать различное количество символов</li>
<li>Если мы&nbsp;используем бинарный режим, чтение осуществляется побайтно и&nbsp;за&nbsp;одну операцию можно прочитать сразу несколько байт</li>
<li>Метод <var>tell</var> возвращает позицию в&nbsp;байтах от&nbsp;начала файла, а&nbsp;метод <var>seek</var> изменяет&nbsp;ее (перематывает) на&nbsp;заданную позицию. Использование <var>seek</var> с&nbsp;текстовыми файлами затруднено из-за несоответствия номера байта и&nbsp;номера символа (это видно в&nbsp;предыдущем примере, когда мы&nbsp;считали 100&nbsp;символов, а&nbsp;<var>tell</var> вернул нам смещение 103)</li>
</ul>
<p>Продолжим экспериментировать:</p>
<pre><code class="language-python">print(f.seek(1246))
print(f.read(1))
</code></pre>
<pre><samp>Traceback (most recent call last):
  File "/home/03.py", line 8, in &lt;module&gt;
    print(f.read(1))
  File "/usr/lib/python3.9/codecs.py", line 322, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xbb in position 0: invalid start byte</samp></pre>
<p>Исключение появилось потому, что начиная с&nbsp;1246-го байта невозможно прочитать символ в&nbsp;кодировке UTF-8.</p>
<p>Из-за буферизации и&nbsp;оптимизации количества операций чтения/записи иногда получается считать вообще весь файл в&nbsp;оперативную память (для этого не&nbsp;надо указывать параметр в&nbsp;методе <var>read</var>). Если его размер до&nbsp;десятков мегабайт, это можно комфортно делать. В&nbsp;результате мы&nbsp;получим одну строку со&nbsp;всем содержимым файла.</p>
<pre><code class="language-python">f = open("files/Толстой.txt", encoding="utf8")
data = f.read()
print(f'Type: {type(data)}, length: {len(data)}')
f.close()
</code></pre>
<pre><samp>Type: &lt;class 'str'&gt;, length: 887312</samp></pre>
<p>В&nbsp;текстовом режиме можно читать файл построчно с&nbsp;использованием метода <var>readline</var>, при этом маркером конца строки является символ <code>\n</code>:</p>
<pre><code class="language-python">f = open("files/Толстой.txt", encoding="utf8")
for i in range(7):
    print(f.readline(), end="")
f.close()
</code></pre>
<pre><samp>   -- Еh bien, mon prince. G&ecirc;nes et Lucques ne sont plus que des apanages,
des поместья, de la famille Buonaparte.  Non, je  vous pr&eacute;viens, que si vous
ne  me dites pas, que nous avons la guerre, si vous vous permettez encore de
pallier  toutes les infamies, toutes les  atrocit&eacute;s  de cet  Antichrist  (ma
parole, j'y  crois) -- je  ne  vous  connais plus, vous n'&ecirc;tes plus mon ami,
vous n'&ecirc;tes  plus  мой  верный  раб,  comme  vous  dites.  [1]  Ну,
здравствуйте, здравствуйте.  Je vois  que  je  vous fais  peur, [2]</samp></pre>
<p>Также можно считать текстовый файл в&nbsp;список строк с&nbsp;помощью метода <var>readlines</var>:</p>
<pre><code class="language-python">f = open("files/Толстой.txt", encoding="utf8")
lines = f.readlines()
print('Type: %s, length: %d' % (type(lines), len(lines)))
print(lines[10])
f.close()
</code></pre>
<pre><samp>Type: &lt;class 'list'&gt;, length: 12128
    князя  Василия,  первого  приехавшего  на  её вечер. Анна  Павловна  кашляла</samp></pre>
<p>Файл может быть построчным итератором (выведем только 10&nbsp;строк):</p>
<pre><code class="language-python">f = open("files/Толстой.txt", encoding="utf8")
for number, line in enumerate(f):
    print(line)
    if number &gt; 8:
        break
f.close()
</code></pre>
<pre><samp>    -- Еh bien, mon prince. G&ecirc;nes et Lucques ne sont plus que des apanages,
 
des поместья, de la famille Buonaparte.  Non, je  vous pr&eacute;viens, que si vous
 
ne  me dites pas, que nous avons la guerre, si vous vous permettez encore de
 
pallier  toutes les infamies, toutes les  atrocit&eacute;s  de cet  Antichrist  (ma
 
parole, j'y  crois) -- je  ne  vous  connais plus, vous n'&ecirc;tes plus mon ami,
 
vous n'&ecirc;tes  plus  мой  верный  раб,  comme  vous  dites.  [1]  Ну,
 
здравствуйте, здравствуйте.  Je vois  que  je  vous fais  peur, [2]
 
садитесь и рассказывайте.
 
       Так говорила в июле 1805 года известная Анна Павловна Шерер, фрейлина и
 
приближенная  императрицы  Марии  Феодоровны,  встречая важного и  чиновного</samp></pre>
</section>
<section class="material__chapter">
<h2 id="7">Запись в&nbsp;файл</h2>
<p>Для записи в&nbsp;файл также есть два режима: <var>w</var>&nbsp;(если файл существовал, его содержимое будет потеряно) и&nbsp;<var>a</var>&nbsp;&mdash; запись идет в&nbsp;конец файла.</p>
<p>После выбора режима можно также ввести и&nbsp;символ "+". Посмотрите в&nbsp;документации по&nbsp;функции <var>open</var>, что означает такая конструкция.</p>
<p>Один из&nbsp;способов записать информацию в&nbsp;файл&nbsp;&mdash; метод <var>write</var>. Если мы&nbsp;хотим сделать запись в&nbsp;середину файла, должны сначала спозиционироваться на&nbsp;место предполагаемой записи (метод <var>seek</var>), а&nbsp;уже потом записывать (метод <var>write</var>). Метод <var>write</var> возвращает количество записанных символов.</p>
<pre><code class="language-python">f = open("files/example.txt", 'w')
print(f.write('123\n456'))
print(f.seek(3))
print(f.write('34352'))
f.close()
f = open("files/example.txt", 'r')
print(f.read())
f.close()
</code></pre>
<pre><samp>7
3
5
12334352</samp></pre>
<p>Построчно пройдитесь по&nbsp;приведенной программе, чтобы лучше понять, как она работает. Заметьте, что если мы&nbsp;используем <var>seek</var>, то&nbsp;данные при записи все равно будут стерты. Этот процесс похож на&nbsp;рисование фломастером: рисуя поверх, вы&nbsp;закрашиваете старый рисунок.</p>
<p>Второй способ записи в&nbsp;файл&nbsp;&mdash; стандартная функция <var>print</var>. Для этого применяется именованный параметр <var>file</var>.</p>
<p>Например:</p>
<pre><code class="language-python">from math import sin

f = open("files/example2.txt", 'w')
for i in range(10):
    print("%0.2f" % sin(i), file=f)
f.close()
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-res-3-1.png" width="300" height="auto" /></div>
<p>Для записи данных в&nbsp;бинарный файл в&nbsp;функцию <code>write()</code> надо передать переменную типа <var>bytes</var>. Например, так:</p>
<pre><code class="language-python">f = open("files/ex_bin.dt", 'wb')
data = [1, 2, 3, 4, 5]
f.write(bytes(data))
f.close()
</code></pre>
<p>Обратите внимание: в&nbsp;примере мы&nbsp;преобразовываем список в&nbsp;поток байт, чтобы потом записать его в&nbsp;файл.</p>
</section>
<section class="material__chapter">
<h2 id="8">Закрытие файлов</h2>
<p>Операционная система контролирует доступ к&nbsp;файлам. Если какая-то программа открыла файл для записи, все попытки любых других программ изменить содержание файла заблокируются для сохранения целостности.</p>
<p>Поэтому после того как работа с&nbsp;файлом закончена, файл надо <strong>отпустить</strong>, закрыв его методом <var>close</var>, что мы&nbsp;делали практически во&nbsp;всех примерах.</p>
<pre><code class="language-python">f.close()
</code></pre>
<p>Повторим, что после завершения программы все файлы, которая она использовала в&nbsp;своей работе, автоматически закроются. Но&nbsp;<strong>хороший стиль программирования</strong>&nbsp;&mdash; это как можно раньше закрыть файл.</p>
<section class="material__note">
<p>Поэтому всегда следуйте принципу: &laquo;Не&nbsp;нужен файл&nbsp;&mdash; отпусти его!&raquo;</p>
</section>
<p>И&nbsp;самое последнее: для того чтобы файл закрывался автоматически даже в&nbsp;случае ошибок во&nbsp;время выполнения других операций, в&nbsp;языке Python есть блок <var>with</var>. Его назначение шире, но&nbsp;в&nbsp;нашем случае он&nbsp;дает закрыть файл после выхода из&nbsp;блока.</p>
<p>Его синтаксис такой:</p>
<pre><code class="language-python">with open('files/Толстой.txt', 'rt') as f:
    read_data = f.read()
print(read_data[:100])
print(f.closed)
</code></pre>
<pre><samp>        -- Еh bien, mon prince. G&ecirc;nes et Lucques ne sont plus que des apanages,
    des
True</samp></pre>
</section>
<section class="material__chapter">
<h2 id="9">PyQT</h2>
<p>Одним из&nbsp;самых широко используемых виджетов в&nbsp;PyQT для отображения текстовой информации является <strong>QTextBrowser</strong>. Его возможности очень велики. Начнем с&nbsp;того, что создадим интерфейс приложения через QtDesigner и&nbsp;посмотрим на&nbsp;те&nbsp;свойства этого виджета, которые можно ему задать.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-res-3-2.png" width="616" height="auto" /></div>
<p>Кроме стандартных настроек самого виджета (размер виджета, его расположение и&nbsp;т.&nbsp;д.), есть группа настроек, отвечающих за&nbsp;шрифт.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-3-2.png" width="386" height="auto" /></div>
<p>Интересно, что для того чтобы отображать различный текст, используется язык разметки HTML,с которым вы&nbsp;должны были познакомиться летом. Так что можно вставить свой HTML-код для красивого оформления текста. Для этого в&nbsp;редакторе свойств нужно выбрать поле html, после чего откроется редактор, в&nbsp;котором можно верстать различные тексты. Как в&nbsp;привычном Word-подобном интерфейсе,</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-res-3-3.png" width="616" height="auto" /></div>
<p>так и&nbsp;используя просто HTML.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-res-3-4.png" width="616" height="auto" /></div>
<p>Этот виджет может использоваться не&nbsp;только для отображения информации, но&nbsp;и&nbsp;для ее&nbsp;ввода. Но, поскольку в&nbsp;данном уроке мы&nbsp;будем получать информацию из&nbsp;файлов, мы&nbsp;можем смело настроить режим <strong>readOnly</strong>. Это тоже можно сделать в&nbsp;редакторе свойств QtDesigner.</p>
<p>Теперь реализуем нашу первую программу. Интерфейс можно собрать самостоятельно в&nbsp;дизайнере (или создать в&nbsp;коде), а&nbsp;можно взять вот <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/pyqt/TextBrowserSample.ui" target="_blank" rel="noopener noreferrer">тут</a>. Она будет получать какую-то информацию из&nbsp;файла и&nbsp;выводить ее&nbsp;в&nbsp;обратном порядке.</p>
<p>Код вашего класса должен выглядеть примерно вот так:</p>
<pre><code class="language-python">class TextBrowserSample(QMainWindow):
    def __init__(self):
        super(TextBrowserSample, self).__init__()
        uic.loadUi('TextBrowserSample.ui', self)
        self.loadButton.clicked.connect(self.load_file)
        self.processButton.clicked.connect(self.process_data)

    def load_file(self):
        pass

    def process_data(self):
        pass
</code></pre>
<p>Для начала необходимо загрузить содержимое текста в&nbsp;наш виджет. Напишем для этого простейшую функцию:</p>
<pre><code class="language-python">def load_file(self):
    try:
        with open('input.txt', 'r',
                  encoding='utf8') as f:  
            # Если файла нет, то мы получим исключение FileNotFoundError
            self.inputText.setText(f.read())
    except FileNotFoundError as ex:
        self.statusBar().showMessage('В директории нет файла input.txt')
</code></pre>
<p>Метод <var>setText</var> позволяет загрузить переданный текст в&nbsp;виджет. Интересно, что, если размер текста превышает размеры виджета по&nbsp;вертикали или горизонтали, автоматически появляется слайдер, позволяющий прокручивать текст.</p>
<p>Дополнительно давайте обработаем случай, когда файла input.txt нет в&nbsp;директории с&nbsp;нашей программой: тогда при попытке получить доступ к&nbsp;файлу будет выброшено исключение FileNotFoundError. При получении такого исключения будем выводить в&nbsp;StatusBar соответствующее сообщение.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-res-3-5.png" width="603" height="auto" /></div>
<p>Теперь мы&nbsp;можем работать с&nbsp;содержимым виджета. Если мы&nbsp;хотим работать с&nbsp;ним как с&nbsp;обычным текстом, игнорируя HTML-теги и&nbsp;форматирование, можно воспользоваться методом <code>toPlainText()</code>.</p>
<pre><code class="language-python">def process_data(self):
    data = self.inputText.toPlainText()
    self.outputText.setText(data[::-1])
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-res-3-6.png" width="603" height="auto" /></div>
<p>Теперь давайте вспомним, что мы&nbsp;можем использовать различное оформление текста. Напишем программу, которая будет окрашивать каждую букву, полученную из&nbsp;файла, в&nbsp;случайный цвет и&nbsp;задавать ей&nbsp;случайный размер. Для этого мы&nbsp;будем использовать HTML-тег <code>&lt;font color="цвет"&gt;...&lt;/font&gt;</code>, а&nbsp;цвет&nbsp;&mdash; это случайное шестнадцатиричное число от&nbsp;0&nbsp;до&nbsp;0xFFFFFF.</p>
<p>Напишем другую функцию-слот для обработки нажатия на&nbsp;кнопку &laquo;Выполнить&raquo;:</p>
<pre><code class="language-python">def color_text(self):
    data = self.inputText.toPlainText()
    HTML = ""
    for i in data:
        color = "#{:06x}".format(random.randrange(0, 0xFFFFFF))
        HTML += "&lt;font color='{}' size = {} &gt;{}&lt;/font&gt;".format(
            color, random.randrange(1, 8), i)
    self.outputText.setHtml(HTML)
</code></pre>
<p>Как он&nbsp;работает? Сначала, как и&nbsp;в&nbsp;первом примере, содержимое текста заносится в&nbsp;переменную. Затем, используя модуль <var>random</var> (не&nbsp;забудьте его импортировать!), мы&nbsp;получаем случайное шестнадцатиричное число&nbsp;&mdash; наш цвет, а&nbsp;затем добавляем наш символ в&nbsp;&laquo;обрамлении&raquo; тега, отвечающего за&nbsp;цвет шрифта и&nbsp;его размер. Подробнее об&nbsp;HTML-тегах можно прочитать в&nbsp;Интернете, например, <a class="material__link" href="http://htmlbook.ru/" target="_blank" rel="noopener noreferrer">здесь</a>.</p>
<p>Ну&nbsp;и&nbsp;для того, чтобы занести форматированный с&nbsp;помощью HTML текст в&nbsp;виджет, понадобится метод <code>setHtml()</code>.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-3/qt-res-3-7.png" width="603" height="auto" /></div>
<p>В&nbsp;этом уроке мы&nbsp;работали с&nbsp;только с&nbsp;простыми текстовыми файлами, однако форматов гораздо больше. В&nbsp;следующих уроках мы&nbsp;поработаем и&nbsp;с&nbsp;другими популярными форматами.</p>
</section>
<section class="material__chapter">
<h2 id="10">Важная информация о текстовых файлах.</h2>
<p>Согласно <a class="material__link" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206" target="_blank" rel="noopener noreferrer">определению из стандарта POSIX</a>, который тоже пришёл к нам из эпохи печатных машинок:</p>
<section class="material__note">
<p class="material__note-heading"><strong>Строка</strong></p>
<p>Строка &mdash; это последовательность из нуля или более символов, не являющихся символом новой строки, и последнего символа новой строки.</p>
</section>
<p>Почему важен этот стандарт? Возможно большое количество способов реализовать одно и то же, и только благодаря стандартам, таким как POSIX, мы имеем сейчас огромное количество качественного программного обеспечения, которое не конфликтует друг с другом. <br />Т.е. если вы не ставите символ переноса строки в конце строки, то формально по стандарту такая строка не является валидной (правильной). Множество программ, которыми пользуются каждый день, написано в согласии с этим стандартом, и они просто не могут правильно обрабатывать такие "сломанные" строки. <br />Давайте, например, через Python создадим такой файл со сломанными строками:</p>
<pre><code class="language-python">with open("broken.txt", "w") as f:
    f.write("qwe\n")
    f.write("asd\n")
    f.write("zxc")
</code></pre>
<p>Сколько по-вашему в этом файле строк? Три? Давайте посмотрим, что об этом файле думает утилита <strong>wc</strong>, которая с флагом <strong>-l</strong> умеет считать количество строк в файле (утилита работает только в Linux/MacOS или gitBash):</p>
<pre><samp>$ wc -l broken.txt
2 broken.txt
    </samp></pre>
<p>Найдено только две строки! <br />Давайте создадим еще один файл:</p>
<pre><code class="language-python">with open("broken2.txt", "w") as f:
    f.write("rty\n")
    f.write("fgh\n")
    f.write("vbn")
        </code></pre>
<p>И попробуем теперь склеить два созданных файла при помощи утилиты <strong>cat</strong>:</p>
<pre><samp>$ cat broken.txt broken2.txt
qwe
asd
zxcrty
fgh
vbn
   </samp></pre>
<p>И опять какой-то странный результат! В большинстве случаев это не то, чего вы бы ожидали, но вполне возможны ситуации, когда вам нужен именно такой результат. Именно поэтому утилита cat не может самостоятельно вставлять отсутствующие символы переноса строки, иначе это сделало бы её поведение неодинаковым.</p>
<p>Возможно, такая маленькая деталь, как перенос строки в конце файла и не кажется очень важной, а тема вообще кажется спорной, но у нас нет другого выбора, кроме как принять это правило за данность и просто выработать привычку всегда ставить символ новой строки в любых текстовых файлах, даже если этого не требуется явно. Это считается распространённой хорошей практикой, и как минимум убережёт вас и ваших коллег от всяких неожиданных эффектов.</p>
<p>В текстовом редакторе это выглядит как лишняя пустая строка в конце файла.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>