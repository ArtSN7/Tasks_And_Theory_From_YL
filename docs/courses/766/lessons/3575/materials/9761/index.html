<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Алиса — урок 1 </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Алиса</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Алиса&nbsp;&mdash; урок&nbsp;1</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Алиса</a></li>
<li><a class="material__link" href="#2">Интеграция с&nbsp;Алисой</a></li>
<li><a class="material__link" href="#3">Логирование (журналирование)</a></li>
<li><a class="material__link" href="#4">Уровни логирования</a></li>
<li><a class="material__link" href="#5">Пишем код</a></li>
<li><a class="material__link" href="#6">Как работает данный код</a></li>
<li><a class="material__link" href="#7">Отладка с&nbsp;Postman</a></li>
<li><a class="material__link" href="#8">Регистрация и&nbsp;тестирование навыка</a></li>
<li><a class="material__link" href="#9">Именованные сущности</a></li>
<li><a class="material__link" href="#10">Ресурсы</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Мы&nbsp;начинаем блок по&nbsp;работе с&nbsp;голосовым помощником от&nbsp;Яндекса&nbsp;&mdash; Алисой.</p>
</section>
<section class="material__chapter">
<h2 id="1">Алиса</h2>
<p>Алиса&nbsp;&mdash; это голосовой помощник от&nbsp;Яндекса. Фактически, это робот, который умеет общаться с&nbsp;нами посредством компьютера или любого другого вычислительного устройства: мобильного телефона, часов, &laquo;умной колонки&raquo; и&nbsp;даже системы управления автомобилем. В&nbsp;процессе общения Алиса может отвечать на&nbsp;вопросы, искать информацию в&nbsp;Интернете, играть с&nbsp;нами в&nbsp;различные игры, торговать на&nbsp;бирже, информировать о&nbsp;погоде, распознавать образы, управлять компонентами &laquo;умного дома&raquo; и&nbsp;делать множество других вещей.</p>
<div class="material__content-positioner"><iframe src="https://www.youtube.com/embed/mpa39xiuhw4" width="560" height="315" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div>
<p><strong>Навыками</strong> принято называть отдельные задачи, которые Алиса умеет решать. Например, программист может научить Алису заказывать пиццу. Это умение и&nbsp;будет навыком. Сейчас различными разработчиками создано <a class="material__link" href="https://dialogs.yandex.ru/store/" target="_blank" rel="noopener noreferrer">большое количество навыков</a>, мы&nbsp;же с&nbsp;вами сегодня сделаем простой навык под названием &laquo;Купи слона&raquo;, в&nbsp;котором Алиса будет с&nbsp;нами играть в&nbsp;простую игру:</p>
<ul>
<li>Купи слона</li>
<li>Нет</li>
<li>Все говорят &laquo;Нет&raquo;. А&nbsp;ты&nbsp;купи слона</li>
<li>Хорошо</li>
<li>Слона можно найти на&nbsp;Яндекс.Маркете!</li>
</ul>
<p>И&nbsp;на&nbsp;этом все. Эта игра&nbsp;&mdash; пример, который приведен на&nbsp;официальном сайте платформы Яндекс.Диалоги&nbsp;&mdash; места, где любой человек может публиковать свои навыки для Алисы.</p>
<p>Но&nbsp;для начала работы узнаем несколько вещей о&nbsp;разработке навыков.</p>
</section>
<section class="material__chapter">
<h2 id="2">Интеграция с&nbsp;Алисой</h2>
<p>Первое, в&nbsp;чем нужно разобраться&nbsp;&mdash; как интегрироваться с&nbsp;Алисой. Алиса не&nbsp;имеет API в&nbsp;классическом понимании&nbsp;&mdash; как, например, у&nbsp;Яндекс.Карт. Интеграция происходит по&nbsp;технологии WebHook (технология&nbsp;&mdash; это громкое слово, скорее, идея).</p>
<p>Почему Алиса просто не&nbsp;могла предоставить нам API для работы? Как вы&nbsp;думаете, в&nbsp;чем сложность?</p>
<p>Алиса может обратиться к&nbsp;нашему навыку в&nbsp;любое время, поскольку никто не&nbsp;знает, когда один из&nbsp;миллионов пользователей Алисы решит им&nbsp;воспользоваться. Если&nbsp;бы Алиса предоставляла свое API, мы&nbsp;должны были&nbsp;бы регулярно ее&nbsp;спрашивать: &laquo;Эй, Алиса, никто не&nbsp;запрашивал наш навык?&raquo;, затем при положительном ответе: &laquo;Запрашивали? Вот мой ответ. А&nbsp;что там ответил пользователь?&raquo; и&nbsp;так далее.</p>
<p>Как&nbsp;же быть?</p>
<p>Оказывается, лучшим решением является такое, в&nbsp;котором Алиса сама сообщит нам обо всех событиях, которые нас касаются. Идея WebHook&rsquo;ов состоит в&nbsp;том, что мы&nbsp;не&nbsp;обращаемся к&nbsp;API, а&nbsp;реализуем свое, но&nbsp;по&nbsp;правилам, описанным в&nbsp;документации. Даем доступ к&nbsp;созданному API Алисе, и&nbsp;уже она начинает общаться с&nbsp;ним самостоятельно. Получается как&nbsp;бы &laquo;интеграция наоборот&raquo;. В&nbsp;документации Алисы есть строгие требования к&nbsp;нашему API. После того, как API реализован, мы&nbsp;&laquo;говорим&raquo; Алисе, куда обращаться: сообщаем наш адрес. Если в&nbsp;интерфейсе Алисы кто-то вызвал наш навык, то&nbsp;Алиса сама нам об&nbsp;этом сообщит. Очень удобно! Не&nbsp;надо постоянно &laquo;пинать&raquo; Алису.</p>
</section>
<section class="material__chapter">
<h2 id="3">Логирование (журналирование)</h2>
<p>Представьте ситуацию: вы&nbsp;не&nbsp;можете видеть на&nbsp;мониторе работу вашей программы. У&nbsp;вас просто может не&nbsp;быть монитора. Или программа размещена не&nbsp;на&nbsp;вашем компьютере, а&nbsp;где-то в&nbsp;облаке. И&nbsp;вы&nbsp;понимаете, что программа работает некорректно. Как&nbsp;же узнать, как она работает, и&nbsp;где вкралась ошибка? В&nbsp;таком случае помогает логирование.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Логирование</strong></p>
<p>Логирование&nbsp;&mdash; это запись и&nbsp;вывод информации о&nbsp;выполняемых операциях, ошибках и&nbsp;других событиях в&nbsp;коде. Это могут быть значения переменных или любой текст.</p>
</section>
<p>Логирование может происходить в&nbsp;консоль или файл. Логи выводятся в&nbsp;консоль, например, в&nbsp;процессе отладки приложения. Если вы&nbsp;уже написали программу, которая выполняется на&nbsp;сервере, то&nbsp;записывать логи желательно в&nbsp;файл, чтобы потом их&nbsp;можно было изучить в&nbsp;случае остановки, падения или перезагрузки сервера.</p>
<p>Для логирования в&nbsp;Python используется библиотека logging.</p>
<p>Пример:</p>
<pre><code class="language-python">import logging


def log():
    i = 0
    while i &lt; 10:
        logging.warning(i)
        i += 1


if __name__ == '__main__':
    log()
</code></pre>
<p>Выводит в&nbsp;консоль:</p>
<pre><samp>WARNING:root:0
WARNING:root:1
WARNING:root:2
WARNING:root:3
WARNING:root:4
WARNING:root:5
WARNING:root:6
WARNING:root:7
WARNING:root:8
WARNING:root:9</samp></pre>
<p>В&nbsp;этом примере мы&nbsp;используем библиотеку logging с&nbsp;параметрами по&nbsp;умолчанию, поэтому вся информация выводится в&nbsp;консоль. Мы&nbsp;использовали функцию <code>warning()</code>, которая предназначена для привлечения внимания к&nbsp;проблеме, которая еще не&nbsp;считается ошибкой. <var>root</var>&nbsp;&mdash; это имя журнала, его можно менять.</p>
<p>Давайте научимся сохранять данные журнала в&nbsp;файл. Еще раз напомним, что это&nbsp;&mdash; правильная практика, когда программа используется в&nbsp;боевом режиме (production), так как файл сохранится в&nbsp;случае остановки, падения или перезагрузки сервера.</p>
<p>Для логирования в&nbsp;файл нужно добавить в&nbsp;код следующую строку:</p>
<pre><code class="language-python">logging.basicConfig(filename='example.log')
</code></pre>
<p>Теперь код целиком выглядит так:</p>
<pre><code class="language-python">import logging

logging.basicConfig(filename='example.log')


def log_to_file():
    i = 0
    while i &lt; 10:
        logging.warning(i)
        i += 1


if __name__ == '__main__':
    log_to_file()
</code></pre>
<p>После того, как мы&nbsp;запустим программу, в&nbsp;папке программы создастся файл example.log, и&nbsp;в&nbsp;нем окажется та&nbsp;же информация, что ранее выводилась в&nbsp;консоль:</p>
<pre><samp>WARNING:root:0
WARNING:root:1
WARNING:root:2
WARNING:root:3
WARNING:root:4
WARNING:root:5
WARNING:root:6
WARNING:root:7
WARNING:root:8
WARNING:root:9</samp></pre>
<p>Если мы&nbsp;запустим программу повторно, то&nbsp;увидим, что старые данные из&nbsp;файла не&nbsp;удаляются. Таким образом, информация будет записана дважды.</p>
<p>Чего&nbsp;же не&nbsp;хватает в&nbsp;файле? Что еще нам важно знать? Правильно&nbsp;&mdash; время события, ведь без него никакого расследования не&nbsp;получится.</p>
<p>Для того чтобы вывести временную метку, надо в&nbsp;функцию <code>logging.basicConfig()</code> передать еще один параметр&nbsp;&mdash; <var>format</var>. Как несложно догадаться, это формат сообщения (как выглядит и&nbsp;что содержит), которое записывается в&nbsp;лог. Сообщение в&nbsp;логе может содержать много полезной информации (подробно можно изучить <a class="material__link" href="https://docs.python.org/3/library/logging.html#logrecord-attributes" target="_blank" rel="noopener noreferrer">тут</a>). Мы&nbsp;рассмотрим только четыре атрибута, которые можно вывести, и&nbsp;подробно расскажем о&nbsp;них.</p>
<p>С&nbsp;добавлением параметра <var>format</var> наш код будет выглядеть так:</p>
<pre><code class="language-python">import logging

logging.basicConfig(
    filename='example.log',
    format='%(asctime)s %(levelname)s %(name)s %(message)s'
)


def log_to_file():
    i = 0
    while i &lt; 10:
        logging.warning(i)
        i += 1


if __name__ == '__main__':
    log_to_file()
</code></pre>
<p>Рассмотрим параметр <code>format='%(asctime)s %(levelname)s %(name)s %(message)s'</code>.</p>
<p>Здесь:</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<tbody>
<tr>
<td><strong>asctime</strong></td>
<td>Время события</td>
</tr>
<tr>
<td><strong>levelname</strong></td>
<td>Уровень логирования (подробно об&nbsp;этом расскажем ниже)</td>
</tr>
<tr>
<td><strong>name</strong></td>
<td>Имя логера (журнала). По&nbsp;умолчанию&nbsp;&mdash; root, но&nbsp;вы&nbsp;можете задавать разные имена, чтобы сделать свои логи более информативными. Например, считается хорошей практикой назначать имя файла с&nbsp;кодом</td>
</tr>
<tr>
<td><strong>message</strong></td>
<td>Сообщение, которое вы&nbsp;отправили в&nbsp;<code>logging.warning()</code></td>
</tr>
</tbody>
</table>
</div>
<p>После запуска мы&nbsp;увидим в&nbsp;файле:</p>
<pre><samp>2018-12-23 21:08:58,805 WARNING root 0
2018-12-23 21:08:58,805 WARNING root 1
2018-12-23 21:08:58,805 WARNING root 2
2018-12-23 21:08:58,805 WARNING root 3
2018-12-23 21:08:58,805 WARNING root 4
2018-12-23 21:08:58,806 WARNING root 5
2018-12-23 21:08:58,806 WARNING root 6
2018-12-23 21:08:58,806 WARNING root 7
2018-12-23 21:08:58,806 WARNING root 8
2018-12-23 21:08:58,806 WARNING root 9</samp></pre>
</section>
<section class="material__chapter">
<h2 id="4">Уровни логирования</h2>
<p>Запись в&nbsp;логи принято разбирать на&nbsp;типы&nbsp;&mdash; уровни. Любое сообщение несет в&nbsp;себе информацию определенной важности, и&nbsp;время реакции на&nbsp;сообщения отличается. Приведем примеры:</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<tbody>
<tr>
<td><strong>Уровень</strong></td>
<td><strong>Пример события</strong></td>
</tr>
<tr>
<td><strong>Debug</strong></td>
<td>Отправлен запрос в&nbsp;базу данных на&nbsp;сохранение</td>
</tr>
<tr>
<td><strong>Debug</strong></td>
<td>Завершен запрос в&nbsp;базу данных на&nbsp;сохранение</td>
</tr>
<tr>
<td><strong>Debug</strong></td>
<td>Запрос в&nbsp;базу занял 0.02&nbsp;секунды, извлечено 1000 записей</td>
</tr>
<tr>
<td><strong>Info</strong></td>
<td>Зарегистрирован новый пользователь (user_id = 123123)</td>
</tr>
<tr>
<td><strong>Warning</strong></td>
<td>Отклонена транзакция с&nbsp;суммой платежа&nbsp;0</td>
</tr>
<tr>
<td><strong>Error</strong></td>
<td>Ошибка при сохранении данных пользователя (user_id = 123124, operation_id = 12312313)</td>
</tr>
<tr>
<td><strong>Critical (Fatal)</strong></td>
<td>Ошибка ответа API Яндекс Карт, код: 404. Маршруты не&nbsp;рассчитываются</td>
</tr>
</tbody>
</table>
</div>
<p>Начинающему программисту бывает сложно определить, к&nbsp;какому уровню следует отнести то&nbsp;или иное событие, возникающее при работе программы. Мы&nbsp;приведем базовые принципы, однако надо иметь в&nbsp;виду, что правила всегда определяет руководитель команды, которая работает над проектом.</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<tbody>
<tr>
<td><strong>Уровень</strong></td>
<td><strong>Относящиеся события</strong></td>
</tr>
<tr>
<td><strong>Debug</strong></td>
<td>Сообщения отладки. В&nbsp;боевом режиме (production) сообщения этого уровня обычно отключены, чтобы не&nbsp;засорять файлы журналов. Но&nbsp;они могут включаться для поиска багов, которые не&nbsp;удалось воспроизвести</td>
</tr>
<tr>
<td><strong>Info</strong></td>
<td>Обычные сообщения, информирующие о&nbsp;действиях программы. Реагировать на&nbsp;такие сообщения вообще не&nbsp;надо, но&nbsp;они могут помочь, например, при поиске багов, расследовании интересных ситуаций и&nbsp;т.&nbsp;д.</td>
</tr>
<tr>
<td><strong>Warning</strong></td>
<td>Записывая такое сообщение, программа обычно пытается привлечь внимание. Произошло что-то странное. Возможно, это новый тип ситуации, еще не&nbsp;известный на&nbsp;текущий момент. Следует разобраться в&nbsp;том, что произошло, что это означает, и&nbsp;отнести ситуацию либо к&nbsp;инфо-сообщению, либо к&nbsp;ошибке. Соответственно, придется доработать код обработки таких ситуаций</td>
</tr>
<tr>
<td><strong>Error</strong></td>
<td>Ошибка в&nbsp;работе программы, требующая вмешательства. Что-то не&nbsp;сохранилось, что-то отвалилось. Необходимо принимать меры довольно быстро! Ошибки этого уровня и&nbsp;выше требуют немедленной записи в&nbsp;лог, чтобы ускорить реакцию на&nbsp;них</td>
</tr>
<tr>
<td><strong>Critical (Fatal)</strong></td>
<td>Это&nbsp;&mdash; особый класс ошибок, приводящих к&nbsp;неработоспособности программы в&nbsp;целом или неработоспособности одного из&nbsp;ее&nbsp;модулей. Чаще всего случаются фатальные ошибки из-за неверной конфигурации или отказов оборудования. Требуют срочной, немедленной реакции</td>
</tr>
</tbody>
</table>
</div>
<p>Имейте в&nbsp;виду, что это&nbsp;&mdash; рекомендации. Вы&nbsp;как архитектор программы вправе определять критичность события или ошибки в&nbsp;своей программе, а&nbsp;если работа происходит в&nbsp;команде, то&nbsp;решение о&nbsp;критичности той или иной ситуации принимается руководителем команды или коллегиально.</p>
<p>Разработчик может настраивать уровень логирования. Логируются сообщения установленного уровня и&nbsp;уровней более высокой критичности. Например, если установлен уровень Info, то&nbsp;в&nbsp;консоль или в&nbsp;файл будут выводиться сообщения уровней: Info, Warning, Error и&nbsp;Fatal.</p>
<p>Уровень логирования по&nbsp;умолчанию&nbsp;&mdash; WARNING.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/logging-levels.svg" width="680" height="auto" /></div>
<p>Уровень логирования в&nbsp;Python настраивается все в&nbsp;той&nbsp;же функции <code>logging.basicConfig()</code> следующим образом:</p>
<pre><code class="language-python">import logging

logging.basicConfig(level=logging.DEBUG)


def log():

    logging.debug('Debug')
    logging.info('Info')
    logging.warning('Warning')
    logging.error('Error')
    logging.critical('Critical or Fatal')


if __name__ == '__main__':
    log()
</code></pre>
<p>Видим в&nbsp;консоли:</p>
<pre><samp>DEBUG:root:Debug
INFO:root:Info
WARNING:root:Warning
ERROR:root:Error
CRITICAL:root:Critical or Fatal</samp></pre>
<p>Если вызвать <code>logging.basicConfig(level=logging.ERROR)</code>, в&nbsp;консоли мы&nbsp;увидим:</p>
<pre><samp>ERROR:root:Error
CRITICAL:root:Critical or Fatal</samp></pre>
<p>Используйте логирование в&nbsp;процессе разработки. Это поможет вам правильно и&nbsp;своевременно реагировать на&nbsp;ошибки, искать баги и&nbsp;понимать, что происходит в&nbsp;вашей программе в&nbsp;любой момент времени.</p>
</section>
<section class="material__chapter">
<h2 id="5">Пишем код</h2>
<p>Теперь переходим к&nbsp;самому интересному. Начнем! Мы&nbsp;разработаем навык, который описан в&nbsp;разделе <a class="material__link" href="https://tech.yandex.ru/dialogs/alice/doc/quickstart-python-docpage/" target="_blank" rel="noopener noreferrer">&laquo;Быстрый старт&raquo;</a> документации Алисы.</p>
<p>Вы&nbsp;уже знакомы с&nbsp;библиотекой Flask. С&nbsp;ее&nbsp;помощью мы&nbsp;напишем небольшой веб-сервер, который будет обрабатывать запросы от&nbsp;Алисы.</p>
<p>Алиса будет передавать нам JSON, содержащий данные о&nbsp;пользователе, и&nbsp;информацию, которую пользователь ввел. Мы&nbsp;же должны будем вернуть в&nbsp;ответ свой JSON (соответственно документации). Алиса его обработает и&nbsp;покажет пользователю.</p>
<p>Рассмотрим JSON запроса, который отправит нам Алиса. На&nbsp;самом деле JSON выглядит сложнее и&nbsp;имеет больше полей, но&nbsp;мы&nbsp;рассмотрим только те&nbsp;из&nbsp;них, которые будем использовать (внимательно изучить содержание JSON&rsquo;ов можно в&nbsp;<a class="material__link" href="https://yandex.ru/dev/dialogs/alice/doc/protocol-docpage/" target="_blank" rel="noopener noreferrer">документации</a>):</p>
<pre><code class="language-python">{
  "request": {
    "command": "закажи пиццу на улицу льва толстого, 16 на завтра",
    "original_utterance": "закажи пиццу на улицу льва толстого, 16 на завтра"
  },
  "session": {
    "new": true,
    "message_id": 4,
    "session_id": "2eac4854-fce721f3-b845abba-20d60",
    "skill_id": "3ad36498-f5rd-4079-a14b-788652932056",
    "user_id": "AC9WC3DF6FCE052E45A4566A48E6B7193774B84814CE49A922E163B8B29881DC"
  },
  "version": "1.0"
}
</code></pre>
<ul>
<li><var>request</var>&nbsp;&mdash; данные, полученные от&nbsp;пользователя
<ul>
<li><var>command</var>&nbsp;&mdash; запрос, который был передан вместе с&nbsp;командой активации навыка. Например, если пользователь активирует навык словами &laquo;спроси у&nbsp;Сбербанка, где ближайшее отделение&raquo;, в&nbsp;этом поле будет передана строка &laquo;где ближайшее отделение&raquo;</li>
<li><var>original_utterance</var>&nbsp;&mdash; полный текст пользовательского запроса, максимум 1024 символа</li>
</ul>
</li>
<li><var>session</var>&nbsp;&mdash; данные о&nbsp;сессии (разговоре с&nbsp;Алисой)
<ul>
<li><var>new</var>&nbsp;&mdash; признак новой сессии. Возможные значения: true&nbsp;&mdash; пользователь начинает новый разговор с&nbsp;навыком, false&nbsp;&mdash; запрос отправлен в&nbsp;рамках уже начатого разговора</li>
<li><var>message_id</var>&nbsp;&mdash; идентификатор сообщения в&nbsp;рамках сессии, максимум 8&nbsp;символов. Инкрементируется (увеличивается на&nbsp;единицу) с&nbsp;каждым следующим запросом</li>
<li><var>session_id</var>&nbsp;&mdash; уникальный идентификатор сессии, максимум 64&nbsp;символа</li>
<li><var>skill_id</var>&nbsp;&mdash; идентификатор вызываемого навыка, присвоенный при создании</li>
<li><var>user_id</var>&nbsp;&mdash; идентификатор экземпляра приложения, в&nbsp;котором пользователь общается с&nbsp;Алисой, максимум 64&nbsp;символа. Даже если пользователь авторизован с&nbsp;одним и&nbsp;тем&nbsp;же аккаунтом в&nbsp;приложении Яндекс для Android и&nbsp;iOS, Яндекс.Диалоги (так называется сервис Яндекса, управляющий навыками для Алисы) присвоят отдельный <var>user_id</var> каждому из&nbsp;этих приложений</li>
</ul>
</li>
<li><var>version</var>&nbsp;&mdash; версия протокола. Текущая версия&nbsp;&mdash; 1.0</li>
</ul>
<p>JSON ответа Алисы (то&nbsp;есть тот JSON, что сформирует наша программа) будет выглядеть так (конечно&nbsp;же, полное описание можно посмотреть в&nbsp;<a class="material__link" href="https://tech.yandex.ru/dialogs/alice/doc/protocol-docpage/" target="_blank" rel="noopener noreferrer">документации</a>):</p>
<pre><code class="language-python">{
  "response": {
    "text": "Здравствуйте! Это мы, хороводоведы.",
    "tts": "Здравствуйте! Это мы, хоров+одо в+еды.",
    "buttons": [
        {
            "title": "Надпись на кнопке",
            "payload": {},
            "url": "https://example.com/",
            "hide": true
        }
    ],
    "end_session": false
  },
  "session": {
    "session_id": "2eac4854-fce721f3-b845abba-20d60",
    "message_id": 4,
    "user_id": "AC9WC3DF6FCE052E45A4566A48E6B7193774B84814CE49A922E163B8B29881DC"
  },
  "version": "1.0"
}
</code></pre>
<ul>
<li><var>response</var>&nbsp;&mdash; данные для ответа пользователю
<ul>
<li><var>text</var>&nbsp;&mdash; текст, который следует показать. Максимум 1024&nbsp;символа. Не&nbsp;должен быть пустым</li>
<li><var>tts</var>&nbsp;&mdash; текст, который следует сказать пользователю. Максимум 1024&nbsp;символа. Не&nbsp;должен быть пустым</li>
<li><var>buttons</var>&nbsp;&mdash; массив кнопок, которые следует показать пользователю. Все указанные кнопки выводятся после основного ответа Алисы, описанного в&nbsp;свойстве <var>text</var>. Кнопки можно использовать как релевантные ответу ссылки или подсказки для продолжения разговора</li>
<li><var>title</var>&nbsp;&mdash; текст кнопки, обязателен для каждой кнопки. Максимум 64&nbsp;символа</li>
<li><var>url</var>&nbsp;&mdash; URL, который должна открывать кнопка, максимум 1024 байта</li>
<li><var>payload</var>&nbsp;&mdash; значения, которые передадутся в&nbsp;программу после нажатия этой кнопки</li>
<li><var>hide</var>&nbsp;&mdash; признак того, что кнопку нужно убрать после следующей реплики пользователя. Допустимые значения: false&nbsp;&mdash; кнопка должна оставаться активной (значение по&nbsp;умолчанию), true&nbsp;&mdash; кнопку нужно скрывать после нажатия</li>
<li><var>end_session</var>&nbsp;&mdash; признак конца разговора. Допустимые значения: false&nbsp;&mdash; сессию следует продолжить, true&nbsp;&mdash; сессию следует завершить</li>
</ul>
</li>
<li><var>session</var>&nbsp;&mdash; данные о&nbsp;сессии (аналогичные запросу)</li>
<li><var>version</var>&nbsp;&mdash; версия протокола. Текущая версия&nbsp;&mdash; 1.0</li>
</ul>
<p>Вы&nbsp;можете скачать <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/flask_app.py" target="_blank" rel="noopener noreferrer">файл с&nbsp;шаблоном кода</a> или скопировать текст программы ниже.</p>
<pre><code class="language-python"># импортируем библиотеки
from flask import Flask, request, jsonify
import logging

# создаём приложение
# мы передаём __name__, в нём содержится информация,
# в каком модуле мы находимся.
# В данном случае там содержится '__main__',
# так как мы обращаемся к переменной из запущенного модуля.
# если бы такое обращение, например, произошло внутри модуля logging,
# то мы бы получили 'logging'
app = Flask(__name__)

# Устанавливаем уровень логирования
logging.basicConfig(level=logging.INFO)

# Создадим словарь, чтобы для каждой сессии общения
# с навыком хранились подсказки, которые видел пользователь.
# Это поможет нам немного разнообразить подсказки ответов
# (buttons в JSON ответа).
# Когда новый пользователь напишет нашему навыку,
# то мы сохраним в этот словарь запись формата
# sessionStorage[user_id] = {'suggests': ["Не хочу.", "Не буду.", "Отстань!" ]}
# Такая запись говорит, что мы показали пользователю эти три подсказки.
# Когда он откажется купить слона,
# то мы уберем одну подсказку. Как будто что-то меняется :)
sessionStorage = {}


@app.route('/post', methods=['POST'])
# Функция получает тело запроса и возвращает ответ.
# Внутри функции доступен request.json - это JSON,
# который отправила нам Алиса в запросе POST
def main():
    logging.info(f'Request: {request.json!r}')

    # Начинаем формировать ответ, согласно документации
    # мы собираем словарь, который потом отдадим Алисе
    response = {
        'session': request.json['session'],
        'version': request.json['version'],
        'response': {
            'end_session': False
        }
    }

    # Отправляем request.json и response в функцию handle_dialog.
    # Она сформирует оставшиеся поля JSON, которые отвечают
    # непосредственно за ведение диалога
    handle_dialog(request.json, response)

    logging.info(f'Response:  {response!r}')

    # Преобразовываем в JSON и возвращаем
    return jsonify(response)


def handle_dialog(req, res):
    user_id = req['session']['user_id']

    if req['session']['new']:
        # Это новый пользователь.
        # Инициализируем сессию и поприветствуем его.
        # Запишем подсказки, которые мы ему покажем в первый раз

        sessionStorage[user_id] = {
            'suggests': [
                "Не хочу.",
                "Не буду.",
                "Отстань!",
            ]
        }
        # Заполняем текст ответа
        res['response']['text'] = 'Привет! Купи слона!'
        # Получим подсказки
        res['response']['buttons'] = get_suggests(user_id)
        return

    # Сюда дойдем только, если пользователь не новый,
    # и разговор с Алисой уже был начат
    # Обрабатываем ответ пользователя.
    # В req['request']['original_utterance'] лежит весь текст,
    # что нам прислал пользователь
    # Если он написал 'ладно', 'куплю', 'покупаю', 'хорошо',
    # то мы считаем, что пользователь согласился.
    # Подумайте, всё ли в этом фрагменте написано "красиво"?
    if req['request']['original_utterance'].lower() in [
        'ладно',
        'куплю',
        'покупаю',
        'хорошо'
    ]:
        # Пользователь согласился, прощаемся.
        res['response']['text'] = 'Слона можно найти на Яндекс.Маркете!'
        res['response']['end_session'] = True
        return

    # Если нет, то убеждаем его купить слона!
    res['response']['text'] = \
        f"Все говорят '{req['request']['original_utterance']}', а ты купи слона!"
    res['response']['buttons'] = get_suggests(user_id)


# Функция возвращает две подсказки для ответа.
def get_suggests(user_id):
    session = sessionStorage[user_id]

    # Выбираем две первые подсказки из массива.
    suggests = [
        {'title': suggest, 'hide': True}
        for suggest in session['suggests'][:2]
    ]

    # Убираем первую подсказку, чтобы подсказки менялись каждый раз.
    session['suggests'] = session['suggests'][1:]
    sessionStorage[user_id] = session

    # Если осталась только одна подсказка, предлагаем подсказку
    # со ссылкой на Яндекс.Маркет.
    if len(suggests) &lt; 2:
        suggests.append({
            "title": "Ладно",
            "url": "https://market.yandex.ru/search?text=слон",
            "hide": True
        })

    return suggests


if __name__ == '__main__':
    app.run()
</code></pre>
<p>Сохраните ваш файл под именем flask_app.py.</p>
</section>
<section class="material__chapter">
<h2 id="6">Как работает данный код</h2>
<p>Разберем тезисно, как работает приведенная программа.</p>
<ol>
<li>Когда мы&nbsp;запускаем программу, точкой входа в&nbsp;нее со&nbsp;стороны Алисы является функция <code>main()</code>, которая &laquo;обернута&raquo; декоратором <var>app.route</var>.</li>
<li>Внутри <code>main()</code> мы&nbsp;сначала логируем полученный запрос, затем начинаем формировать ответ, потом вызываем функцию <code>handle_dialog()</code> для обработки диалога с&nbsp;пользователем, в&nbsp;результате&nbsp;же логируем и&nbsp;возвращаем ответ.</li>
<li>Функция <code>handle_dialog()</code> формирует ответ, исходя из&nbsp;данных запроса и&nbsp;состояния сессии (новый разговор или продолжение старого).</li>
<li>Вспомогательная функция <code>get_suggests()</code> формирует подсказки в&nbsp;ответе.</li>
<li>В&nbsp;глобальном словаре <var>sessionStorage</var> мы&nbsp;будем хранить информацию о&nbsp;подсказках для каждого пользователя.</li>
</ol>
</section>
<section class="material__chapter">
<h2 id="7">Отладка с&nbsp;Postman</h2>
<p>Перед тем, как продолжить, нам надо убедиться, что созданный нами веб-сервер возвращает правильный ответ (или похожий на&nbsp;правильный). Воспользуемся для этого программой <a class="material__link" href="https://www.getpostman.com/" target="_blank" rel="noopener noreferrer">Postman</a>.</p>
<p>Postman&nbsp;&mdash; это приложение, которое позволяет взаимодействовать с&nbsp;API без написания кода. Это бывает удобно, чтобы находить ошибки и&nbsp;&laquo;пробовать&raquo; новое API перед разработкой. Postman не&nbsp;единственное подобное приложение, можете попробовать еще, например, <a class="material__link" href="https://insomnia.rest/" target="_blank" rel="noopener noreferrer">Insomnia</a>.</p>
<p>Сейчас мы&nbsp;проверим ответ от&nbsp;нашего приложения.</p>
<p>Запустите созданное ранее приложение в&nbsp;среде разработки и&nbsp;скопируйте адрес вида <code>http://127.0.0.1:5000/post</code> в&nbsp;строку запроса программы Postman.</p>
<p>JSON запроса можно взять из&nbsp;<a class="material__link" href="https://tech.yandex.ru/dialogs/alice/doc/protocol-docpage/" target="_blank" rel="noopener noreferrer">документации</a> Алисы или, на&nbsp;крайний случай, из&nbsp;рассмотренного нами примера.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/postman-1.png" width="680" height="auto" /></div>
<p>Проверьте, что ваш ответ похож на&nbsp;тот, что требует документация Алисы. Если это так, то&nbsp;поздравляем, мы&nbsp;добились результата :)</p>
<p>Для следующего шага нам понадобится, чтобы наш навык был доступен из&nbsp;Интернета, поэтому давайте либо задеплоим (разместим) его на&nbsp;Heroku, либо просто сделаем туннель с&nbsp;помощью ngrok.</p>
</section>
<section class="material__chapter">
<h2 id="8">Регистрация и&nbsp;тестирование навыка</h2>
<p>Перейдем к&nbsp;завершающему и&nbsp;самому простому пункту. Это регистрация навыка в&nbsp;Алисе.</p>
<ol>
<li>Зарегистрируйтесь в&nbsp;Яндексе или залогиньтесь, если вы&nbsp;уже зарегистрированы.</li>
<li>Перейдите по&nbsp;ссылке <a class="material__link" href="https://dialogs.yandex.ru/developer/" target="_blank" rel="noopener noreferrer">https://dialogs.yandex.ru/developer/</a>.</li>
<li>Нажмите <strong>создать диалог</strong>.</li>
<li>Выберите вариант <strong>Навык в&nbsp;Алисе</strong>.</li>
<li>Заполните &laquo;активационное имя&raquo;. По&nbsp;этой фразе Алиса будет вызывать ваш навык.</li>
<li>Заполните поля, указав ссылку в&nbsp;поле Webhook URL. (из бесплатных сервисов рекомендуем использовать Glitch)</li>
</ol>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/cabinet.png" width="680" height="auto" /></div>
<p>Перейдите на&nbsp;вкладку <strong>Тестирование</strong> и&nbsp;проверьте работу своего навыка.</p>
</section>
<section class="material__chapter">
<h2 id="9">Именованные сущности</h2>
<p>Часто при создании навыка из&nbsp;ответа пользователя необходимо извлечь некоторую информацию, и&nbsp;не&nbsp;всегда это делается просто. Но&nbsp;разработчики Алисы уже позаботились о&nbsp;нас и&nbsp;сами выделяют некоторые такие сущности, которые в&nbsp;терминах Алисы называются <strong>именованными</strong>.</p>
<p>Под именованными сущностями подразумеваются:</p>
<ul>
<li>Имена</li>
<li>Фамилии</li>
<li>Названия городов и&nbsp;т.&nbsp;д.</li>
</ul>
<p>Когда пользователь в&nbsp;своем сообщении использует имя, фамилию или город, эти данные попадают в&nbsp;специальный раздел JSON&rsquo;а, который отправляет нам Алиса.</p>
<p>Рассмотрим пример:</p>
<pre><code class="language-python">{
  "meta": {
    "locale": "ru-RU",
    "timezone": "Europe/Moscow",
    "client_id": "ru.yandex.searchplugin/5.80 (Samsung Galaxy; Android 4.4)",
    "interfaces": {
      "screen": { }
    }
  },
  "request": {
    "command": "закажи пиццу на улицу льва толстого, 16 на завтра",
    "original_utterance": "закажи пиццу на улицу льва толстого, 16 на завтра",
    "type": "SimpleUtterance",
    "markup": {
      "dangerous_context": true
    },
    "payload": {},
    "nlu": {
      "tokens": [
        "закажи",
        "пиццу",
        "на",
        "льва",
        "толстого",
        "16",
        "на",
        "завтра"
      ],
      "entities": [
        {
          "tokens": {
            "start": 2,
            "end": 6
          },
          "type": "YANDEX.GEO",
          "value": {
            "house_number": "16",
            "street": "льва толстого"
          }
        },
        {
          "tokens": {
            "start": 3,
            "end": 5
          },
          "type": "YANDEX.FIO",
          "value": {
            "first_name": "лев",
            "last_name": "толстой"
          }
        },
        {
          "tokens": {
            "start": 5,
            "end": 6
          },
          "type": "YANDEX.NUMBER",
          "value": 16
        },
        {
          "tokens": {
            "start": 6,
            "end": 8
          },
          "type": "YANDEX.DATETIME",
          "value": {
            "day": 1,
            "day_is_relative": true
          }
        }
      ]
    }
  },
  "session": {
    "new": true,
    "message_id": 4,
    "session_id": "2eac4854-fce721f3-b845abba-20d60",
    "skill_id": "3ad36498-f5rd-4079-a14b-788652932056",
    "user_id": "AC9WC3DF6FCE052E45A4566A48E6B7193774B84814CE49A922E163B8B29881DC"
  },
  "version": "1.0"
}
</code></pre>
<p>Обратите внимание на&nbsp;раздел request &rarr; nlu &rarr; tokens:</p>
<pre><code class="language-python">"tokens": [
        "закажи",
        "пиццу",
        "на",
        "льва",
        "толстого",
        "16",
        "на",
        "завтра"
      ]
</code></pre>
<p>Можно заметить, что это полученный от&nbsp;пользователя текст, разобранный на&nbsp;отдельные слова. Каждое слово при этом приводится к&nbsp;нижнему регистру. Это очень удобно, если надо искать вхождения каких-то определенных слов. Например, &laquo;да&raquo; или &laquo;нет&raquo;.</p>
<p>Второй раздел, на&nbsp;который стоит обратить внимание&nbsp;&mdash; это entities (то&nbsp;есть <strong>сущности</strong>):</p>
<pre><code class="language-python">"entities": [
        {
          "tokens": {
            "start": 2,
            "end": 6
          },
          "type": "YANDEX.GEO",
          "value": {
            "house_number": "16",
            "street": "льва толстого"
          }
        },
        {
          "tokens": {
            "start": 3,
            "end": 5
          },
          "type": "YANDEX.FIO",
          "value": {
            "first_name": "лев",
            "last_name": "толстой"
          }
        },
        {
          "tokens": {
            "start": 5,
            "end": 6
          },
          "type": "YANDEX.NUMBER",
          "value": 16
        },
        {
          "tokens": {
            "start": 6,
            "end": 8
          },
          "type": "YANDEX.DATETIME",
          "value": {
            "day": 1,
            "day_is_relative": true
          }
        }
      ]
</code></pre>
<p>Мы&nbsp;видим, что текст от&nbsp;пользователя подробно разобран и&nbsp;из&nbsp;него выделены все сущности от&nbsp;имени до&nbsp;даты.</p>
<p>entities&nbsp;&mdash; это массив таких сущностей. Рассмотрим одну сущность и&nbsp;подробно распишем, из&nbsp;чего&nbsp;же она состоит:</p>
<pre><code class="language-python">{
"tokens": {
   "start": 3,
   "end": 5
},
   "type": "YANDEX.FIO",
   "value": {
      "first_name": "лев",
       "last_name": "толстой"
    }
}
</code></pre>
<ul>
<li><var>tokens</var>&nbsp;&mdash; обозначение начала и&nbsp;конца именованной сущности в&nbsp;массиве слов (<var>tokens</var>, что мы&nbsp;рассматривали выше). Нумерация слов в&nbsp;массиве начинается с&nbsp;0
<ul>
<li><var>start</var>&nbsp;&mdash; первое слово именованной сущности</li>
<li><var>end</var>&nbsp;&mdash; последнее слово после именованной сущности</li>
</ul>
</li>
<li><var>type</var>&nbsp;&mdash; тип именованной сущности. Возможные значения:
<ul>
<li>YANDEX.DATETIME&nbsp;&mdash; дата и&nbsp;время</li>
<li>YANDEX.FIO&nbsp;&mdash; фамилия, имя и&nbsp;отчество</li>
<li>YANDEX.GEO&nbsp;&mdash; местоположение (адрес или аэропорт)</li>
<li>YANDEX.NUMBER&nbsp;&mdash; число, целое или с&nbsp;плавающей точкой</li>
</ul>
</li>
<li><var>value</var>&nbsp;&mdash; формальное описание именованной сущности (мы&nbsp;приведем ниже пример для типа YANDEX.FIO. Описание остальных типов ищите в&nbsp;<a class="material__link" href="https://yandex.ru/dev/dialogs/alice/doc/naming-entities-docpage/" target="_blank" rel="noopener noreferrer">документации</a>)
<ul>
<li>first_name&nbsp;&mdash; имя</li>
<li>last_name&nbsp;&mdash; фамилия</li>
</ul>
</li>
</ul>
<p>Пример кода, получающий имя человека из&nbsp;JSON:</p>
<pre><code class="language-python">def get_first_name(req):
    # перебираем сущности
    for entity in req['request']['nlu']['entities']:
        # находим сущность с типом 'YANDEX.FIO'
        if entity['type'] == 'YANDEX.FIO':
            # Если есть сущность с ключом 'first_name', 
            # возвращаем ее значение.
            # Во всех остальных случаях возвращаем None.
            return entity['value'].get('first_name', None)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="10">Ресурсы</h2>
<p>Для каждого навыка Алиса позволяет размещать до&nbsp;100&nbsp;MB дополнительных медиафайлов (изображения и&nbsp;звуки), но&nbsp;с&nbsp;некоторыми ограничениями:</p>
<ul>
<li>Изображение должно быть размером от&nbsp;1&nbsp;KB до&nbsp;1&nbsp;MB</li>
<li>Звуковой файл должен быть не&nbsp;длиннее 2-х минут</li>
</ul>
<p>Ресурсы можно добавить на&nbsp;вкладке &laquo;Ресурсы&raquo; в&nbsp;разделе управления навыком. Как работать с&nbsp;изображениями мы&nbsp;рассмотрим на&nbsp;следующем уроке, а&nbsp;пока давайте добавим какой-нибудь звук.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/resources.png" width="680" height="auto" /></div>
<p>После загрузки звукового файла добавится код его вставки в&nbsp;ответ. Чтобы добавить проигрывание звукового файла, надо добавить этот код в&nbsp;поле <var>tts</var> ответа.</p>
<p>Загружать ресурсы к&nbsp;навыку можно не&nbsp;только через веб-интерфейс, но&nbsp;и&nbsp;с&nbsp;помощью <a class="material__link" href="https://tech.yandex.ru/dialogs/alice/doc/resource-upload-docpage/" target="_blank" rel="noopener noreferrer">HTTP API Алисы</a>. Можно написать код с&nbsp;использованием библиотеки requests или воспользоваться Postman.</p>
<p>Идем по&nbsp;пунктам:</p>
<ol>
<li>Создадим новый навык. Зайдем на&nbsp;<a class="material__link" href="https://dialogs.yandex.ru/developer/" target="_blank" rel="noopener noreferrer">платформу диалогов</a> и&nbsp;нажмем <strong>создать новый навык</strong></li>
<li>Скопируем из&nbsp;URL и&nbsp;сохраним его идентификатор (ID):
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/zagruzkafoto.png" width="680" height="auto" /></div>
</li>
<li>Получим token по&nbsp;<a class="material__link" href="https://oauth.yandex.ru/authorize?response_type=token&amp;client_id=c473ca268cd749d3a8371351a8f2bcbd" target="_blank" rel="noopener noreferrer">ссылке</a>. Сохраните его тоже. Он&nbsp;вам пригодится</li>
<li>Теперь запускаем Postman
<ul>
<li>Заполняем поля на&nbsp;вкладке Headers</li>
<li>Добавьте параметр с&nbsp;названием Authorization. Для этого в&nbsp;колонке KEY пишем Authorization, а&nbsp;в&nbsp;колонке VALUE&nbsp;&mdash; &laquo;OAuth Token&raquo; (OAuth пробел token, который вы&nbsp;получили)</li>
<li>В&nbsp;поле ссылки добавляем ссылку <code>https://dialogs.yandex.net/api/v1/skills/id_навыка/images</code> (заменить id_навыка на&nbsp;id&nbsp;из&nbsp;пункта&nbsp;2) для изображения или <code>https://dialogs.yandex.net/api/v1/skills/id_навыка/sounds</code> для звукового файла</li>
</ul>
<img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/postman-2.png" width="680" height="auto" /></li>
<li>Теперь на&nbsp;вкладке Body выбираем радио-кнопку form-data и&nbsp;добавляем файл. В&nbsp;колонке key напишите &laquo;file&raquo;, в&nbsp;колонке value нажмите &laquo;choose file&raquo; и&nbsp;выберите файл с&nbsp;вашего компьютера. Далее нажимаем Send.</li>
</ol>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/alice/postman-3.png" width="680" height="auto" /></div>
<p>Если все сделано правильно, в&nbsp;ответе вы&nbsp;получите идентификатор картинки или звукового файла, который вы&nbsp;сможете использовать в&nbsp;дальнейшем.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>