<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Совместная работа над проектом, основные понятия и команды </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Репозитории 2</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Совместная работа над проектом, основные понятия и&nbsp;команды. Работа с&nbsp;репозиториями в&nbsp;среде разработки</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Ветки в&nbsp;Git</a></li>
<li><a class="material__link" href="#2">Объединение (слияние) изменений</a></li>
<li><a class="material__link" href="#3">Решение конфликтов</a></li>
<li><a class="material__link" href="#4">Схема командной работы с&nbsp;репозиторием</a></li>
<li><a class="material__link" href="#5">GitFlow</a></li>
<li><a class="material__link" href="#6">GitHubFlow</a></li>
<li><a class="material__link" href="#7">Заключение</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке рассматривается работа с&nbsp;ветками в&nbsp;Git, решение конфликтов изменений, а&nbsp;также основы командной разработки в&nbsp;Git.</p>
</section>
<section class="material__chapter">
<h2 id="1">Ветки в&nbsp;Git</h2>
<p>Мы&nbsp;уже немного затронули тему о&nbsp;<strong>ветках</strong> в&nbsp;Git. Настало время внимательней разобрать это понятие.</p>
<p>Если&nbsp;бы система контроля версий ограничивалась только ведением истории коммитов, то&nbsp;она&nbsp;бы никак не&nbsp;помогла нескольким разработчикам работать с&nbsp;одним репозиторием. Или одному разработчику&nbsp;&mdash; над несколькими задачами в&nbsp;одном.</p>
<p>Для всего этого (и&nbsp;не&nbsp;только) в&nbsp;Git и&nbsp;существуют ветки. Ветки позволяют:</p>
<ul>
<li>Давать имена версиям</li>
<li>Иметь одновременно несколько <strong>рабочих</strong> версий (рабочей версией называется&nbsp;та, над которой в&nbsp;определенный момент времени трудится разработчик)</li>
<li>Объединять результаты деятельности нескольких разработчиков</li>
</ul>
<p>Допустим, у&nbsp;нас есть программа (можно продолжить работу с&nbsp;репозиторием из&nbsp;прошлого урока, а&nbsp;можно создать новый репозиторий), последняя закоммиченная версия которой выглядит так:</p>
<pre><code class="language-python">def my_superfunction():
    print('What an awesome print!')


def main():
    print('My first git program')
    print('And I change it every day')
    print('Again')
    print('UFO came and added this line')
    my_superfunction()


if __name__ == '__main__':
    main()
</code></pre>
<p>Мы&nbsp;хотим создать версии нашей программы, в&nbsp;которой функция <var>my_superfunction</var> ведет себя по-другому, например, одна выводит надпись Hello, python!!!, другая&nbsp;&mdash; Yandexlyceum, но&nbsp;старую версию мы&nbsp;тоже хотим сохранить.</p>
<p>Сначала заведем новую ветку программы и&nbsp;сразу на&nbsp;нее переключимся. Это можно сделать через пункт меню VCS&nbsp;&rarr;&nbsp;Git&nbsp;&rarr;&nbsp;Branches&nbsp;&rarr;&nbsp;New Branch (или Ctrl + Shift + `). В&nbsp;появившемся окне введем имя нашей новой ветки, например, <var>newBranch</var>, оставим галочку, которая сразу осуществляет переключение на&nbsp;новою ветку при создании нетронутой.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-1-create-branch.png" width="500" height="auto" /></div>
<p>Посмотрим на&nbsp;вкладку Log меню системы контроля версий. Обратите внимание, что на&nbsp;последнем коммите появилась еще одна зеленая бирочка, которая говорит о&nbsp;том, что мы&nbsp;находимся на&nbsp;развилке и&nbsp;в&nbsp;этом месте код двух веток master и&nbsp;newBranch совпадает.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-2.png" width="680" height="auto" /></div>
<p>Поменяем код нашей функции и&nbsp;закоммитим изменения.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-3.png" width="600" height="auto" /></div>
<p>При совершении коммита видно, что изменения фиксируются в&nbsp;ветку newBranch.</p>
<p>Давайте вернемся в&nbsp;master. В&nbsp;Logs в&nbsp;меню системы контроля версии выберем последний коммит ветки master, кликнем на&nbsp;нем правой кнопкой мышки и&nbsp;выберем Branch 'master'&nbsp;&rarr;&nbsp;Checkout.</p>
<p>Создадим еще одну ветку, назовем ее&nbsp;demobranch.</p>
<p>Внесем изменения в&nbsp;функцию <var>my_superfunction</var>, чтобы она выводила текст Yandexlyceum, и&nbsp;закомитим изменения.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-4.png" width="680" height="auto" /></div>
<p>По&nbsp;логам видно, что у&nbsp;нас есть три ветки: master, newBranch и&nbsp;demobranch. demobranch&nbsp;&mdash; текущая активная ветка, то, что мы&nbsp;находимся в&nbsp;ней, подтверждается указателем HEAD. Также есть ветка newBranch, у&nbsp;которой с&nbsp;demobranch общий источник кода&nbsp;&mdash; последний на&nbsp;текущий момент коммит ветки master.</p>
<p>Для того чтобы переключиться в&nbsp;нужную ветку, надо кликнуть на&nbsp;последнем коммите этой ветки и&nbsp;выбрать пункт меню Branch 'имя_ветки'&nbsp;&rarr;&nbsp;Checkout (это можно сделать и&nbsp;через меню: VCS&nbsp;&rarr;&nbsp;Git&nbsp;&rarr;&nbsp;Branches).</p>
<p>Теперь удалим неиспользуемую ветку demobranch командой VCS&nbsp;&rarr;&nbsp;Git&nbsp;&rarr;&nbsp;Branches&nbsp;&rarr;&nbsp;demobranch&nbsp;&rarr;&nbsp;Delete.</p>
<p>Теперь мы&nbsp;умеем создавать и&nbsp;удалять ветки, а&nbsp;также переключаться между ветками.</p>
<p>Версии программы, зафиксированные в&nbsp;разных ветках, можно сравнивать между собой с&nbsp;помощью команды VCS&nbsp;&rarr;&nbsp;Git&nbsp;&rarr;&nbsp;Compare with Branch. Давайте сравним program.py из&nbsp;ветки newBranch, в&nbsp;которой мы&nbsp;сейчас находимся, и&nbsp;master.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-5.png" width="680" height="auto" /></div>
<p>Обратите внимание: создавая ветку, мы&nbsp;<strong>получаем полную</strong> копию ветки, в&nbsp;которой находились в&nbsp;этот момент.</p>
<p>Для закрепления успехов перейдем на&nbsp;ветку master, создадим новую ветку addAuthorBranch, и&nbsp;добавим в&nbsp;начало нашей программы комментарий с&nbsp;именем автора:</p>
<pre><code class="language-python"># Yandexlyceum
def my_superfunction():
    print('What an awesome print!')
....
</code></pre>
<p>Закоммитим изменения.</p>
<p>Затем снова вернемся в&nbsp;master, создадим ветку printOne, в&nbsp;которой добавим в&nbsp;конец функции <var>main</var> код:</p>
<pre><code class="language-python">print(1)
</code></pre>
<p>Снова закоммитим изменения. После проделанной работы Log системы контроля версий должен выглядеть примерно вот так:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-6.png" width="680" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="2">Объединение (слияние) изменений</h2>
<p>Итак, Git позволяет независимо разрабатывать несколько версий программы в&nbsp;разных <strong>ветках</strong> одного большого дерева.</p>
<p>Теперь разберемся, как из&nbsp;двух веток собрать единую версию. Попробуем получить программу как с&nbsp;указанием авторства из&nbsp;ветки addAuthorBranch, так и&nbsp;с&nbsp;печатью единицы из&nbsp;ветки printOne.</p>
<p>Для объединения нескольких веток (merge) в&nbsp;одну, нам необходимо перейти в&nbsp;ветку, в&nbsp;которую мы&nbsp;хотим влить изменения. Пусть это будет ветка printOne. Выберите в&nbsp;Log последний коммит ветки addAuthorBranch, кликните на&nbsp;ней правой кнопкой мышки и&nbsp;выберите команду Branch 'addAuthorBranch'&nbsp;&rarr;&nbsp;Merge into Current.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-7.png" width="680" height="auto" /></div>
<p>В&nbsp;Logs мы&nbsp;увидим, что у&nbsp;нас соединились две ветки в&nbsp;одну, а&nbsp;сам код&nbsp;&mdash; результат объединения этих веток. Влейте ветку newBranch в&nbsp;printOne.</p>
<p>Если мы&nbsp;зайдем на&nbsp;GitHub, мы&nbsp;увидим, что изменения которые мы&nbsp;делали, там не&nbsp;отразились. Это нормально, ведь все изменения мы&nbsp;делали локально. Давайте запушим нашу ветку printOne:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-8.png" width="680" height="auto" /></div>
<p>После этого ветка printOne и&nbsp;коммиты из&nbsp;нее попадут в&nbsp;удаленный репозиторий. А&nbsp;у&nbsp;нашей ветки printOne на&nbsp;вкладке Logs появится фиолетовая бирочка и&nbsp;информация о&nbsp;том, что тот&nbsp;же код находится в&nbsp;удаленном репозитории в&nbsp;ветке origin/printOne.</p>
</section>
<section class="material__chapter">
<h2 id="3">Решение конфликтов</h2>
<p>Не&nbsp;всегда объединение веток проходит гладко. Бывает, что программисты (или один программист в&nbsp;разных ветках) вносили изменения в&nbsp;одну и&nbsp;ту&nbsp;же строку кода, поэтому при объединении изменений возникнет конфликт, и&nbsp;объединение веток не&nbsp;будет считаться успешным до&nbsp;тех пор, пока этот конфликт не&nbsp;будет решен. Давайте смоделируем такую ситуацию.</p>
<p>Переключимся на&nbsp;ветку master и&nbsp;создадим там новый файл conflict_test.py вот с&nbsp;таким кодом:</p>
<pre><code class="language-python">print("Hello Git!")
print("Hello PyCharm!")
</code></pre>
<p>Добавим его к&nbsp;отслеживанию и&nbsp;закоммитим.</p>
<p>Создадим новую ветку lowercase (VCS&nbsp;&rarr;&nbsp;Git&nbsp;&rarr;&nbsp;Branches&nbsp;&rarr;&nbsp;New Branch, оставим галочку для переключения на&nbsp;новую ветку), и, стоя на&nbsp;ней, изменим наш файл следующим образом:</p>
<pre><code class="language-python">print("hello git!") # маленькие буквы
print("hello pycharm!") # маленькие буквы
</code></pre>
<p>Cделаем коммит. После этого переключимся на&nbsp;ветку master, убедимся, что файл вернулся к&nbsp;изначальной версии, и&nbsp;создадим еще одну ветку uppercase. Стоя на&nbsp;ней, изменим файл следующим образом:</p>
<pre><code class="language-python">print("HELLO GIT!") # большие буквы
print("HELLO PYCHARM!") # большие буквы
</code></pre>
<p>Cнова зафиксируем версию. Вернемся на&nbsp;ветку master и&nbsp;вольем в&nbsp;нее изменения из&nbsp;ветки lowercase. Слияние должно пройти успешно, а&nbsp;на&nbsp;ветке master появятся маленькие буквы. После этого выполним слияние с&nbsp;веткой uppercase. Теперь возник конфликт.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-9.png" width="680" height="auto" /></div>
<p>Нам показывается перечень файлов, в&nbsp;которых изменения затрагивают одни и&nbsp;те&nbsp;же строки. У&nbsp;нас есть несколько вариантов действий:</p>
<ol>
<li>Accept Yours&nbsp;&mdash; оставить версию строк, которые находятся в&nbsp;текущей ветке (в&nbsp;которую вливаются изменения)</li>
<li>Accept Theirs&nbsp;&mdash; заменить все конфликтные строки на&nbsp;новую версию из&nbsp;вливаемой ветки</li>
<li>Merge&nbsp;&mdash; решить конфликт в&nbsp;ручном режиме. Это наиболее безопасный вариант</li>
</ol>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-10.png" width="680" height="auto" /></div>
<p>При выборе Merge откроется окно:</p>
<ul>
<li>Левая часть&nbsp;&mdash; текущая версия файла на&nbsp;ветке, в&nbsp;которую вливаются изменения</li>
<li>Правая часть&nbsp;&mdash; версия файла на&nbsp;ветке, откуда вливаются изменения</li>
<li>Центральная часть&nbsp;&mdash; версия, предлагаемая Git при попытке автоматического слияния, может быть основана на&nbsp;предыдущих версиях файла</li>
</ul>
<p>Тут есть быстрые кнопки для принятия левой (Accept Left), правой (Accept Right) и&nbsp;центральной части (Apply). Также можно отменить слияние (Abort). Какую часть выбрать&nbsp;&mdash; решает разработчик. Еще он&nbsp;может редактировать центральную часть, создав новую версию файла. Решите конфликт любым способом.</p>
</section>
<section class="material__chapter">
<h2 id="4">Схема командной работы с&nbsp;репозиторием</h2>
<p>Мы&nbsp;с&nbsp;вами уже научились работать с&nbsp;локальными и&nbsp;удаленными репозиториями, создавать, удалять и&nbsp;объединять ветки, фиксировать изменения в&nbsp;локальном и&nbsp;удаленном репозитории. Но&nbsp;во&nbsp;всех наших упражнениях ситуация была упрощенной: с&nbsp;репозиторием работал только один разработчик.</p>
<p>Когда разработчик один, то&nbsp;не&nbsp;особенно важно, как называть ветки, когда создавать новые ветки, в&nbsp;какое время и&nbsp;куда их&nbsp;вливать. Но&nbsp;все кардинально меняется, если с&nbsp;репозиторием работают несколько разработчиков:</p>
<ul>
<li>Многократно возрастает вероятность конфликтов в&nbsp;ветках</li>
<li>Угадать, какие изменения сделаны в&nbsp;ветке, невозможно, если нет понятных имен веток и&nbsp;комментариев к&nbsp;коммитам</li>
<li>Появляется необходимость как-то договориться о&nbsp;том, где мы&nbsp;храним полностью работающую программу, а&nbsp;где&nbsp;&mdash; ведем разработку и&nbsp;экспериментируем</li>
</ul>
<p>И, наконец, нужно как-то работать с&nbsp;удаленным репозиторием, не&nbsp;мешая друг другу.</p>
<p>Для решения перечисленных проблем нужно, чтобы все разработчики проекта следовали единому своду правил работы с&nbsp;репозиторием.</p>
<p>Перечислим требования, которые предъявляются к&nbsp;такому своду:</p>
<ol>
<li>Единый стандарт именования веток</li>
<li>Единый стандарт ветвления в&nbsp;репозитории</li>
<li>Единые правила изменения стабильной ветки (master)</li>
<li>Единые правила объединения репозиториев</li>
<li>Единые правила работы над проектными задачами</li>
</ol>
<p>Такие своды правил называют flow.</p>
<p>В&nbsp;современной разработке чаще всего используются две популярные схемы (в&nbsp;пределах одного проекта рекомендуется выбрать и&nbsp;использовать только одну):</p>
<ol>
<li>Классический подход Git Flow</li>
<li>GitHub Flow, адаптированный под коллективную работу на&nbsp;GitHub</li>
</ol>
<p>Перед началом изучения методологий работы с&nbsp;репозиторием давайте зафиксируем терминологию&nbsp;&mdash; она идентична для всех основных flow:</p>
<ul>
<li>Стабильная ветка (Stable)&nbsp;&mdash; ветка, в&nbsp;которой программа в&nbsp;любой момент считается рабочей и&nbsp;хорошо протестированной. В&nbsp;идеале программу из&nbsp;этой ветки всегда можно передать заказчику&nbsp;&mdash; или, как часто говорят, <em>в&nbsp;продакшн</em> (production&nbsp;&mdash; рабочее состояние продукта). В&nbsp;большинстве методологий в&nbsp;качестве стабильной используется ветка master</li>
<li>Ветка разработки (Dev)&nbsp;&mdash; ветка, относительно которой заводятся все новые изменения (именно от&nbsp;этой ветки отделяются новые ветки для разработки фич). Как правило, это ветка со&nbsp;всеми законченными в&nbsp;настоящий момент изменениями, без нестабильных изменений и&nbsp;изменений &laquo;в&nbsp;работе&raquo;. Код в&nbsp;этой ветке чаще всего работоспособен, но&nbsp;не&nbsp;протестирован достаточно хорошо для передачи <em>в&nbsp;продакшн</em>. Из&nbsp;этой ветки часто собираются будущие релизы</li>
<li>Релиз&nbsp;&mdash; процесс вливания ветки релиз-кандидата в&nbsp;мастер-ветку и&nbsp;выкладки ее&nbsp;в&nbsp;продакшн</li>
<li>Релиз-кандидат/релизная ветка&nbsp;&mdash; ветка, где зафиксированы на&nbsp;момент релиза (выпуска новой версии продукта) все изменения, которые следующим шагом <em>поедут в&nbsp;продакшн</em>, то&nbsp;есть будут включены в&nbsp;новую версию. После сбора этой ветки вносить в&nbsp;нее изменения, кроме исправления ошибок (или <em>багов</em>), обычно запрещено</li>
<li>Фича-бранч&nbsp;&mdash; ветка, в&nbsp;которой разработчик ведет разработку одной конкретной задачи или функциональности</li>
<li>Хотфикс&nbsp;&mdash; ветка, отходящая от&nbsp;стабильной ветки или релиз-кандидата, нужная для исправления критического бага и&nbsp;обратного вливания в&nbsp;ту&nbsp;же ветку и&nbsp;все дочерние ветки</li>
</ul>
</section>
<section class="material__chapter">
<h2 id="5">GitFlow</h2>
<p>Самая старая&nbsp;и, вероятно, одна из&nbsp;наиболее распространенных методологий работы с&nbsp;репозиторием. Про нее часто спрашивают на&nbsp;различных собеседованиях при приеме на&nbsp;работу и&nbsp;применяют в&nbsp;относительно консервативных командах.</p>
<p>GitFlow использует описанные выше сущности следующим образом:</p>
<ul>
<li>Stable&nbsp;&mdash; ветка master</li>
<li>Dev&nbsp;&mdash; ветка develop</li>
<li>Фича-бранчи&nbsp;&mdash; ветки вида feature/&lt;имя фичи/номер тикета в&nbsp;трекинг-системе&gt; (это такие системы, в&nbsp;которых разработчикам ставят задачи и&nbsp;определяют сроки их&nbsp;выполнения, а&nbsp;разработчики отчитываются о&nbsp;результатах своей работы)</li>
<li>Хотфиксы&nbsp;&mdash; ветки вида hotfix/&lt;имя исправляемого бага/номер тикета в&nbsp;трекинг-системе&gt;</li>
<li>Релизные ветки&nbsp;&mdash; ветки вида release/&lt;номер релиза/дата начала релиза&gt;. Часто в&nbsp;качестве номера релиза используется symver-нотация: x.y.z, где x&nbsp;&mdash; версия программного продукта, версии с&nbsp;разной x-версией часто обратно несовместимы; y&nbsp;&mdash; номер релиза, если меняется только y&nbsp;&mdash; обратная совместимость не&nbsp;нарушается, чаще&nbsp;&mdash; исправляется старая функциональность или добавляется опциональная новая; z&nbsp;&mdash; номер патча, обнуляется при каждом обновлении&nbsp;y, часто используется для обозначения порядкового номера хотфикса. Подробнее о&nbsp;семантическом версионировании читайте <a class="material__link" href="http://semver.org/lang/ru/" target="_blank" rel="noopener noreferrer">тут</a></li>
<li>Релиз/Тег&nbsp;&mdash; тег в&nbsp;ветке master, совпадающий по&nbsp;имени с&nbsp;именем релизной ветки (подробнее про теги читайте в&nbsp;инструкции git help tag)</li>
</ul>
<p>В&nbsp;качестве примера трекинг-систем можно привести следующие:</p>
<ol>
<li><a class="material__link" href="https://ru.atlassian.com/software/jira" target="_blank" rel="noopener noreferrer">JIRA</a></li>
<li><a class="material__link" href="http://www.redmine.org/" target="_blank" rel="noopener noreferrer">Redmine</a></li>
<li><a class="material__link" href="http://tracker.yandex.ru/" target="_blank" rel="noopener noreferrer">Яндекс.Трекер</a></li>
</ol>
<p>Общая схема работы с&nbsp;репозиторием в&nbsp;рамках GitFlow выглядит так:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/gitflow.svg" width="680" height="auto" /></div>
<p>Обратите внимание на&nbsp;то, как происходит выпуск <strong>релизов</strong>. Например, релиз с&nbsp;номером 1.1.1 получился только после внесения критичных правок, которые добавились и&nbsp;в&nbsp;<strong>коммит</strong> в&nbsp;ветке develop.</p>
<p>А&nbsp;версия 1.2.0 собралась уже из&nbsp;релизной ветки.</p>
<p>Предлагаем вам немного поработать по&nbsp;методологии GitFlow.</p>
</section>
<section class="material__chapter">
<h2 id="6">GitHubFlow</h2>
<p>GitHubFlow&nbsp;&mdash; современная методология, которая распространена в&nbsp;компаниях, использующих систему GitHub. Она отлично совместима с&nbsp;процессом непрерывной поставки&nbsp;ПО и&nbsp;публичной работой над свободным программным обеспечением.</p>
<p>GitHubFlow оперирует следующими сущностями:</p>
<ul>
<li>Stable&nbsp;&mdash; ветка master</li>
<li>Dev&nbsp;&mdash; сущность отдельно не&nbsp;выделяется. В&nbsp;качестве ветки, от&nbsp;которой осуществляется ветвление, используется ветка master</li>
<li>Фича-бранчи&nbsp;&mdash; ветки вида feature/&lt;имя фичи/номер тикета в&nbsp;трекинг-системе&gt;</li>
<li>Хотфиксы&nbsp;&mdash; ветки вида hotfix/&lt;имя исправляемого бага/номер тикета в&nbsp;трекинг-системе&gt;</li>
<li>Релизные ветки&nbsp;&mdash; в&nbsp;виде отдельный сущности, как правило, не&nbsp;используются. GitHubFlow приветствует идеологию 1&nbsp;фича = 1&nbsp;релиз</li>
<li>Релиз/Тег&nbsp;&mdash; тег в&nbsp;ветке master, совпадающий по&nbsp;имени с&nbsp;релизной веткой (подробнее про теги читайте в&nbsp;инструкции git help tag)</li>
<li>Pull-request&nbsp;&mdash; сущность, специфичная для системы GitHub, заменяющая собой push в&nbsp;ветку master. После окончания работы над фича-веткой разработчик не&nbsp;делает merge в&nbsp;мастер-ветку, а&nbsp;создает <strong>предложение</strong> о&nbsp;внесении изменений в&nbsp;GitHub&nbsp;&mdash; так называемый pull-request. Далее основные разработчики проекта проверяют код пулл-реквеста (смотрят на&nbsp;корректность вносимых изменений или делают codereview) и&nbsp;либо принимают пулл-реквест (предварительно решив конфликты обычным слиянием), либо отклоняют пулл-реквест. Во&nbsp;втором случае изменения не&nbsp;попадают в&nbsp;ветку master</li>
</ul>
<p>Подробнее почитать про GitHubFlow можно <a class="material__link" href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener noreferrer">тут</a>.</p>
<p>Общая схема работы с&nbsp;репозиторием в&nbsp;рамках GitHubFlow выглядит так:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/git-2/githubflow.svg" width="680" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="7">Заключение</h2>
<p>На&nbsp;этом мы&nbsp;закончим наш небольшой экскурс в&nbsp;системы контроля версий.</p>
<p>Вы&nbsp;научились работать в&nbsp;команде с&nbsp;удаленными репозиториями. Теперь у&nbsp;вас есть достаточно знаний для самостоятельного участия в&nbsp;разработке различных проектов.</p>
<p>На&nbsp;этом возможности PyCharm по&nbsp;работе с&nbsp;Git не&nbsp;заканчиваются. Сами разработчики JetBrains подготовили подробную <a class="material__link" href="https://www.jetbrains.com/help/pycharm/using-git-integration.html" target="_blank" rel="noopener noreferrer">инструкцию</a> по&nbsp;работе с&nbsp;Git из&nbsp;PyCharm (на&nbsp;английском языке). Там вы&nbsp;найдёте много полезной информации и&nbsp;узнаете о&nbsp;дополнительных возможностях PyCharm, которые мы&nbsp;не&nbsp;успели рассмотреть за&nbsp;время урока.</p>
<p>Рекомендуем вам попробовать поработать с&nbsp;Git с&nbsp;помощью командной строки. Работая с&nbsp;репозиторием с&nbsp;помощью командной строки, программист строго контролирует все выполняемые операции, видит все происходящее в&nbsp;репозитории и&nbsp;может гибко настраивать функциональность Git под свои нужды: у&nbsp;каждой команды существует большое количество флагов, вы&nbsp;можете увидеть их&nbsp;с&nbsp;помощью git help &lt;имя команды&gt;. Кроме того, скорость работы командной строки значительно выше, чем у&nbsp;графических утилит. Графические утилиты, как правило, не&nbsp;реализуют в&nbsp;полной мере все функции системы Git. Тем не&nbsp;менее, с&nbsp;ними удобно и&nbsp;приятно работать, они позволяют выполнять все часто используемые команды. Большое преимущество работы с&nbsp;Git через IDE: не&nbsp;нужно переключаться между окнами и&nbsp;приложениями, чтобы сделать коммит или получить изменения с&nbsp;сервера.</p>
<p>Кроме того, мы&nbsp;не&nbsp;затронули целый ряд полезных тем, касающихся работы с&nbsp;репозиториями. Поэтому предлагаем вам изучить их&nbsp;самостоятельно.</p>
<ol>
<li><a class="material__link" href="https://help.github.com/articles/working-with-forks/" target="_blank" rel="noopener noreferrer">Форки</a> в&nbsp;GitHub&nbsp;&mdash; очень мощный инструмент для работы с&nbsp;публичными репозиториями, популярный в&nbsp;opensource community</li>
<li><a class="material__link" href="https://habrahabr.ru/post/161009/" target="_blank" rel="noopener noreferrer">Rebase</a>&nbsp;&mdash; еще один очень популярный способ объединения изменений, удобный при работе над достаточно большими фичами</li>
<li><a class="material__link" href="http://marklodato.github.io/visual-git-guide/index-ru.html" target="_blank" rel="noopener noreferrer">Cherry-pick и&nbsp;reset</a>&nbsp;&mdash; инструменты для работы с&nbsp;историей коммитов: извлечением какого-либо коммита, или откатом последних коммитов</li>
<li>Так&nbsp;же мы&nbsp;рекомендуем пошаговый <a class="material__link" href="https://githowto.com/ru" target="_blank" rel="noopener noreferrer">самоучитель</a> по&nbsp;Git для закрепления пройденного материала</li>
</ol>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>