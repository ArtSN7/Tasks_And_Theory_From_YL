<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | PyQT. Диалоги, работа с изображениями </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок QT Диалоги</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>PyQT. Диалоги, работа с&nbsp;изображениями</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">QPixmap</a></li>
<li><a class="material__link" href="#2">Диалоговые окна для выбора файла</a></li>
<li><a class="material__link" href="#3">Диалоги ввода информации</a></li>
<li><a class="material__link" href="#4">Рисование</a></li>
<li><a class="material__link" href="#5">L-системы</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;этом уроке мы&nbsp;рассмотрим возможности PyQT по&nbsp;отображению графических данных, а&nbsp;также изучим возможности рисования непосредственно на&nbsp;виджетах библиотеки.</p>
</section>
<section class="material__chapter">
<h2 id="1">QPixmap</h2>
<p>До&nbsp;сих пор мы&nbsp;работали только с&nbsp;текстовой информацией, однако, как нам подсказывает здравый смысл (и&nbsp;материалы уроков про библиотеки в&nbsp;Python), в&nbsp;файлах может храниться не&nbsp;только текст, но&nbsp;и&nbsp;различные более сложные данные, например: изображения, видео или аудиозаписи. В&nbsp;этом уроке мы&nbsp;познакомимся с&nbsp;возможностями PyQT, позволяющими работать с&nbsp;графикой.</p>
<p>Одним из&nbsp;способов отображения изображения является использование <strong>QPixmap</strong>. Напишем простейшую программу, которая будет демонстрировать заданную картинку.</p>
<pre><code class="language-python">import sys

from PyQt5.QtGui import QPixmap
from PyQt5.QtWidgets import QApplication, QLabel, QMainWindow

SCREEN_SIZE = [400, 400]


class Example(QMainWindow):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(400, 400, *SCREEN_SIZE)
        self.setWindowTitle('Отображение картинки')

        ## Изображение
        self.pixmap = QPixmap('orig.jpg')
        # Если картинки нет, то QPixmap будет пустым, 
        # а исключения не будет
        self.image = QLabel(self)
        self.image.move(80, 60)
        self.image.resize(250, 250)
        # Отображаем содержимое QPixmap в объекте QLabel
        self.image.setPixmap(self.pixmap)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Хотя раньше мы&nbsp;передавали размеры экрана напрямую в&nbsp;функцию, можно использовать список или какую-то другую структуру для хранения этих данных. Это может пригодиться в&nbsp;том случае, если у&nbsp;вас в&nbsp;программе много окон разного размера, или при повторном открытии окна необходимо восстановить его предыдущий размер.</p>
<p>Обратите ваше внимание на&nbsp;следующий факт: <var>QPixmap</var> не&nbsp;используется для &laquo;показывания&raquo; изображения. В&nbsp;нем только хранится объект&nbsp;&mdash; картинка. Для отображения используется уже знакомый нам <var>QLabel</var>, в&nbsp;который с&nbsp;помощью метода <var>setPixmap</var> загружается наш объект.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-1.png" width="402" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="2">Диалоговые окна для выбора файла</h2>
<p>Но&nbsp;что делать, если мы&nbsp;хотим написать программу, которая позволяет открывать несколько файлов? Менять каждый раз код программы&nbsp;&mdash; неоптимально. Использовать <code>input()</code> для ввода имени файла? Но&nbsp;мы&nbsp;же работаем с&nbsp;графическим интерфейсом. Разместить на&nbsp;форме <var>QLineEdit</var>, как мы&nbsp;делали на&nbsp;предыдущих занятиях? Выглядит как выход, но&nbsp;это неудобно по&nbsp;нескольким причинам:</p>
<ul>
<li>Путь к&nbsp;файлу может быть очень длинным и&nbsp;пользователю будет неудобно его вводить. Да&nbsp;и&nbsp;вообще пользователь может с&nbsp;ходу не&nbsp;знать, где находится нужный файл</li>
<li>Пользователь может часто ошибаться при вводе, и&nbsp;нам придется обрабатывать эти ошибки</li>
</ul>
<p>Чтобы повысить удобство для пользователей и&nbsp;минимизировать ошибки ввода, были придуманы так называемые <strong>Диалоговые окна</strong>, которые мы&nbsp;сейчас и&nbsp;попробуем использовать.</p>
<p>Диалоговые окна нужны для того, чтобы получить какую-либо информацию от&nbsp;пользователя. Это может быть текстовая информация, цвет, настройки шрифта и&nbsp;даже файлы. В&nbsp;PyQT уже есть встроенные виджеты, реализующие различные диалоговые окна.</p>
<p>Будем получать путь к&nbsp;файлу с&nbsp;помощью <strong>QFileDialog</strong>. Важно не&nbsp;забыть импортировать этот виджет из&nbsp;<strong>PyQt5.QtWidgets</strong>.</p>
<p>Добавим в&nbsp;функцию загрузки из&nbsp;первой программы следующую строку:</p>
<pre><code class="language-python">fname = QFileDialog.getOpenFileName(self, 'Выбрать картинку', '')[0]
</code></pre>
<p>И&nbsp;будем передавать в&nbsp;<var>QPixmap</var> не&nbsp;имя файла, а&nbsp;переменную <var>fname</var>. Посмотрим, что будет происходить.</p>
<p>Перед запуском программы открывается окно выбора файла.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-2.png" width="680" height="auto" /></div>
<p>После выбора файла (после нажатия кнопки &laquo;Открыть&raquo;), диалог закроется и откроется наша форма с выбранным изображением.</p>
<p>Давайте разберем, какие основные параметры можно передать в&nbsp;метод <var>getOpenFileName</var> диалога работы с файлами, для получения имени файла:</p>
<ol>
<li>Родительский виджет (наш виджет формы)</li>
<li>Заголовок окна. В&nbsp;нашем случае это &laquo;Выбрать картинку&raquo;. Интересный факт: этот заголовок будет отображаться только в&nbsp;Windows и&nbsp;некоторых окружениях рабочего стола в&nbsp;Linux, а&nbsp;в&nbsp;macOS будет игнорироваться</li>
<li>Директория открытия&nbsp;&mdash; папка, содержимое которой будет отображаться при открытии диалога. Можно даже дописать имя файла, который будет предлагаться к&nbsp;открытию. Если передать пустые кавычки, поиск начнется в&nbsp;той&nbsp;же папке, где лежит запускаемый нами скрипт</li>
<li>Набор фильтров. Если ничего не&nbsp;передать, будет применен фильтр &rsquo;All Files (*)&rsquo;, который отображает все файлы в&nbsp;директории. Если нужно отобразить только определенные типы файлов, можно это указать строкой вида: &rsquo;Картинка (.jpg);;Картинка (.jpg);;Все файлы (*)&rsquo;. Так мы&nbsp;дадим пользователю выбирать, какие типы файлов он&nbsp;хочет отображать в&nbsp;папке. Разные фильтры отделяются &rsquo;;;&rsquo;.</li>
</ol>
<pre><code class="language-python">fname = QFileDialog.getOpenFileName(
    self, 'Выбрать картинку', '',
    'Картинка (*.jpg);;Картинка (*.png);;Все файлы (*)')[0]
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-4-filter.png" width="251" height="auto" /></div>
<p>Остальные параметры метода можно посмотреть в&nbsp;<a class="material__link" href="https://doc.qt.io/qt-5/qfiledialog.html#getOpenFileName" target="_blank" rel="noopener noreferrer">документации</a>.</p>
<p>Обратите внимание: эта функция возвращает кортеж, состоящий из&nbsp;полного пути к&nbsp;файлу, а&nbsp;также выбранный фильтр (по&nbsp;умолчанию&nbsp;&mdash; &rsquo;All Files (*)&rsquo;)</p>
</section>
<section class="material__chapter">
<h2 id="3">Диалоги ввода информации</h2>
<p>Кроме диалога, позволяющего выбрать файл, существуют и&nbsp;другие.</p>
<p>Рассмотрим виджет <strong>QInputDialog</strong>. Особенность этого виджета в&nbsp;том, что его можно настроить на&nbsp;получение различных типов данных: строки (одной или нескольких), числа или одного значения из&nbsp;списка, вызывая различные методы.</p>
<p>Напишем программу, которая получает имя пользователя с&nbsp;помощью диалогового окна.</p>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import QWidget, QApplication, QPushButton
from PyQt5.QtWidgets import QInputDialog


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 150, 150)
        self.setWindowTitle('Диалоговые окна')

        self.button_1 = QPushButton(self)
        self.button_1.move(20, 40)
        self.button_1.setText("Кнопка")
        self.button_1.clicked.connect(self.run)

    def run(self):
        name, ok_pressed = QInputDialog.getText(self, "Введите имя", 
                                                "Как тебя зовут?")
        if ok_pressed:
            self.button_1.setText(name)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec_())
</code></pre>
<p>В&nbsp;методе, вызываемой нажатием на&nbsp;кнопку, создается диалоговое окно (<var>QInputDialog</var>) и&nbsp;указывается, какой тип оно будет возвращать (<var>getText</var>). В&nbsp;качестве параметров передаются родительское окно (<var>self</var>), заголовок нового окна и&nbsp;сообщение для пользователя. Возвращает эта функция кортеж, где на&nbsp;первом месте записаны введенные пользователем данные (или пустая строка, если нажата кнопка &laquo;Отмена&raquo;), а&nbsp;на&nbsp;втором&nbsp;&mdash; состояние кнопки &laquo;Ok&raquo;.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-3.png" width="199" height="auto" /></div>
<p>В&nbsp;случае если мы&nbsp;хотим получить целое число, лучше воспользоваться методом <code>getInt()</code>, в&nbsp;котором мы&nbsp;можем указать значение по&nbsp;умолчанию, минимальное значение, максимальное значение и&nbsp;шаг.</p>
<pre><code class="language-python">age, ok_pressed = QInputDialog.getInt(
    self, "Введите возраст", "Сколько тебе лет?",
    20, 18, 27, 1)
</code></pre>
<p>В&nbsp;этом примере значение по&nbsp;умолчанию&nbsp;&mdash; 20, минимальное значение&nbsp;&mdash; 18, максимальное&nbsp;&mdash; 27, а&nbsp;шаг&nbsp;&mdash; 1.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-4.png" width="199" height="auto" /></div>
<p>Иногда нам нужно, чтобы пользователь выбрал какое-то значение из&nbsp;предоставленных. Для этого есть метод <var>getItem</var>.</p>
<pre><code class="language-python">country, ok_pressed = QInputDialog.getItem(
    self, "Выберите вашу страну", "Откуда ты?", 
    ("Россия", "Германия", "США"), 1, False)
</code></pre>
<p>В&nbsp;качестве параметров необходимо указать: родителя, заголовок окна, вопрос, итерируемый объект с&nbsp;вариантами ответа и&nbsp;индекс значения по&nbsp;умолчанию. А&nbsp;чтобы пользователь не&nbsp;смог что-то самостоятельно ввести, укажем следующим параметром False.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-5.png" width="199" height="auto" /></div>
<p>Для выбора цвета существует другой виджет&nbsp;&mdash; <strong>QColorDialog</strong>. Вот пример программы с&nbsp;его использованием:</p>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import QWidget, QApplication, QPushButton
from PyQt5.QtWidgets import QColorDialog


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 150, 150)
        self.setWindowTitle('Диалоговые окна')

        self.button_1 = QPushButton(self)
        self.button_1.move(20, 40)
        self.button_1.setText("Кнопка")
        self.button_1.clicked.connect(self.run)

    def run(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.button_1.setStyleSheet(
                "background-color: {}".format(color.name()))


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Если цвет валиден, фон кнопки окрасится в&nbsp;него. Функция <code>.name()</code> возвращает цвет в&nbsp;шестнадцатитиричном формате. Управлять стилями элементов достаточно просто, синтаксис похож на&nbsp;CSS, с&nbsp;которым вы&nbsp;должны были познакомиться во&nbsp;время изучения HTML.</p>
<p>Примеры можно посмотреть в&nbsp;<a class="material__link" href="https://doc.qt.io/qtforpython/overviews/stylesheet-examples.html" target="_blank" rel="noopener noreferrer">документации</a>.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-6.png" width="522" height="auto" /></div>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-7.png" width="152" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="4">Рисование</h2>
<p>До&nbsp;этого момента, чтобы создать и&nbsp;вывести какое-либо изображение, надо было создавать картинку с&nbsp;помощью PIL, а&nbsp;затем выводить&nbsp;ее, используя виджет <var>QPixmap</var>. Но&nbsp;в&nbsp;PyQT есть модули, которые позволяют рисовать прямо на&nbsp;самих виджетах. Посмотрим, как с&nbsp;ними работать.</p>
<pre><code class="language-python">import sys

from PyQt5.QtGui import QPainter, QColor
from PyQt5.QtWidgets import QWidget, QApplication


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 200, 200)
        self.setWindowTitle('Рисование')

    # Метод срабатывает, когда виджету надо 
    # перерисовать свое содержимое, 
    # например, при создании формы
    def paintEvent(self, event):
        # Создаем объект QPainter для рисования
        qp = QPainter()
        # Начинаем процесс рисования
        qp.begin(self)
        self.draw_flag(qp)
        # Завершаем рисование
        qp.end()

    def draw_flag(self, qp):
        # Задаем кисть
        qp.setBrush(QColor(255, 0, 0))
        # Рисуем прямоугольник заданной кистью
        qp.drawRect(30, 30, 120, 30)
        qp.setBrush(QColor(0, 255, 0))
        qp.drawRect(30, 60, 120, 30)
        qp.setBrush(QColor(0, 0, 255))
        qp.drawRect(30, 90, 120, 30)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-8.png" width="242" height="auto" /></div>
<p>Заметьте: все работает, несмотря на&nbsp;то, что мы&nbsp;явно нигде не&nbsp;вызываем метод <code>paintEvent()</code>. Этот метод вызывается автоматически в&nbsp;те&nbsp;моменты, когда виджет понимает, что ему надо обновить свой внешний вид, например, при создании формы. Кроме того, в&nbsp;качестве параметра присутствует некий <var>event</var>&nbsp;&mdash; событие. Это событие, на&nbsp;которое подвешивается обработчик, например: движение, нажатие или отпускание кнопки мыши, нажатие или отпускание клавиши клавиатуры и&nbsp;многое другое.</p>
<p>В&nbsp;методе <var>paintEvent()</var> происходит инициализация экземпляра класса <var>QPainter</var>, который отвечает за&nbsp;рисование на&nbsp;виджетах. Рисовать нужно между вызовами методов <var>begin</var> и&nbsp;<var>end</var>.</p>
<p>В&nbsp;методе <var>drawFlag()</var> происходит непосредственно рисование. С&nbsp;помощью метода <var>setBrush</var> мы&nbsp;задаем цвет кисти в&nbsp;формате RGB. Этот метод принимает на&nbsp;вход не&nbsp;кортеж цветовых компонент, а&nbsp;экземпляр класса <var>QColor</var>. А&nbsp;он&nbsp;уже, в&nbsp;свою очередь, при создании может принимать цветовые компоненты RGB. Подробнее про возможности <var>QColor</var> можно посмотреть в&nbsp;<a class="material__link" href="https://doc.qt.io/qt-5/qcolor.html" target="_blank" rel="noopener noreferrer">документации</a>.</p>
<p>Кроме метода <code>setBrush()</code>, у&nbsp;<var>QPainter</var> есть еще метод <code>setPen()</code>, который также принимает в&nbsp;качестве параметра объект <var>QColor</var>. Разница в&nbsp;том, что кисть задает цвет заливки, а&nbsp;ручка&nbsp;&mdash; цвет обводки.</p>
<p>Сам процесс рисования очень похож на&nbsp;тот, с&nbsp;каким мы&nbsp;сталкивались при изучении библиотеки Pillow. Например, чтобы нарисовать прямоугольник, применяем метод <code>drawRect()</code>. В&nbsp;качестве параметров ему передаются координаты левого верхнего угла, длина и&nbsp;высота. Как и&nbsp;в&nbsp;Pillow, существуют различные методы для рисования разных графических объектов, например:</p>
<ul>
<li><code>drawArc()</code>&nbsp;&mdash; для рисования дуги</li>
<li><code>drawEllipse()</code>&nbsp;&mdash; для эллипсов</li>
<li><code>drawLine()</code>&nbsp;&mdash; для линий</li>
<li><code>drawPolygon()</code>&nbsp;&mdash; для многоугольников</li>
<li><code>drawText()</code>&nbsp;&mdash; для текста</li>
</ul>
<p>Подробнее про эти и&nbsp;другие методы <var>QPainter</var> можно почитать в&nbsp;<a class="material__link" href="https://doc.qt.io/qt-5/qpainter.html" target="_blank" rel="noopener noreferrer">документации</a>.</p>
<p><strong>Важное замечание:</strong> библиотека PyQT устроена таким образом, что рисовать можно <strong>только</strong> внутри <code>paintEvent()</code>, а&nbsp;сам <code>paintEvent()</code> вызывается не&nbsp;по&nbsp;всем событиям, например, нажатие кнопки само по&nbsp;себе не&nbsp;приводит с&nbsp;появлению сигнала на&nbsp;перерисовку. Но&nbsp;есть и&nbsp;хорошие новости: никто не&nbsp;запрещает вам рисовать в&nbsp;другом месте, например, на&nbsp;<var>QPixmap</var>, а&nbsp;потом отображать результат, как мы&nbsp;рассматривали в&nbsp;первом примере этого урока. Кроме того, вы&nbsp;в&nbsp;любой момент можете принудительно заставить форму перерисоваться, для этого надо вызвать у&nbsp;нее метод <code>update()</code> или <code>repaint()</code>.</p>
<p>Давайте немного изменим предыдущий пример, чтобы рисование происходило только после нажатия на&nbsp;кнопку:</p>
<pre><code class="language-python">import sys

from PyQt5.QtGui import QPainter, QColor
from PyQt5.QtWidgets import QWidget, QApplication, QPushButton


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 200, 200)
        self.setWindowTitle('Рисование')
        self.btn = QPushButton('Рисовать', self)
        self.btn.move(70, 150)
        self.do_paint = False
        self.btn.clicked.connect(self.paint)

    def paintEvent(self, event):
        if self.do_paint:
            qp = QPainter()
            qp.begin(self)
            self.draw_flag(qp)
            qp.end()

    def paint(self):
        self.do_paint = True
        self.repaint()

    def draw_flag(self, qp):
        qp.setBrush(QColor(255, 0, 0))
        qp.drawRect(30, 30, 120, 30)
        qp.setBrush(QColor(0, 255, 0))
        qp.drawRect(30, 60, 120, 30)
        qp.setBrush(QColor(0, 0, 255))
        qp.drawRect(30, 90, 120, 30)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/paintbutton1.gif" width="205" height="auto" /></div>
<p>Рассмотрим еще один пример: напишем программу, которая будет рисовать пятиконечную звездочку. Для этого необходимо рассчитать точки. Пятиконечная звезда получается из&nbsp;правильного пятиугольника, если соединять точки через одну. Так что сначала нарисуем пятиугольник, а&nbsp;затем&nbsp;&mdash; звезду. Важно помнить, что наши координаты, в&nbsp;которых мы&nbsp;привыкли работать, могут не&nbsp;совпадать с&nbsp;экранными.</p>
<p>Для начала напишем функции, которые будут пересчитывать координаты в&nbsp;экранные.</p>
<pre><code class="language-python">def xs(self,x):
    return x + SCREEN_SIZE[0] // 2


def ys(self,y):
    return SCREEN_SIZE[1] // 2 - y
</code></pre>
<p>А&nbsp;теперь вместо метода <var>draw_flag()</var> напишем метод <var>draw_star()</var>. Для его&nbsp;работы, кроме тех модулей, про которые мы&nbsp;говорили выше, нам понадобятся объекты следующих модулей: <var>Qt</var>, <var>QPen</var>, <var>math</var>. Так что важно не&nbsp;забыть импортировать&nbsp;их.</p>
<pre><code class="language-python">import sys
from math import cos, pi, sin

from PyQt5.QtCore import Qt
from PyQt5.QtGui import QPainter, QPen
from PyQt5.QtWidgets import QWidget, QApplication

SCREEN_SIZE = [500, 500]
# Задаём длину стороны и количество углов
SIDE_LENGTH = 200
SIDES_COUNT = 5


class DrawStar(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, *SCREEN_SIZE)
        self.setWindowTitle('Рисуем звезду')

    def paintEvent(self, event):
        qp = QPainter()
        qp.begin(self)
        self.draw_star(qp)
        qp.end()

    def xs(self, x):
        return x + SCREEN_SIZE[0] // 2

    def ys(self, y):
        return SCREEN_SIZE[1] // 2 - y

    def draw_star(self, qp):

        # Считаем координаты и переводим их в экранные
        nodes = [(SIDE_LENGTH * cos(i * 2 * pi / SIDES_COUNT),
                  SIDE_LENGTH * sin(i * 2 * pi / SIDES_COUNT))
                 for i in range(SIDES_COUNT)]
        nodes2 = [(int(self.xs(node[0])),
                   int(self.ys(node[1]))) for node in nodes]

        # Рисуем пятиугольник
        for i in range(-1, len(nodes2) - 1):
            qp.drawLine(*nodes2[i], *nodes2[i + 1])

        # Изменяем цвет линии
        pen = QPen(Qt.red, 2)
        qp.setPen(pen)

        # Рисуем звезду
        for i in range(-2, len(nodes2) - 2):
            qp.drawLine(*nodes2[i], *nodes2[i + 2])


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = DrawStar()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Сначала мы&nbsp;высчитываем координаты и&nbsp;переводим их&nbsp;в&nbsp;экранные. Затем мы&nbsp;используем метод <var>drawLine</var> объекта класса <var>QPainter</var>, в&nbsp;него поступают координаты двух точек, между которыми строится линия. Пройдясь по&nbsp;всем точкам, мы&nbsp;получим пятиугольник. По умолчанию рисование происходит с&nbsp;помощью &laquo;кисти&raquo; черного цвета и&nbsp;с&nbsp;толщиной, равной единице. Создадим новую кисть <code>pen = QPen(Qt.red, 2)</code> и&nbsp;применим&nbsp;ее. А&nbsp;затем, пробегаясь по&nbsp;тем&nbsp;же точкам, но&nbsp;через одну, получим изображение звезды.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-res-4-9.png" width="402" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="5">L-системы</h2>
<p>В&nbsp;1968&nbsp;г. венгерский биолог и&nbsp;ботаник <a class="material__link" href="https://ru.wikipedia.org/wiki/Линденмайер,_Аристид" target="_blank" rel="noopener noreferrer">Аристид Линденмайер</a> (Aristid Lindenmayer) предложил математическую модель для изучения развития простых многоклеточных организмов, которая позже была расширена и&nbsp;используется для моделирования сложных ветвящихся структур&nbsp;&mdash; разнообразных деревьев и&nbsp;цветов.</p>
<p>Эта модель получила название Lindenmayer System, или просто L-System. Свои идеи Линденмайер изложил в&nbsp;книге &laquo;Алгоритмическая красота растений&raquo; (The Algorithmic Beauty of&nbsp;Plants).</p>
<p>Идею можно объяснить так: сложный объект получается из&nbsp;простого с&nbsp;помощью перезаписи частей этого простого объекта по&nbsp;определенным ранее правилам. L-система является частным случаем фракталов.</p>
<p>Представьте, что вы&nbsp;&mdash; художник. Но&nbsp;у&nbsp;вас есть только карандаш, поле для творчества&nbsp;&mdash; лист бумаги, и&nbsp;вы&nbsp;умеете выполнять только определенный набор команд (например, &laquo;поставить карандаш на&nbsp;бумагу&raquo;, &laquo;поднять карандаш в&nbsp;воздух&raquo;, &laquo;нарисовать линию&raquo;, &laquo;повернуться на&nbsp;угол&raquo; и&nbsp;т.д.) Для того чтобы нарисовать на&nbsp;листе бумаги картину, вы&nbsp;получаете задание&nbsp;&mdash; строку символов, которую вам готовит L-автомат. Назовем эту строку <strong>L-строкой</strong>.</p>
<p>Итак, первый этап решения задачи&nbsp;&mdash; формирование L-строки, второй&nbsp;&mdash; построение по&nbsp;этой строке рисунка.</p>
<p>L-автомат не&nbsp;может сформировать L-строку &laquo;из&nbsp;неоткуда&raquo;. Поэтому, у&nbsp;него есть <strong>аксиома</strong>&nbsp;&mdash; строка, которая определяет начало эволюции. Для дальнейшего развития L-автомат использует <strong>теоремы</strong>&nbsp;&mdash; правила, по&nbsp;которым и&nbsp;будет происходить преобразование L-строки.</p>
<p>Чтобы построить L-систему мы&nbsp;определим символы, которыми кодируется L-строка и&nbsp;опишем действия, которые производит художник, обрабатывая любой из&nbsp;символов.</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse;" border="1" cellpadding="5px">
<tbody>
<tr>
<th>Символ</th>
<th>Действие</th>
</tr>
<tr>
<td>F</td>
<td>Начертить отрезок из&nbsp;точки, в&nbsp;которой находится карандаш под текущим углом, и&nbsp;остаться в&nbsp;новой точке.</td>
</tr>
<tr>
<td>f</td>
<td>Перенести карандаш из&nbsp;точки под текущим углом и&nbsp;остаться в&nbsp;новой точке, но&nbsp;не&nbsp;чертить отрезок.</td>
</tr>
<tr>
<td>+</td>
<td>Повернуться на&nbsp;заданный угол по&nbsp;часовой стрелке.</td>
</tr>
<tr>
<td>-</td>
<td>Повернуться на&nbsp;заданный угол против часовой стрелки.</td>
</tr>
<tr>
<td>[</td>
<td>Сохранить текущее состояние карандаша.</td>
</tr>
<tr>
<td>]</td>
<td>Вернуться в&nbsp;предыдущее сохраненное состояние карандаша.</td>
</tr>
<tr>
<td>|</td>
<td>Повернуться на&nbsp;180&nbsp;градусов.</td>
</tr>
</tbody>
</table>
</div>
<p>Необходимо пояснить некоторые моменты. Что такое <strong>текущий угол</strong> и&nbsp;<strong>состояние карандаша</strong>? Дело в&nbsp;том, что перед построением рисунка мы&nbsp;должны определиться со&nbsp;значением угла, на&nbsp;который мы&nbsp;будем поворачиваться в&nbsp;процессе работы, а&nbsp;под состоянием карандаша мы&nbsp;будем понимать набор из&nbsp;координат карандаша на&nbsp;листе и&nbsp;значения угла. Договоримся, что изначально угол равен нулю, а&nbsp;карандаш расположен в&nbsp;начале координат. Кроме того, надо знать длину шага для рисования.</p>
<p>Мы&nbsp;уже упомянули, что каждая фигура определяется своей аксиомой и&nbsp;набором теорем.</p>
<p>Например, аксиома может быть задана так:</p>
<pre><code>F
</code></pre>
<p>Это означает, что наша система изначально представлена L-строкой F. То&nbsp;есть для того чтобы ее&nbsp;построить, мы&nbsp;возьмем из&nbsp;списка правил действие для строки F и&nbsp;выполним его, то&nbsp;есть построим линию.</p>
<p>Допустим, у&nbsp;нас есть только одна теорема и&nbsp;она выглядит так:</p>
<pre><code>F -&gt; F-F++F-F
</code></pre>
<p>Это означает, что на&nbsp;каждом шаге для получения новой эволюции L-строки мы&nbsp;должны каждый символ&nbsp;F заменить на&nbsp;последовательность: F-F++F-F.</p>
<p>Посмотрите на&nbsp;то, что будет представлять L-строка на&nbsp;первых 3-х шагах алгоритма.</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse;" border="1" cellpadding="5px">
<tbody>
<tr>
<th>Этап</th>
<th>L-строка</th>
</tr>
<tr>
<td>0</td>
<td>F</td>
</tr>
<tr>
<td>1</td>
<td>F-F++F-F</td>
</tr>
<tr>
<td>2</td>
<td>F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F</td>
</tr>
<tr>
<td>3</td>
<td>F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F-F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F-F-F++F-F-F-F++F-F++F-F++F-F-F- F++F-F</td>
</tr>
</tbody>
</table>
</div>
<p>В&nbsp;результате L-автомат будет содержать L-строку, которая описывает заданный фрактал&nbsp;&mdash; кривую Коха.</p>
<p>Вспомним про начальные условия и&nbsp;зададим угол поворота в&nbsp;60&nbsp;градусов.</p>
<p>Нулевой шаг алгоритма, L=F&nbsp;&mdash; рисуем отрезок.</p>
<p>Первый шаг алгоритма, L=F-F++F-F&nbsp;&mdash; рисуем отрезок, затем поворачиваемся против часовой стрелки на&nbsp;60&nbsp;градусов, затем опять рисуем отрезок, затем следует поворот на&nbsp;120 градусов по&nbsp;часовой стрелке, рисование отрезка, поворот на&nbsp;60&nbsp;градусов против часовой стрелки и&nbsp;&mdash; ура&nbsp;&mdash; последний отрезок.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-4-1.png" width="500" height="auto" /></div>
<p>Рассмотрим более сложную L-систему:</p>
<p>Угол: 90 градусов</p>
<p>Аксиома: X</p>
<p>Теоремы:</p>
<p>X =&gt; -YF+XFX+FY-</p>
<p>Y =&gt; +XF-YFY-FX+</p>
<p>В&nbsp;этой L-системе присутствуют символы, которые не&nbsp;входят в&nbsp;перечень действий карандаша. В&nbsp;этом нет ничего страшного. При создании L-строки такие символы будут использованы, а&nbsp;при построении фрактала&nbsp;&mdash; нет, они будут просто проигнорированы.</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse;" border="1" cellpadding="5px">
<tbody>
<tr>
<th>Этап</th>
<th>L-строка</th>
</tr>
<tr>
<td>0</td>
<td>X</td>
</tr>
<tr>
<td>1</td>
<td>-YF+XFX+FY-</td>
</tr>
<tr>
<td>2</td>
<td>-+XF-YFY-FX+F+-YF+XFX+FY-F-YF+XFX+FY-+F+XF-YFY-FX+-</td>
</tr>
</tbody>
</table>
</div>
<p>При построении первого шага&nbsp;мы:</p>
<ol>
<li>Повернемся на 90 градусов против часовой стрелки</li>
<li>Y &ndash; проигнорируем</li>
<li>Нарисуем отрезок</li>
<li>Повернемся на 90 градусов по часовой стрелке</li>
<li>Х &ndash; проигнорируем</li>
<li>Нарисуем отрезок</li>
<li>Опять проигнорируем Х</li>
<li>Повернемся на 90 градусов по часовой стрелке</li>
<li>Нарисуем отрезок</li>
<li>Y &ndash; проигнорируем</li>
<li>Повернемся на 90 градусов против часовой стрелки</li>
</ol>
<p>И&nbsp;в&nbsp;результате получим ... кривую Гильберта. Нужно отметить, что фрактал нулевой глубины в&nbsp;данном случае не&nbsp;имеет картинки, поскольку L-строка содержит символ &laquo;X&raquo;, который никак не&nbsp;отображается. А&nbsp;вот для фрактала пятой глубины получим:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-4-2.gif" width="223" height="auto" /></div>
<p>Остановимся немного на&nbsp;поворотах. Допустим ваш карандаш находится в&nbsp;точке с&nbsp;координатами (x<sub>0</sub>, y<sub>0</sub>), а&nbsp;текущий угол&nbsp;&mdash; &alpha;. Пусть длина шага равна&nbsp;&mdash; l. Тогда координаты карандаша после окончания рисования можно вычислить по&nbsp;следующим формулам:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-4-3.png" width="177" height="auto" /></div>
<p>При этом углы должны быть указаны в&nbsp;<strong>радианах</strong>. Если&nbsp;же мы&nbsp;указываем углы в&nbsp;градусах, то&nbsp;формулы приобретают следующий вид:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-4/qt-4-4.png" width="195" height="auto" /></div>
<p>Поворот на&nbsp;определенный угол сводится к&nbsp;следующему:</p>
<pre><code class="language-python">alpha = (alpha + phi) % 360
</code></pre>
<p>Все необходимые функции: синус, косинус, перевод градусов в&nbsp;радианы и&nbsp;обратно&nbsp;&mdash; можно найти в&nbsp;модуле math, который входит в&nbsp;стандартную библиотеку.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>