<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Библиотеки unittest и pytest </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок unittest pytest</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Библиотеки unittest и&nbsp;pytest</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Повторение: зачем нужны библиотеки для тестирования</a></li>
<li><a class="material__link" href="#2">Библиотека unittest</a></li>
<li><a class="material__link" href="#3">Библиотека pytest</a></li>
<li><a class="material__link" href="#4">Общие рекомендации о&nbsp;том, как писать тесты</a></li>
<li><a class="material__link" href="#5">Резюме</a></li>
<li><a class="material__link" href="#6">Бонус. Библиотека doctest</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке мы&nbsp;рассмотрим инструменты языка Python для тестирования: библиотеки unittest и&nbsp;pytest. С&nbsp;их&nbsp;помощью мы&nbsp;научимся писать гибкие и&nbsp;автоматизированные тесты.</p>
</section>
<section class="material__chapter">
<h2 id="1">Повторение: зачем нужны библиотеки для тестирования</h2>
<p>На&nbsp;прошлом уроке мы&nbsp;узнали, что такое юнит-тестирование. Оказалось, что тестировать свои программы очень полезно, но&nbsp;не&nbsp;так уж&nbsp;и&nbsp;просто:</p>
<ul>
<li><strong>Тесты должны быть гибкими.</strong> Нужно тестировать самые разные случаи: не&nbsp;только правильность возвращаемых значений, но&nbsp;и, например, исключения</li>
<li><strong>Тесты должны быть простыми.</strong> Если код теста сложен, то&nbsp;в&nbsp;нем легко ошибиться. К&nbsp;тому&nbsp;же, тесты&nbsp;&mdash; это еще и&nbsp;неявный способ документирования кода</li>
<li><strong>Тесты должны быть автоматизированными.</strong> Запуск ста тестов должен быть таким&nbsp;же простым, как и&nbsp;запуск одного</li>
<li>Отчет о&nbsp;непройденных тестах должен быть удобным и&nbsp;подробным, чтобы легко понять, где именно ошибка</li>
</ul>
<p>Сегодня мы&nbsp;познакомимся с&nbsp;библиотеками, которые позволяют писать гибкие, простые и&nbsp;автоматизированные тесты.</p>
</section>
<section class="material__chapter">
<h2 id="2">Библиотека unittest</h2>
<p>unittest&nbsp;&mdash; стандартная библиотека Python для unit-тестирования. Ей&nbsp;пользуются не&nbsp;очень часто, потому что pytest, речь о&nbsp;которой пойдет чуть ниже, завоевала сердца абсолютного большинства тех, кто пишет тесты на&nbsp;Python (а&nbsp;к&nbsp;тому&nbsp;же еще она совместима с&nbsp;тестами, которые написаны для unittest), но, тем не&nbsp;менее, было&nbsp;бы несправедливо обойти вниманием этот инструмент.</p>
<p>Давайте узнаем, как устроено тестирование с&nbsp;помощью этой библиотеки на&nbsp;примере функции <code>reverse()</code> из&nbsp;предыдущего урока. Поместим функцию в&nbsp;отдельный файл reverse.py и&nbsp;подключим его к&nbsp;тестирующему модулю.</p>
<pre><code class="language-python"># Тестируемая функция
def reverse(s):
    if type(s) != str:
        raise TypeError('Expected str, got {}'.format(type(s)))

    return s[::-1]
</code></pre>
<p>В&nbsp;тестирующем модуле сначала подключим библиотеку unittest, а&nbsp;затем из&nbsp;файла reverse.py импортируем функцию <var>reverse</var>.</p>
<pre><code class="language-python">import unittest
from reverse import reverse
</code></pre>
<p>Для каждого тестируемого компонента (в&nbsp;нашем случае&nbsp;&mdash; функции <code>reverse()</code>) нужно реализовать класс-наследник от&nbsp;<var>unittest.TestCase</var>. Методы этого класса, название которых начинается с&nbsp;<var>test_</var>, и&nbsp;будут тестами. У&nbsp;базового класса <var>unittest.TestCase</var> есть встроенные методы для проверки возвращаемых значений&nbsp;&mdash; в&nbsp;частности, метод <var>assertEqual</var>, который проверяет, соответствует&nbsp;ли полученное значение ожидаемому.</p>
<pre><code class="language-python">class TestReverse(unittest.TestCase):
    def test_empty(self):
        self.assertEqual(reverse(''), '')
</code></pre>
<p>Обратите внимание, что название метода <var>test_empty</var> подсказывает нам, какой именно случай тестируется (пустая строка).</p>
<p>Тестирование исключений через unittest делается с&nbsp;помощью метода <var>assertRaises</var>. Это менеджер контекста, который принимает на&nbsp;вход один аргумент&nbsp;&mdash; ожидаемое исключение (в&nbsp;нашем случае это <var>TypeError</var>):</p>
<pre><code class="language-python">def test_wrong_type(self):
    with self.assertRaises(TypeError):
        reverse(42)
</code></pre>
<p>Автоматизировать тестирование просто: в&nbsp;конце программы нужно дописать</p>
<pre><code class="language-python">if __name__ == '__main__':
     unittest.main()
</code></pre>
<p>и&nbsp;сохранить весь код в&nbsp;файл с&nbsp;расширением .py (например, в&nbsp;unittest_simple.py). Запускается так&nbsp;же, как обычная программа на&nbsp;Python.</p>
<pre><samp>&gt;python files/unittest_simple.py
-----------------------------------------------------------
 Ran 2 tests in 0.000s
 OK</samp></pre>
<p>Два теста (мы&nbsp;описали два метода в&nbsp;классе <var>TestReverse</var>) прошли успешно.</p>
</section>
<section class="material__chapter">
<h2 id="3">Библиотека pytest</h2>
<p>По&nbsp;сравнению с&nbsp;unittest, тесты pytest синтаксически проще. Вот пример такого теста:</p>
<pre><code class="language-python"># Тестируемая функция
def reverse(s):
    if type(s) != str:
        raise TypeError('Expected str, got {}'.format(type(s)))

    return s[::-1]


# Обязательно начинайте тест с префикса 'test_'
def test_reverse():
    assert reverse('abc') == 'cba'
</code></pre>
<p>Код теста&nbsp;&mdash; это обычная функция на&nbsp;Python. Для сравнения возвращаемого значения с&nbsp;ожидаемым используется конструкция <var>assert</var>.</p>
<p>Запускается тест из&nbsp;командной строки с&nbsp;помощью специальной утилиты pytest, которая устанавливается вместе с&nbsp;библиотекой.</p>
<pre><samp>pytest files/pytest_simple.py
======================== test session starts =========================
platform darwin -- Python 3.6.2, pytest-3.2.1, py-1.4.34, pluggy-0.4.0
rootdir: /materials/additional/tests, inifile:
collected 1 item
    
files/pytest_simple.py .
    
====================== 1 passed in 0.01 seconds ======================</samp></pre>
<p>Запуск программы pytest_simple.py из&nbsp;консоли с&nbsp;помощью python или из&nbsp;вашей IDE ни&nbsp;к&nbsp;чему не&nbsp;приведет. В&nbsp;этой программе нет вызова функций или блока <code>if&nbsp;__name__ == "__main__"</code>:</p>
<pre><samp>python files/pytest_simple.py</samp></pre>
<p>Утилита pytest анализирует код следующим образом:</p>
<ol>
<li>Находит <strong>функции</strong>, названия которых начинаются с&nbsp;<code>test_</code>, и&nbsp;выполняет их&nbsp;как тесты</li>
<li>Находит <strong>классы</strong>, названия которых начинаются с&nbsp;<code>Test</code>. У&nbsp;классов находит <strong>методы</strong>, названия которых начинаются с&nbsp;<code>test_</code>, и&nbsp;выполняет их&nbsp;как тесты</li>
</ol>
<p>Все проверки внутри тестовых функций или методов можно делать с&nbsp;помощью стандартного макроса <var>assert</var>. Для проверки исключений в&nbsp;библиотеке pytest, по&nbsp;аналогии с&nbsp;библиотекой unittest, есть специальный менеджер контекста <code>pytest.raises()</code>. Чтобы использовать его, сперва нужно импортировать библиотеку pytest.</p>
<pre><code class="language-python">import pytest

def test_exception():
    with pytest.raises(ZeroDivisionError):
        1 / 0
</code></pre>
<p>Для автоматизации тестирования с&nbsp;помощью pytest ничего, в&nbsp;общем-то, делать не&nbsp;нужно&nbsp;&mdash; достаточно написать тестовые функции (не&nbsp;забывая, что их&nbsp;название должно начинаться с&nbsp;<code>test_</code>). Утилита pytest способна принимать на&nbsp;вход несколько файлов с&nbsp;тестами, так что для каждой компоненты можно писать тесты в&nbsp;отдельном файле.</p>
<p>Разумеется, это далеко не&nbsp;вся функциональность библиотеки pytest, а&nbsp;только ее&nbsp;крошечная часть. pytest позволяет создавать фикстуры (fixtures)&nbsp;&mdash; специальные функции, которые выполняются до&nbsp;или после непосредственно вызова теста. С&nbsp;помощью фикстур можно, например, сначала залить в&nbsp;базу данных тестовые данные, а&nbsp;после вызова теста удалить&nbsp;их.</p>
<p>Еще одним мощным инструментом являются моки (Mock). С&nbsp;помощью них можно заменять какие-то части вашей программы при тестировании на&nbsp;макеты, которые обладают некоторым фиксированным поведением. Например, можно заменить реальный сервер системы на&nbsp;имитацию, которая возвращает заранее заготовленный ответ.</p>
</section>
<section class="material__chapter">
<h2 id="4">Общие рекомендации о&nbsp;том, как писать тесты</h2>
<p><strong>Какие входные данные нужно тестировать?</strong></p>
<ol>
<li>Тестируйте корректность работы на&nbsp;<strong>неправильных</strong> входных данных. Примеры:
<ul>
<li>Неправильный тип аргумента (число вместо строки)</li>
<li>Некорректное значение (квадратный корень из&nbsp;отрицательного числа или деление на&nbsp;ноль)</li>
</ul>
В&nbsp;этих случаях программа должна выбрасывать <strong>исключение</strong>. При тестировании нужно проверять, что удаляется нужное исключение.</li>
<li>Тестируйте <strong>граничные</strong> случаи. Например:
<ul>
<li>Пустая строка</li>
<li>Пустой список</li>
<li>Ноль и т.&nbsp;д.</li>
</ul>
</li>
<li>Не&nbsp;забывайте протестировать <strong>правильные</strong> входные данные :)</li>
</ol>
<p><strong>Как организовать код тестов?</strong></p>
<ol>
<li>Для каждого компонента заведите свой тестовый класс или отдельный файл. Названия тестовых функций должны отражать смысл теста:
<ul>
<li>Пример плохого названия: <var>test_1</var></li>
<li>Пример хорошего названия: <var>test_palindrome</var></li>
</ul>
</li>
<li>Желательно, чтобы в&nbsp;тестовой функции была ровно одна проверка
<ul>
<li>Пример &laquo;неправильного&raquo; теста функции <code>foo(n)</code> на&nbsp;pytest:</li>
</ul>
<pre><code class="language-python">def test_foo():
    assert foo(0) == 1
    with pytest.raises(TypeError):
        foo('42')
</code></pre>
<ul>
<li>Пример &laquo;правильного&raquo; теста:</li>
</ul>
<pre><code class="language-python">def test_foo_zero():
    assert foo(0) == 1
      
def test_foo_wrong_type():
    with pytest.raises(TypeError):
        foo('42')
</code></pre>
</li>
</ol>
</section>
<section class="material__chapter">
<h2 id="5">Резюме</h2>
<ol>
<li>Мы&nbsp;познакомились с&nbsp;библиотеками unittest и&nbsp;pytest, которые позволяют писать простые, гибкие и&nbsp;автоматизированные тесты</li>
<li>Мы&nbsp;изучили общие рекомендации к&nbsp;написанию тестов:
<ul>
<li>Какие данные тестировать: не&nbsp;только &laquo;ожидаемые&raquo; входные значения, но&nbsp;также неправильные типы и&nbsp;граничные случаи</li>
<li>Как организовывать код тестов: отдельный тестовый класс для каждого компонента, одна проверка в&nbsp;одном тесте</li>
</ul>
</li>
</ol>
</section>
<section class="material__chapter">
<h2 id="6">Бонус. Библиотека doctest</h2>
<p>В&nbsp;разговоре про модульное тестирование стоит упомянуть такой инструмент, как doctest. Эта библиотека, хоть и&nbsp;не&nbsp;обладает слишком обширными возможностями, зачастую бывает удобна для создания простых тестов.</p>
<p>Модуль интересен тем, что тесты на&nbsp;нем выглядят как скопированные фрагменты сеанса из&nbsp;интерактивной строки Python.</p>
<p>Давайте рассмотрим пример функции, которая возвращает квадратный корень из&nbsp;числа. Если аргумент не&nbsp;число, тогда бросается исключение <var>TypeError</var>, а&nbsp;если аргумент меньше нуля&nbsp;&mdash; исключение <var>ValueError</var>. С&nbsp;тестами для doctest такая функция будет выглядеть вот так:</p>
<pre><code class="language-python">def square_root(x):
    """
    &gt;&gt;&gt; square_root(4)
    2.0
    &gt;&gt;&gt; [square_root(x) for x in range(10)]
    [0.0, 1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0]
    &gt;&gt;&gt; square_root(-1)
    Traceback (most recent call last):
        ...
    ValueError: Argument must be greater than 0
    &gt;&gt;&gt; square_root("yandexlyceum")
    Traceback (most recent call last):
        ...
    TypeError: yandexlyceum is not valid int or float value
    """
    if not isinstance(x, int) and not isinstance(x, float):
        raise TypeError(f"{x} is not valid int or float value")
    if x &gt;= 0:
        return x ** 0.5
    else:
        raise ValueError("Argument must be greater than 0")


if __name__ == "__main__":
    import doctest

    doctest.testmod()
</code></pre>
<p>Для того чтобы запустить файл в&nbsp;режиме прохождения тестов, надо в&nbsp;командной строке выполнить команду:</p>
<pre><code>python имя_файла.py -v
</code></pre>
<p>Мы&nbsp;получим вот такой результат:</p>
<pre><samp>Trying:
    square_root(4)
Expecting:
    2.0
ok
Trying:
    [square_root(x) for x in range(10)]
Expecting:
    [0.0, 1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0]
ok
Trying:
    square_root(-1)
Expecting:
    Traceback (most recent call last):
        ...
    ValueError: Argument must be greater than 0
ok
Trying:
    square_root("yandexlyceum")
Expecting:
    Traceback (most recent call last):
        ...
    TypeError: yandexlyceum is not valid int or float value
ok
1 items had no tests:
    __main__
1 items passed all tests:
   4 tests in __main__.square_root
4 tests in 2 items.
4 passed and 0 failed.
Test passed.</samp></pre>
<p>Очевидно, что doctest не&nbsp;подходит для написания сложных тестов, для этого лучше использовать pytest. Но&nbsp;есть сценарии, в&nbsp;которых использование именно этой библиотеки более чем оправдано:</p>
<ul>
<li>Написание тестов для проверки базовой функциональности функций и&nbsp;объектов</li>
<li>Проверка, что документация к&nbsp;функциям правильная и&nbsp;актуальная</li>
<li>Генерация документации по&nbsp;своему модулю с&nbsp;примерами ввода-вывода</li>
</ul>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>