<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Библиотека argparse. Задачи на создание скриптов с ее помощью </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок argparse</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Библиотека argparse. Задачи на&nbsp;создание скриптов с&nbsp;ее&nbsp;помощью</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Повторение</a></li>
<li><a class="material__link" href="#2">Библиотека argparse</a></li>
<li><a class="material__link" href="#3">Модули, импорт модулей из&nbsp;скриптов</a></li>
<li><a class="material__link" href="#4">Заключение</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке мы&nbsp;продолжим работать с&nbsp;командной строкой и&nbsp;разберем возможности библиотеки argparse.</p>
</section>
<section class="material__chapter">
<h2 id="1">Повторение</h2>
<p>На&nbsp;предыдущем занятии мы&nbsp;рассмотрели простой способ работы с&nbsp;данными, которые поступают в&nbsp;программу (скрипт) через параметры командной строки. Однако такой способ не&nbsp;дает нужной гибкости, и&nbsp;в&nbsp;сложных случаях его применять не&nbsp;стоит.</p>
<p>Рассмотрим пример реализации программы, которая ожидает получить в&nbsp;параметрах список чисел в&nbsp;системе счисления с&nbsp;основанием, переданном в&nbsp;параметре <var>base</var> (если он&nbsp;не&nbsp;указан, то&nbsp;подразумевается <em>двоичная</em> система счисления) и&nbsp;переводит их&nbsp;в&nbsp;десятичную. Преобразованный список чисел выводится на&nbsp;экран.</p>
<p>В&nbsp;двоичной системе счисления есть только две цифры&nbsp;&mdash; 0&nbsp;и&nbsp;1, и&nbsp;запись чисел в&nbsp;ней получается существенно длиннее, чем в&nbsp;десятичной.</p>
<pre><code class="language-python">import sys


def print_help(msg=""):
    print(f"Usage: {sys.argv[0]} [-h] [--log LOG] [--base BASE] int [int ...]\n{msg}")


def main(args):
    integers = []
    log_file = ''
    base = 2

    while (args):
        arg = args.pop(0)
        if arg == '-h':
            print_help()
            return None, None
        elif arg == '--base':
            try:
                base = int(args.pop(0))
            except ValueError:
                print_help(f"invalid base value: {arg}")
                return None, None
        elif arg == '--log':
            log_file = args.pop(0)
        else:
            integers.append(arg)

    if not integers:
        print_help('No int args')
        return None, None

    try:
        return list(map(lambda x: int(x, base), integers)), log_file
    except ValueError as e:
        print_help(f"invalid value: {e}")
        return None, None


numbers, log_file = main(sys.argv[1:])

if log_file is None:
    pass
elif log_file == "":
    print(*numbers)
else:
    with open(log_file, "wt") as output:
        print(*numbers, file=output)
</code></pre>
<p>Несколько слов о&nbsp;тексте выше. В&nbsp;функции мы&nbsp;последовательно читаем список переданных параметров, и&nbsp;если получаем служебное значение (<code>-h, --log, --base</code>), то&nbsp;анализируем следующий за&nbsp;ним параметр. Если&nbsp;же мы&nbsp;получаем число, сохраняем его в&nbsp;списке. Когда список заполнен, его преобразуют <var>lambda</var>-функции.</p>
<p>Посмотрим на&nbsp;то, что у&nbsp;нас получилось.</p>
<p>Вызов без параметров:</p>
<pre><samp>python3 files/ex1.py

Usage: files/ex1.py [-h] [--log LOG] [--base BASE] int [int ...]
No int args</samp></pre>
<p>Вызов с&nbsp;правильными параметрами, но&nbsp;без указания основания системы счисления:</p>
<pre><samp>python3 files/ex1.py 110 1 1010

6 1 10</samp></pre>
<p>Вызов с&nbsp;ошибочными параметрами и&nbsp;указанием системы счисления:</p>
<pre><samp>python3 files/ex1.py 147 22 3 --base 3

Usage: files/ex1.py [-h] [--log LOG] [--base BASE] int [int ...]
invalid value: invalid literal for int() with base 3: '147'</samp></pre>
<p>Вызов с&nbsp;правильными параметрами и&nbsp;сохранением в&nbsp;файл:</p>
<pre><samp>python3 files/ex1.py 110 1 1010 --base 3 --log files/work.log</samp></pre>
<p>Вроде&nbsp;бы все работает, но&nbsp;посмотрите, сколько текста мы&nbsp;написали ради трех параметров! А&nbsp;если параметры имеют псевдонимы? Например, для вывода справочной информации по&nbsp;команде можно задавать как параметр <code>-h</code>, так и&nbsp;параметр <code>--help</code>. Что&nbsp;же делать?</p>
<p>Выход из&nbsp;ситуации напрашивается сам собой. Если нужно сделать простую обработку параметров, то&nbsp;используйте список <var>argv</var> из&nbsp;библиотеки sys, но&nbsp;для сложных ситуаций придется искать другой путь.</p>
<p>И&nbsp;в&nbsp;Python есть более легкий, быстрый и&nbsp;надежный способ&nbsp;&mdash; это библиотека argparse.</p>
</section>
<section class="material__chapter">
<h2 id="2">Библиотека argparse</h2>
<p>Попробуем решить нашу задачу иным способом:</p>
<pre><code class="language-python">import argparse
import sys

parser = argparse.ArgumentParser(
    description="convert integers to decimal system")
parser.add_argument('integers', metavar='integers', nargs='+',
                    type=str, help='integers to be converted')
parser.add_argument('--base', default=2, type=int,
                    help='default numeric system')
parser.add_argument('--log', default=sys.stdout, type=argparse.FileType('w'),
                    help='the file where converted data should be written')

args = parser.parse_args()
s = " ".join(map(lambda x: str(int(x, args.base)), args.integers))
args.log.write(s + '\n')
args.log.close()
</code></pre>
<pre><samp>python3 files/ex2.py -h

usage: ex2.py [-h] [--base BASE] [--log LOG] integers [integers ...]
    convert integers to decimal system
 
    positional arguments:
      integers     integers to be converted
 
    optional arguments:
      -h, --help   show this help message and exit
      --base BASE  default numeric system
      --log LOG    the file where converted data should be written</samp></pre>
<pre><samp>python3 files/ex2.py 1 11 111

1 3 7</samp></pre>
<p>Интересно?</p>
<p>Давайте разбираться.</p>
<p>Для парсинга аргументов с&nbsp;помощью argparse требуется импортировать саму библиотеку (дополнительно устанавливать ее&nbsp;не&nbsp;нужно), создать экземпляр объекта <var>ArgumentParser</var> и&nbsp;запустить функцию парсинга <code>parse_args()</code>:</p>
<pre><code class="language-python">import argparse

parser = argparse.ArgumentParser()
parser.parse_args()
</code></pre>
<p>Если запустить эту программу с&nbsp;ключом <code>-h</code>, мы&nbsp;сразу получим справочную информацию.</p>
<pre><samp>python3 files/first_argparse.py -h

usage: first_argparse.py [-h]
    
optional arguments:
  -h, --help  show this help message and exit</samp></pre>
<p>Вот и&nbsp;все, что нужно программе, чтобы начать обрабатывать приходящие в&nbsp;нее аргументы. Таким образом, у&nbsp;нас есть:</p>
<ol>
<li>Документация (которую можно вызвать, передав опцию <code>--help</code> или <code>-h</code>)</li>
<li>Проверка валидности (корректности) аргументов</li>
<li>Сообщения об&nbsp;ошибках при получении невалидных аргументов</li>
</ol>
<p>Но&nbsp;это далеко не&nbsp;все, что может argparse. Скорее всего, раз мы&nbsp;решили им&nbsp;воспользоваться, захотим получить значения других, в&nbsp;том числе и&nbsp;не&nbsp;совсем стандартных аргументов.</p>
<p>Чтобы сообщить парсеру о&nbsp;таких аргументах, у&nbsp;<var>ArgumentParser</var>&rsquo;a есть метод <var>add_argument</var>. Он&nbsp;принимает множество параметров, однако обязательным является только <strong>название</strong> создаваемого аргумента или флага (первый параметр).</p>
<pre><code>ArgumentParser.add_argument(&lt;name or flags&gt; [, help][, metavar][, type]
                                            [,nargs][, default][, action]
                                            [, const][, choices]
                                            [, required][, dest])
</code></pre>
<p>Парсер использует это имя для обозначений переменных, при выводе в&nbsp;справочной информации и&nbsp;т.&nbsp;д. Остальные модификаторы могут потребоваться для реализации более сложных конструкций. Рассмотрим некоторые из&nbsp;них.</p>
<p>Текст подсказки, который показывается при вызове справки, вводится с&nbsp;помощью параметра <var>help</var>. <var>metavar</var> отвечает за&nbsp;название параметра в&nbsp;подсказке (если его не&nbsp;указать, то&nbsp;берется имя из&nbsp;первого аргумента <var>name</var>). <var>type</var> гарантирует, что параметр хранит значения только указанного типа (причем число можно представить в&nbsp;виде строки, но&nbsp;не&nbsp;любую строку можно привести к&nbsp;числу).</p>
<p>При описании свойств аргумента в&nbsp;<var>add_argument</var> можно обозначить ожидаемое количество таких аргументов с&nbsp;помощью <var>nargs</var>. Это число (как 3&nbsp;или&nbsp;7) или строка '+' (которая означает, что элементов должно быть 1&nbsp;или больше), или '?' (может&nbsp;1, а&nbsp;может и&nbsp;не&nbsp;быть), или '*' (любое количество от&nbsp;0&nbsp;до&nbsp;бесконечности).</p>
<p>Еще одним полезным параметром является значение аргумента по&nbsp;умолчанию (программисты говорят <strong>дефолтное</strong> значение, от&nbsp;английского слова default), которое задается с&nbsp;помощью параметра <var>default</var>. Этот параметр может принимать в&nbsp;себя строку, массив, объект (к&nbsp;примеру, <var>sys.stdin</var>) и&nbsp;многое другое.</p>
<pre><code class="language-python">import argparse

parser = argparse.ArgumentParser()
parser.add_argument("arg1")
parser.add_argument("arg2", help="echo this string")
parser.add_argument("int_args", metavar="N", type=int,
                    nargs='+', help="echo some integers")
args = parser.parse_args()

print(args.arg1)
print(args.arg2)
print(args.int_args)
</code></pre>
<pre><samp>python3 files/ex3.py -h

usage: ex3.py [-h] arg1 arg2 N [N ...]
    
positional arguments:
  arg1
  arg2        echo this string
  N           echo some integers

optional arguments:
  -h, --help  show this help message and exit</samp></pre>
<pre><samp>python3 files/ex3.py 'one'    'two' 3 4   17
 
one
two
[3, 4, 17]</samp></pre>
<p>Давайте рассмотрим и&nbsp;проанализируем еще один пример:</p>
<pre><code class="language-python">import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--name")
parser.add_argument("-up", "--up_case", action="store_true",
                    help="convert name to upper register")
parser.add_argument(
    "--number", choices=[0, 1, 2], type=int, default=0,
    help="select number", required=True)
parser.add_argument("--no-name", action="store_const", const="no",
                    dest="name")
args = parser.parse_args()

name = args.name
if (args.up_case):
    name = name.upper()

print(f"The name is {name}. And the number = {args.number}")
</code></pre>
<p>Мы&nbsp;уже встречались с&nbsp;именованными аргументами, то&nbsp;есть такими, для которых расположение в&nbsp;командной строке при вызове программы не&nbsp;играет роли, а&nbsp;важно лишь&nbsp;то, чтобы значение аргумента предварялось его именем (ключом). Примером такого аргумента является, например, <code>--base</code> в&nbsp;самом первом примере этого урока.</p>
<p>Чтобы сообщить argparse о&nbsp;желании использовать именованный аргумент, достаточно вставить знак "-" перед его названием (можно один, можно два, а&nbsp;можно и&nbsp;оба варианта сразу).</p>
<p>В&nbsp;примере выше определен именованный аргумент <var>name</var>. Для него мы&nbsp;не&nbsp;указали ни&nbsp;подсказки (для справки), ни&nbsp;каких-либо других параметров.</p>
<p>Еще у&nbsp;нас есть аргумент <var>up_case</var> (или&nbsp;<var>up</var>), простой флаг, принимающий значение true, если он&nbsp;указан. Такое поведение достигается благодаря параметру <var>action</var> у&nbsp;метода <var>add_argument</var>.</p>
<p>Возможные значения этого параметра:</p>
<ul>
<li><var>store_true</var>&nbsp;&mdash; установить значение true</li>
<li><var>store_false</var> &mdash; установить значение false</li>
<li><var>store_const</var>&nbsp;&mdash; установить значение, указанное в&nbsp;параметре <var>const</var>. При этом параметр <var>dest</var> хранит имя переменной, в&nbsp;которой сохраняется это значение</li>
</ul>
<p>Фраза <code>parser.add_argument("--no-name", action="store_const", const="no", dest="name")</code> расшифровывается так:</p>
<ol>
<li>Создать именованный параметр <var>no-name</var></li>
<li>При его указании проинициализировать переменную с&nbsp;именем <var>name</var> (указано в&nbsp;параметре <var>dest</var>) значением&nbsp;<var>no</var></li>
</ol>
<p>При добавлении аргумента <var>number</var> мы&nbsp;указали параметр <var>choice</var>, что позволило определить возможные значения для аргумента. Параметр <code>required = True</code> указывает на&nbsp;то, что аргумент является обязательным.</p>
<p>Попробуйте самостоятельно поработать с&nbsp;программой выше, поизменять параметры и&nbsp;посмотреть, что получается.</p>
<p>Несколько примеров ее&nbsp;работы:</p>
<pre><samp>python3 files/ex4.py --help

usage: ex4.py [-h] [--name NAME] [-up] --number {0,1,2} [--no-name]
    
optional arguments:
  -h, --help        show this help message and exit
  --name NAME
  -up, --up_case    convert name to upper register
  --number {0,1,2}  select number
  --no-name</samp></pre>
<pre><samp>python3 files/ex4.py -up --no-name

usage: ex4.py [-h] [--name NAME] [-up] --number {0,1,2} [--no-name]
ex4.py: error: the following arguments are required: --number

    An exception has occurred, use %tb to see the full traceback.
    SystemExit: 2</samp></pre>
</section>
<section class="material__chapter">
<h2 id="3">Модули, импорт модулей из&nbsp;скриптов</h2>
<p>Настало время немного детальнее поговорить о&nbsp;модулях в&nbsp;Python. Мы&nbsp;уже неоднократно ими пользовались, но&nbsp;не&nbsp;упомянули о&nbsp;том, как&nbsp;же они устроены внутри. Давайте исправим этот недочет.</p>
<p>Когда в&nbsp;тексте нашей программы мы&nbsp;пишем команду <var>import</var>, Python пытается подключить (загрузить) файл, имя которого мы&nbsp;указали. Но&nbsp;для этого он&nbsp;должен ответить на&nbsp;вопрос: где искать файл?</p>
<p>Давайте разберемся.</p>
<p>В&nbsp;начале прошлого урока мы&nbsp;говорили про системную переменную PATH и&nbsp;поиск исполняемых файлов.</p>
<p>В&nbsp;языке Python работает похожая технология для модулей при выполнении команды <var>import</var>. Давайте узнаем, где&nbsp;же Python будет искать файл с&nbsp;модулем, когда получит соответствующую команду.</p>
<p>Для этого посмотрим на&nbsp;значение переменной <var>sys.path</var> из&nbsp;библиотеки (модуля) sys:</p>
<pre><code class="language-python">import sys
import pprint
pprint.pprint(sys.path)
</code></pre>
<pre><samp>['',
 '/Users/anaconda/lib/python36.zip',
 '/Users/anaconda/lib/python3.6',
 '/Users/anaconda/lib/python3.6/lib-dynload',
 '/Users/anaconda/lib/python3.6/site-packages',
 '/Users/anaconda/lib/python3.6/site-packages/Sphinx-1.6.3-py3.6.egg',
 '/Users/anaconda/lib/python3.6/site-packages/aeosa',
 '/Users/anaconda/lib/python3.6/site-packages/setuptools-27.2.0-py3.6.egg',
 '/Users/anaconda/lib/python3.6/site-packages/IPython/extensions',
 '/Users/.ipython']</samp></pre>
<p>Как вы&nbsp;могли заметить, переменная <var>sys.path</var> хранит некоторый список путей. А&nbsp;на&nbsp;первой позиции в&nbsp;этом списке стоит <strong>пустая строка</strong>. Это означает, что при импорте модуля, поиск первым делом будет осуществляться в&nbsp;каталоге, где находится сама запускаемая программа.</p>
<p>Если в&nbsp;текущем каталоге модуль не&nbsp;найден, то&nbsp;Python попытается найти его последовательно во&nbsp;всех каталогах списка <var>sys.path</var>. Он&nbsp;может искать даже в&nbsp;zip-архивах.</p>
<p>Если ни&nbsp;по&nbsp;одному из&nbsp;путей файл не&nbsp;найден, мы&nbsp;получим ошибку.</p>
<p>Как вы&nbsp;уже знаете, Python позволяет импортировать те&nbsp;модули, которые вы&nbsp;разработали самостоятельно. Для этого (если импортируемый файл и&nbsp;файл, в&nbsp;который импортируем, лежат в&nbsp;одной директории) надо написать:</p>
<pre><code class="language-python">import имя_файла_без_.py
</code></pre>
<p>Например, для файла module.py импорт будет выглядеть так:</p>
<pre><code class="language-python">import module
</code></pre>
<p>Однако при импорте Python выполнит этот файл, как будто вы&nbsp;запустили его на&nbsp;исполнение как отдельную программу. Иногда именно это нам и&nbsp;нужно, но&nbsp;существует достаточно большой процент сценариев, когда такое поведение нежелательно.</p>
<p>В&nbsp;любой программе на&nbsp;Python есть глобальная переменная <code>__name__</code>. Анализ ее&nbsp;значения и&nbsp;поможет нам корректно работать с&nbsp;модулями. Правило такое:</p>
<ul>
<li>Если в&nbsp;переменной <code>__name__</code> находится значение <code>"__main__"</code>, это означает, что интерпретатор Python вызвал программу самостоятельно</li>
<li>Если этот файл импортируется с&nbsp;помощью команды <var>import</var>, переменной <code>__name__</code> будет присвоено имя модуля. Мы&nbsp;уже встречались с&nbsp;подобной записью при изучении библиотеки PyQt</li>
</ul>
<p>Рассмотрим еще один пример:</p>
<pre><code class="language-python"># my_module_good.py


def some_func():
    print("func is running")
    if __name__ == "__main__":
        print("I was called without ##import##")


def main():
    print("Main part of my_module.py")
    some_func()


if __name__ == "__main__":
    main()
</code></pre>
<pre><code class="language-python"># my_script_good.py

from my_module_good import some_func


def main():
    print("My_script is running")
    some_func()


if __name__ == "__main__":
    main()
</code></pre>
<p>Как мы&nbsp;видим, если вызвать напрямую my_module_good.py, то&nbsp;запустится функция <var>main</var>, откуда произойдет вызов функции <var>some_func</var>. А&nbsp;если мы&nbsp;просто подключаем модуль, то&nbsp;вызова функции <var>main</var> из&nbsp;файла my_module_good.py не&nbsp;произойдет.</p>
<p>Такой способ оформления программы является общепринятой практикой, и&nbsp;мы&nbsp;призываем вас следовать ей&nbsp;в&nbsp;будущем.</p>
</section>
<section class="material__chapter">
<h2 id="4">Заключение</h2>
<p>Мы&nbsp;немного отвлеклись от&nbsp;непосредственного изучения взаимодействия с&nbsp;различными API, чтобы изучить различные дополнительные темы, которые неразрывно связаны с&nbsp;написанием программ для Веба. Уже на&nbsp;следующем уроке мы&nbsp;вернемся к&nbsp;главной теме второго полугодия и&nbsp;больше уже не&nbsp;будем от&nbsp;нее отступать.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>