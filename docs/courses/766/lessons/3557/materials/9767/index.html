<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Украшения игры </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок PG. Украшения</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Украшения игры</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Анимация спрайтов</a></li>
<li><a class="material__link" href="#2">Система частиц</a></li>
<li><a class="material__link" href="#3">Что&nbsp;же дальше?</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;последнем занятии мы&nbsp;рассмотрим два способа на&nbsp;порядок улучшить впечатление от&nbsp;игры (примерно в&nbsp;10&nbsp;раз).</p>
<p>Этот урок не&nbsp;содержит задач.</p>
</section>
<section class="material__chapter">
<h2 id="1">Анимация спрайтов</h2>
<p>В&nbsp;игре важно все: и&nbsp;удобство управления, и&nbsp;тщательно разработанные уровни. Но&nbsp;в&nbsp;первую очередь пользователи обращают внимание на&nbsp;графические эффекты и&nbsp;звук.</p>
<p>Для того чтобы картинка ожила, используют анимацию. Просто рисуют несколько изображений и&nbsp;последовательно их&nbsp;меняют. Обычно для анимации спрайтов берут листы, совмещающие в&nbsp;себе несколько последовательных изображений. Например, такие:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-8-1.png" width="680" height="auto" /></div>
<p>Удобно создать специальный класс &laquo;анимированный спрайт&raquo;, где разрезать лист на&nbsp;отдельные спрайты.</p>
<pre><code class="language-python">class AnimatedSprite(pygame.sprite.Sprite):
    def __init__(self, sheet, columns, rows, x, y):
        super().__init__(all_sprites)
        self.frames = []
        self.cut_sheet(sheet, columns, rows)
        self.cur_frame = 0
        self.image = self.frames[self.cur_frame]
        self.rect = self.rect.move(x, y)

    def cut_sheet(self, sheet, columns, rows):
        self.rect = pygame.Rect(0, 0, sheet.get_width() // columns, 
                                sheet.get_height() // rows)
        for j in range(rows):
            for i in range(columns):
                frame_location = (self.rect.w * i, self.rect.h * j)
                self.frames.append(sheet.subsurface(pygame.Rect(
                    frame_location, self.rect.size)))

    def update(self):
        self.cur_frame = (self.cur_frame + 1) % len(self.frames)
        self.image = self.frames[self.cur_frame]
</code></pre>
<p>Смены кадров удобно делать в&nbsp;методе <code>update()</code>. По&nbsp;времени, чтобы элементы игры оживали, или по&nbsp;координатам, чтобы, например, герой ходил, переставляя ноги. Реализация выше&nbsp;&mdash; лишь один из&nbsp;возможных примеров.</p>
<p>Смена кадра на&nbsp;каждой итерации цикла&nbsp;&mdash; это очень часто.</p>
<p>На&nbsp;рисунке показана работа спрайта, созданного командой</p>
<pre><code class="language-python">dragon = AnimatedSprite(load_image("dragon_sheet8x2.png"), 8, 2, 50, 50)
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-8-2.gif" width="166" height="auto" /></div>
<p>при обновлении 10&nbsp;раз в&nbsp;секунду (<code>clock.tick(10)</code>).</p>
<p>Для того чтобы не&nbsp;тормозить всю игру, можно ввести в&nbsp;классе счетчик итераций и&nbsp;менять изображение, скажем, каждую пятую итерацию.</p>
<p>Сложнее всего&nbsp;&mdash; нарисовать персонажа. Для первых игр вполне можно использовать <a class="material__link" href="https://yandex.ru/search/?text=free+sprite+sheets&amp;lr=213&amp;clid=2270455&amp;win=413&amp;suggest_reqid=429699388157469083249185062493782," target="_blank" rel="noopener noreferrer">свободно распространяемые сеты</a>. Обычно в&nbsp;них содержится несколько анимаций, например, движение игрока в&nbsp;разные стороны. Можно создать несколько списков с&nbsp;индексами изображений и&nbsp;переключать их&nbsp;в&nbsp;зависимости от&nbsp;направления движения.</p>
</section>
<section class="material__chapter">
<h2 id="2">Система частиц</h2>
<p>Система частиц очень украшает игру. Взрывы, туман, искры&nbsp;&mdash; все эти эффекты делаются по&nbsp;одной технологии. В&nbsp;ее&nbsp;основе, как в&nbsp;жизни, много маленьких объектов, которые связаны со&nbsp;своим источником (эммитером) и&nbsp;иногда между собой.</p>
<p>Удобно оформлять частицу в&nbsp;виде класса, наследника спрайта. При этом можно просто проверять вылет частиц за&nbsp;границы экрана пересечением прямоугольника спрайта с&nbsp;прямоугольником экрана.</p>
<pre><code class="language-python">...
# для отслеживания улетевших частиц
# удобно использовать пересечение прямоугольников
screen_rect = (0, 0, width, height)

class Particle(pygame.sprite.Sprite):
    # сгенерируем частицы разного размера
    fire = [load_image("star.png")]
    for scale in (5, 10, 20):
        fire.append(pygame.transform.scale(fire[0], (scale, scale)))

    def __init__(self, pos, dx, dy):
        super().__init__(all_sprites)
        self.image = random.choice(self.fire)
        self.rect = self.image.get_rect()

        # у каждой частицы своя скорость &mdash; это вектор
        self.velocity = [dx, dy]
        # и свои координаты
        self.rect.x, self.rect.y = pos

        # гравитация будет одинаковой (значение константы)
        self.gravity = GRAVITY

    def update(self):
        # применяем гравитационный эффект: 
        # движение с ускорением под действием гравитации
        self.velocity[1] += self.gravity
        # перемещаем частицу
        self.rect.x += self.velocity[0]
        self.rect.y += self.velocity[1]
        # убиваем, если частица ушла за экран
        if not self.rect.colliderect(screen_rect):
            self.kill()
</code></pre>
<p>Для демонстрационного примера не&nbsp;будем создавать класс эмиттера, а&nbsp;ограничимся функцией, принимающей в&nbsp;себя позицию, из&nbsp;которой будут вылетать звезды:</p>
<pre><code class="language-python">def create_particles(position):
    # количество создаваемых частиц
    particle_count = 20
    # возможные скорости
    numbers = range(-5, 6)
    for _ in range(particle_count):
        Particle(position, random.choice(numbers), random.choice(numbers))
</code></pre>
<p>Эту функцию будем вызывать по&nbsp;щелчку мыши, передавая в&nbsp;нее координаты нажатия клавиши мыши:</p>
<pre><code class="language-python">all_sprites = pygame.sprite.Group()
clock = pygame.time.Clock()
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.MOUSEBUTTONDOWN:
            # создаём частицы по щелчку мыши
            create_particles(pygame.mouse.get_pos())
    
    all_sprites.update()
    screen.fill((0, 0, 0))
    all_sprites.draw(screen)    
    pygame.display.flip()
    clock.tick(50)

pygame.quit()
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-8-3.gif" width="494" height="auto" /></div>
<p>Картинку для задания можно взять тут:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/pygame/star.png" width="32" height="auto" /></div>
<p>Конечно, это всего лишь пример. Впереди&nbsp;&mdash; большое поле для экспериментов и&nbsp;изучения теории. Существует много сложных алгоритмов систем частиц, с&nbsp;которыми обязательно стоит познакомиться.</p>
</section>
<section class="material__chapter">
<h2 id="3">Что&nbsp;же дальше?</h2>
<p>К&nbsp;этому занятию нет специальных задач. Разберитесь с&nbsp;приведенными в&nbsp;уроке примерами и&nbsp;продолжайте разрабатывать свою игру.</p>
<p>У&nbsp;хорошей игры должно быть звуковое оформление. Мы&nbsp;не&nbsp;обсуждали звук на&nbsp;занятиях, но&nbsp;попробуйте разобраться по&nbsp;документации с&nbsp;возможностями модуля <a class="material__link" href="https://www.pygame.org/docs/ref/mixer.html" target="_blank" rel="noopener noreferrer">pygame.mixer</a> и&nbsp;добавьте в&nbsp;игру музыку и&nbsp;эффекты.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>