<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Столкновения и другие взаимодействия </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок PG. Физика</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Столкновения и&nbsp;другие взаимодействия</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Введение</a></li>
<li><a class="material__link" href="#2">Пересечение по&nbsp;прямоугольнику и&nbsp;окружности</a></li>
<li><a class="material__link" href="#3">Пересечение по&nbsp;маске</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке рассмотрим разные виды взаимодействия спрайтов друг с&nbsp;другом: пересечение по&nbsp;прямоугольнику, по&nbsp;окружности, по&nbsp;маске.</p>
</section>
<section class="material__chapter">
<h2 id="1">Введение</h2>
<p>Когда речь заходит об&nbsp;играх, то&nbsp;обязательно всплывает тема о&nbsp;физических процессах, которые лежат в&nbsp;основе поведения игровых объектов. Движение объектов в&nbsp;поле других объектов, столкновения объектов и&nbsp;другая функциональность&nbsp;&mdash; все это требует физического и&nbsp;математического моделирования.</p>
<p>Например, определение столкновений&nbsp;&mdash; это определение пересечений геометрических фигур.</p>
<p>Перед тем, как мы&nbsp;поговорим о&nbsp;возможностях модуля <var>sprite</var>, давайте решим две первые классные зaдачи. Их&nbsp;нужно решить <strong>не&nbsp;пользуясь</strong> библиотекой Pygame.</p>
<p>В&nbsp;Pygame не&nbsp;реализована поддержка физических процессов, но&nbsp;в&nbsp;модуле <var>sprite</var> существуют удобные функции для определения столкновений объектов.</p>
</section>
<section class="material__chapter">
<h2 id="2">Пересечение по&nbsp;прямоугольнику и&nbsp;окружности</h2>
<p>Какие&nbsp;же возможности дает библиотека Pygame программисту?</p>
<p>Во-первых, Pygame позволяет проверить спрайт на&nbsp;столкновение с&nbsp;другим спрайтом. Причем проверить это можно двумя способами:</p>
<ol>
<li>По&nbsp;ограничивающему прямоугольнику (метод <code>collide_rect()</code>)</li>
<li>По&nbsp;ограничивающей окружности (метод <code>collide_circle()</code>)</li>
</ol>
<p>Для &laquo;рядовых ситуаций&raquo; этого достаточно.</p>
<p>А&nbsp;во-вторых, Pygame может проверить спрайт на&nbsp;столкновение с&nbsp;группой других спрайтов.</p>
<p>Попробуем написать простейший бильярд: кружочки в&nbsp;окне, отскакивающие от&nbsp;стенок. Вероятно, вы&nbsp;уже сталкивались с&nbsp;этой задачей, и, вполне возможно, решали&nbsp;ее. Здесь мы&nbsp;ударим из&nbsp;пушки по&nbsp;воробьям и&nbsp;решим задачу таким образом, чтобы изучить всю мощь детекторов столкновений.</p>
<p>Вам уже не&nbsp;составит труда создать класс шарика. Он&nbsp;может выглядеть примерно так:</p>
<pre><code class="language-python">class Ball(pygame.sprite.Sprite):
    def __init__(self, radius, x, y):
        super().__init__(all_sprites)
        self.radius = radius
        self.image = pygame.Surface((2 * radius, 2 * radius),
                                    pygame.SRCALPHA, 32)
        pygame.draw.circle(self.image, pygame.Color("red"),
                           (radius, radius), radius)
        self.rect = pygame.Rect(x, y, 2 * radius, 2 * radius)
        self.vx = random.randint(-5, 5)
        self.vy = random.randrange(-5, 5)

    def update(self):
        self.rect = self.rect.move(self.vx, self.vy)
</code></pre>
<p>Определим рамку, которая ограничивает поле экрана в&nbsp;виде спрайта. Тогда мы&nbsp;сможем определять отталкивание шариков от&nbsp;стенок как пересечение спрайта шарика со&nbsp;спрайтами рамки (поскольку рамка состоит из&nbsp;четырех стенок).</p>
<p>Стенки будут либо строго горизонтальными, либо строго вертикальными. Для нас играет роль именно принадлежность стенки к&nbsp;той или иной группе спрайтов: при столкновении с&nbsp;вертикальными нужно поменять x-координату, иначе&nbsp;&mdash; y-координату. Действительно, например, ударившись о&nbsp;нижнюю или верхнюю стенку, шарик должен изменить своё направление по&nbsp;вертикали, а&nbsp;направление по&nbsp;горизонтали у&nbsp;него останется прежним.</p>
<p>Заведем две дополнительные группы. Мощь модуля <var>sprite</var> библиотеки Pygame состоит в&nbsp;том, что можно вызовом одной команды проверять столкновения с&nbsp;целой группой спрайтов и&nbsp;даже получать список тех из&nbsp;них, с&nbsp;которыми имеется пересечение.</p>
<pre><code class="language-python">horizontal_borders = pygame.sprite.Group()
vertical_borders = pygame.sprite.Group()
</code></pre>
<p>Сам класс <var>Border</var> можно оформить так:</p>
<pre><code class="language-python">class Border(pygame.sprite.Sprite):
    # строго вертикальный или строго горизонтальный отрезок
    def __init__(self, x1, y1, x2, y2):
        super().__init__(all_sprites)
        if x1 == x2:  # вертикальная стенка
            self.add(vertical_borders)
            self.image = pygame.Surface([1, y2 - y1])
            self.rect = pygame.Rect(x1, y1, 1, y2 - y1)
        else:  # горизонтальная стенка
            self.add(horizontal_borders)
            self.image = pygame.Surface([x2 - x1, 1])
            self.rect = pygame.Rect(x1, y1, x2 - x1, 1)
</code></pre>
<p>Добавим в&nbsp;программу четыре стенки и&nbsp;несколько шариков:</p>
<pre><code class="language-python">Border(5, 5, width - 5, 5)
Border(5, height - 5, width - 5, height - 5)
Border(5, 5, 5, height - 5)
Border(width - 5, 5, width - 5, height - 5)

for i in range(10):
    Ball(20, 100, 100)
</code></pre>
<p>Все шарики создаются в&nbsp;одном месте, но&nbsp;потом разлетаются. Естественно, не&nbsp;обращая внимания на&nbsp;стенки.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-6-1.png" width="368" height="auto" /></div>
<p>И&nbsp;вот тут начинается самое интересное. Добавим в&nbsp;<code>update()</code> шариков элементарную проверку на&nbsp;столкновение с&nbsp;группами стенок:</p>
<pre><code class="language-python"># движение с проверкой столкновение шара со стенками
def update(self):
    self.rect = self.rect.move(self.vx, self.vy)
    if pygame.sprite.spritecollideany(self, horizontal_borders):
        self.vy = -self.vy
    if pygame.sprite.spritecollideany(self, vertical_borders):
        self.vx = -self.vx
</code></pre>
<p>Теперь шарики двигаются как надо, отскакивая от&nbsp;стенок.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-6/pygame-6-2.gif" width="500" height="auto" /></div>
<p>Именно так просто, в&nbsp;две строки. Функция <code>spritecollideany()</code> возвращает спрайт из&nbsp;группы, с&nbsp;которым произошло столкновение или None, если столкновение не&nbsp;обнаружено.</p>
<p>Другая функция, <code>spritecollide()</code>, принимает в&nbsp;качестве аргументов так&nbsp;же спрайт и&nbsp;группу&nbsp;&mdash; возвращает <em>список</em> спрайтов из&nbsp;группы, с&nbsp;которыми произошло пересечение. Третьим параметром можно передать логическое значение True, и&nbsp;тогда все спрайты, с&nbsp;которыми есть пересечение, будут уничтожены и&nbsp;убраны из&nbsp;группы.</p>
<p>Организовать столкновения шариков между собой немного сложнее. Вернее, организовать столкновение строго по&nbsp;законам физики действительно сложно. Но&nbsp;вполне можно пойти на&nbsp;упрощение: например, при столкновении менять скорости шариков на&nbsp;противоположные или обменивать их&nbsp;скорости.</p>
<p>Попробуйте ради практики реализовать такую задачу. Мы&nbsp;же будем двигаться дальше.</p>
</section>
<section class="material__chapter">
<h2 id="3">Пересечение по&nbsp;маске</h2>
<p>Не&nbsp;все объекты имеют простую форму, поэтому их&nbsp;обработку не&nbsp;всегда можно свести к&nbsp;проверке столкновений ограничивающих объекты прямоугольников и&nbsp;окружностей.</p>
<p>Для таких сложных объектов возможно использовать функцию <code>pygame.sprite.collide_mask()</code>, которая ориентируется именно на&nbsp;<em>пересечение картинок</em>. Чтобы ее&nbsp;использовать, стоит заранее вычислить маску в&nbsp;проверяемых на&nbsp;столкновение спрайтах.</p>
<pre><code class="language-python">sprite.mask = pygame.mask.from_surface(sprite.image)
</code></pre>
<p>Или, если в&nbsp;конструкторе:</p>
<pre><code class="language-python">self.mask = pygame.mask.from_surface(self.image)
</code></pre>
<p>Напишем простой пример: будем высаживать десант на&nbsp;горы.</p>
<p>Горы и&nbsp;парашютик оформим в&nbsp;виде спрайтов. Картинка гор должна иметь прозрачный фон.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-6/pt.png" width="50" height="auto" /></div>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-6/mountains.png" width="680" height="auto" /></div>
<p>(Если он&nbsp;изначально непрозрачный, но&nbsp;одноцветный, то&nbsp;можно сделать его прозрачным, если передать в&nbsp;функцию <code>load_image()</code> параметр <code>colorkey=-1</code>).</p>
<p>В&nbsp;конструкторе сразу вычислим маски, чтобы потом сравнение на&nbsp;столкновение проходило быстрее.</p>
<p>Гору располагаем внизу окна, парашютики будем генерировать по&nbsp;щелчку мыши.</p>
<pre><code class="language-python">class Mountain(pygame.sprite.Sprite):
    image = load_image("mountains.png")

    def __init__(self):
        super().__init__(all_sprites)
        self.image = Mountain.image
        self.rect = self.image.get_rect()
        # вычисляем маску для эффективного сравнения
        self.mask = pygame.mask.from_surface(self.image)
        # располагаем горы внизу
        self.rect.bottom = height
</code></pre>
<p>Создаем гору:</p>
<pre><code class="language-python">mountain = Mountain()
</code></pre>
<p>С&nbsp;переменной <var>mountain</var> будет работать класс-парашютик:</p>
<pre><code class="language-python">class Landing(pygame.sprite.Sprite):
    image = load_image("pt.png")

    def __init__(self, pos):
        super().__init__(all_sprites)
        self.image = Landing.image
        self.rect = self.image.get_rect()
        # вычисляем маску для эффективного сравнения
        self.mask = pygame.mask.from_surface(self.image)
        self.rect.x = pos[0]
        self.rect.y = pos[1]

    def update(self):
        self.rect = self.rect.move(0, 1)
</code></pre>
<p>В&nbsp;игровом цикле добавляем парашютики:</p>
<pre><code class="language-python">	# в основном игровом цикле
	...
    for event in pygame.event.get():
        ...       
        if event.type == pygame.MOUSEBUTTONDOWN:
            Landing(event.pos)
     ...
</code></pre>
<p>Теперь парашютики летят вниз, до&nbsp;конца экрана:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-6-4.png" width="600" height="auto" /></div>
<p>Но&nbsp;если добавить в&nbsp;функцию <code>update()</code> класса <var>Landing</var> проверку на&nbsp;пересечение по&nbsp;маске,</p>
<pre><code class="language-python">def update(self):
    # если ещё в небе
    if not pygame.sprite.collide_mask(self, mountain):
        self.rect = self.rect.move(0, 1)
</code></pre>
<p>то&nbsp;ситуация изменится, и&nbsp;парашютики будут останавливаться в&nbsp;точке касания с&nbsp;горой.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-6/mountains.gif" width="680" height="auto" /></div>
<p>Сравнение происходит по&nbsp;пересечению непрозрачных пикселей изображения (это верх горы). Видно, что один из&nbsp;парашютиков остановился &laquo;не&nbsp;долетев&raquo;, потому что произошло пересечение областей не&nbsp;с&nbsp;квадратиком-грузом, а&nbsp;со&nbsp;стропами.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>