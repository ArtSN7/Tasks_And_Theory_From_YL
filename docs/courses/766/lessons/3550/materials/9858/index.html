<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Игровой цикл. События </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок PG. События</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Игровой цикл. События</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Поговорим о&nbsp;времени</a></li>
<li><a class="material__link" href="#2">Время в&nbsp;PyGame</a></li>
<li><a class="material__link" href="#3">События</a></li>
<li><a class="material__link" href="#4">События по&nbsp;таймеру</a></li>
<li><a class="material__link" href="#5">Холст (Surface)</a></li>
<li><a class="material__link" href="#6">Памятка по&nbsp;решению задач</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке поговорим об&nbsp;игровом цикле. Обсудим работу со&nbsp;временем, кадрами и&nbsp;событиями.</p>
</section>
<section class="material__chapter">
<h2 id="1">Поговорим о&nbsp;времени</h2>
<p>Обычно программа на&nbsp;Pygame, даже если она показывает статичную картинку, все равно содержит <strong>игровой цикл</strong>.</p>
<p><strong>Главный игровой цикл</strong>&nbsp;&mdash; обязательный компонент любой игры. В&nbsp;нем происходит постоянная отрисовка игровых объектов, изменение их&nbsp;состояния (например, положения) и&nbsp;обработка событий. Прежде всего, цикл реагирует на&nbsp;действия пользователя.</p>
<p>Общая концепция примерно такая&nbsp;же, как при использовании PyQT: мы&nbsp;задаем реакцию приложения на&nbsp;определенные события, только там главный цикл запускался неявно через <code>app.exec()</code>, тут&nbsp;же нам предстоит более низкоуровневое управление этой частью программы.</p>
<p>Рассмотрим обработку завершения приложения: цикл должен быть завершен по&nbsp;желанию пользователя.</p>
<pre><code class="language-python">import pygame

if __name__ == '__main__':
    pygame.init()
    size = width, height = 800, 400
    screen = pygame.display.set_mode(size)

    running = True
    while running:
        # внутри игрового цикла ещё один цикл
        # приема и обработки сообщений
        for event in pygame.event.get():
            # при закрытии окна
            if event.type == pygame.QUIT:
                running = False

        # отрисовка и изменение свойств объектов
        # ...

        # обновление экрана
        pygame.display.flip()
    pygame.quit()
</code></pre>
<p>Игра заканчивается, когда завершается главный игровой цикл.</p>
<p>Если завести переменную <var>x_pos</var>, занести в&nbsp;нее значение&nbsp;0, а&nbsp;в&nbsp;цикл добавить строки:</p>
<pre><code class="language-python">screen.fill((0, 0, 0))
pygame.draw.circle(screen, (255, 0, 0), (x_pos, 200), 20)
x_pos += 1
</code></pre>
<p>то&nbsp;красный круг &laquo;поедет&raquo; вправо.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-2/jamesbond.gif" width="600" height="auto" /></div>
<p>Для аккуратности лучше поместить рисование в&nbsp;отдельную функцию. На&nbsp;прошлом занятии мы&nbsp;называли ее&nbsp;<code>draw()</code>. Если написать в&nbsp;нее генерацию случайных точек, то&nbsp;картинка на&nbsp;экране будет постоянно меняться, получится эффект ряби не&nbsp;настроенного на&nbsp;канал телевизора.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-2/tvsnow2.gif" width="600" height="auto" /></div>
<p><strong>Тренировочное задание.</strong> Реализуйте программу, моделирующую ненастроенный телевизор.</p>
</section>
<section class="material__chapter">
<h2 id="2">Время в&nbsp;PyGame</h2>
<p>Не&nbsp;имеет большого значения, с&nbsp;какой скоростью мерцает телевизор из&nbsp;предыдущего примера. Но&nbsp;в&nbsp;играх время играет очень важную роль. На&nbsp;некоторых машинах движение будет идти слишком быстро, на&nbsp;других&nbsp;&mdash; слишком медленно. Это зависит как от&nbsp;мощности компьютера, так и&nbsp;от&nbsp;загруженности процессора.</p>
<p>Но&nbsp;разработчик игры стремится к&nbsp;тому, чтобы на&nbsp;любом компьютере движение выглядело примерно одинаково. Для этого нужно учитывать время.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-2/time.svg" width="600" height="auto" /></div>
<p><em>Л.&nbsp;Кэрролл &laquo;Алиса в&nbsp;стране чудес&raquo;</em></p>
<p>В&nbsp;Pygame для учета времени есть специальный класс <var>Clock</var> в&nbsp;модуле <var>time</var>.</p>
<p>Нужно создать его экземпляр перед игровым циклом, а&nbsp;в&nbsp;самом цикле на&nbsp;каждом шаге вызывать метод <code>tick()</code> этого экземпляра.</p>
<p>Этот метод возвращает <strong>количество миллисекунд</strong>, прошедших с&nbsp;момента последнего вызова. Можно ориентироваться на&nbsp;него и&nbsp;работать с&nbsp;объектом игры с&nbsp;учетом полученного прошедшего времени.</p>
<p>Например, завести переменную скорости и&nbsp;вычислять новое положение объекта по&nbsp;формуле <code>x_pos += v * clock.tick()</code>:</p>
<pre><code class="language-python">import pygame

if __name__ == '__main__':
    pygame.init()
    pygame.display.set_caption('Движущийся круг 2')
    size = width, height = 800, 400
    screen = pygame.display.set_mode(size)

    running = True
    x_pos = 0
    v = 20  # пикселей в секунду
    clock = pygame.time.Clock()
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        screen.fill((0, 0, 0))
        pygame.draw.circle(screen, (255, 0, 0), (int(x_pos), 200), 20)
        x_pos += v * clock.tick() / 1000  # v * t в секундах
        pygame.display.flip()
    pygame.quit()
</code></pre>
<p>Теперь кружок из&nbsp;первого примера будет перемещаться со&nbsp;скоростью <strong>ровно</strong> 20&nbsp;пикселей в&nbsp;секунду практически равномерно.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-2/jamesbond2.gif" width="600" height="auto" /></div>
<p>Обратите внимание: при вычислениях <var>x</var>&nbsp;может стать нецелым, а&nbsp;при рисовании окружности позиция центра должна быть кортежем целых чисел. Поэтому нужно приводить <var>x</var>&nbsp;к&nbsp;типу <var>int</var>.</p>
<p>В&nbsp;простых случаях, когда особая точность не&nbsp;требуется, можно просто передавать в&nbsp;метод <code>tick()</code> требуемое FPS (FPS&nbsp;&mdash; Frames per Second&nbsp;&mdash; кадров в&nbsp;секунду) и&nbsp;считать, что кадры рассчитываются и&nbsp;рисуются почти мгновенно. В&nbsp;этом случае <code>tick()</code> будет задерживать выполнение программы так, чтобы количество кадров было не&nbsp;больше переданного значения&nbsp;&mdash; оно будет примерно равно ему&nbsp;&mdash; и&nbsp;дальше ориентироваться на&nbsp;это значение:</p>
<pre><code class="language-python">import pygame

if __name__ == '__main__':
    pygame.init()
    pygame.display.set_caption('Движущийся круг 2')
    size = width, height = 800, 400
    screen = pygame.display.set_mode(size)

    running = True
    x_pos = 0
    v = 20  # пикселей в секунду
    fps = 60
    clock = pygame.time.Clock()
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        screen.fill((0, 0, 0))
        pygame.draw.circle(screen, (255, 0, 0), (int(x_pos), 200), 20)
        x_pos += v / fps
        clock.tick(fps)
        pygame.display.flip()
    pygame.quit()
</code></pre>
<p>Конечно, у&nbsp;компьютера есть предел, и&nbsp;1000 FPS вы&nbsp;не&nbsp;получите в&nbsp;любом случае. Но, на&nbsp;самом деле, и&nbsp;30&nbsp;FPS вполне достаточно.</p>
</section>
<section class="material__chapter">
<h2 id="3">События</h2>
<p>В&nbsp;Pygame есть модули <var>mouse</var> и&nbsp;<var>keyboard</var>. Они позволяют &laquo;опрашивать&raquo; мышь и&nbsp;клавиатуру в&nbsp;любой момент, то&nbsp;есть получать от&nbsp;устройств информацию. Но&nbsp;удобнее работать с&nbsp;<strong>событиями.</strong></p>
<p>Важнее узнать, что кнопка мыши <em>нажалась</em>, чем получить информацию о&nbsp;том, что она <em>нажата</em>.</p>
<p>Любая игра также управляется событиями. Что&nbsp;же это за&nbsp;события?</p>
<p>Прежде всего, это события пользовательского ввода: игрок нажал клавишу на&nbsp;клавиатуре, подвинул мышь, нажал на&nbsp;кнопку закрытия окна и&nbsp;т.&nbsp;д. На&nbsp;каждом шаге главного игрового цикла мы&nbsp;разбираем накопившиеся события.</p>
<p>Несмотря на&nbsp;то, что цикл работает очень быстро, за&nbsp;одну итерацию наступивших событий может быть несколько. Поэтому в&nbsp;программе появляется второй внутренний цикл, который обрабатывает все произошедшие события (разбирает очередь событий).</p>
<p>Еще раз вернемся к&nbsp;шаблону игровой программы:</p>
<pre><code class="language-python">running = True

while running:
    # внутри игрового цикла ещё один цикл
    # приёма и обработки сообщений
    for event in pygame.event.get():
        # при закрытии окна
        if event.type == pygame.QUIT:
            running = False            
        # РЕАКЦИЯ НА ОСТАЛЬНЫЕ СОБЫТИЯ
        # ...  
    # отрисовка и изменение свойств объектов
    # ...    
    pygame.display.flip()
</code></pre>
<p>Обратите внимание: мы&nbsp;забираем события функцией <code>get()</code>, а&nbsp;не&nbsp;<code>wait()</code>, как на&nbsp;прошлом занятии. <code>wait()</code> блокирует выполнение программы, пока не&nbsp;наступит событие. Такое поведение подходит для шахмат или пошаговых стратегий, но&nbsp;в&nbsp;<strong>шутере</strong> монстры не&nbsp;станут ждать, пока игрок выстрелит.</p>
<p>Таким образом, главный игровой цикл обычно выглядит примерно так:</p>
<pre><code class="language-python">fps = 50 # количество кадров в секунду
clock = pygame.time.Clock()
running = True
while running: # главный игровой цикл
    for event in pygame.event.get():
    	if event.type == pygame.QUIT:
    		running = False
    	# обработка остальных событий
    	# ...
    # формирование кадра
    # ...
    pygame.display.flip() # смена кадра
    # изменение игрового мира
    # ...
    # временная задержка
    clock.tick(fps)
</code></pre>
<p>Каждое событие содержит в&nbsp;себе его тип и&nbsp;параметры. Например, события от&nbsp;мыши содержат позицию курсора и&nbsp;информацию о&nbsp;том, какая кнопка была нажата или отпущена.</p>
<p>Приведем список основных типов событий с&nbsp;их&nbsp;атрибутами:</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<thead>
<tr>
<th>event.type</th>
<th>атрибуты</th>
</tr>
</thead>
<tbody>
<tr>
<td>QUIT</td>
<td>нет</td>
</tr>
<tr>
<td>KEYDOWN</td>
<td>unicode, key, mod (например, shift, ctrl...)</td>
</tr>
<tr>
<td>KEYUP</td>
<td>key, mod</td>
</tr>
<tr>
<td>MOUSEMOTION</td>
<td>pos (кортеж текущих координат),<br />rel (кортеж координат относительно предыдущего события),<br />buttons (кортеж номеров нажатых кнопок в момент движения)</td>
</tr>
<tr>
<td>MOUSEBUTTONUP</td>
<td>pos, button</td>
</tr>
<tr>
<td>MOUSEBUTTONDOWN</td>
<td>pos, button</td>
</tr>
</tbody>
</table>
</div>
<p>Например, код:</p>
<pre><code class="language-python">while running:
    screen.fill((0, 0, 0))
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.MOUSEMOTION:
            pygame.draw.circle(screen, (0, 0, 255), event.pos, 20)
    pygame.display.flip()
    clock.tick(50)
</code></pre>
<p>отображает при движении мыши синий круг под курсором.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-2/blueball.gif" width="600" height="auto" /></div>
<p>Обратите внимание: круг исчезает, если мышь не&nbsp;двигать. Почему? Как это можно исправить?</p>
<p>Pygame поставляется с&nbsp;большим количеством <a class="material__link" href="https://www.pygame.org/docs/ref/examples.html" target="_blank" rel="noopener noreferrer">примеров, небольших программ</a>, иллюстрирующих ее&nbsp;возможности. Примеры устанавливаются вместе с&nbsp;библиотекой в&nbsp;виде модуля <var>examples</var>.</p>
<p>Хорошо помогает разобраться с событиями пример <var>eventlist</var>. Его можно запустить из командной строки</p>
<pre><code>python -m pygame.examples.eventlist
</code></pre>
<p>Или кодом (из&nbsp;среды программирования):</p>
<pre><code class="language-python">import pygame.examples.eventlist
pygame.examples.eventlist.main()
</code></pre>
<p>А&nbsp;еще лучше&nbsp;&mdash; узнать местоположение папки с&nbsp;примерами с&nbsp;помощью следующей мини-программы:</p>
<pre><code class="language-python">import pygame.examples
print(pygame.examples.__file__)
</code></pre>
<p>и&nbsp;скопировать оттуда в&nbsp;среду исходный код из&nbsp;файла eventlist.py. Тогда его можно будет изменять.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-2/eventlist.gif" width="500" height="auto" /></div>
<p>Поэкспериментируйте с&nbsp;кодом этого примера.</p>
<p><strong>Тренировочное задание.</strong> По&nbsp;<a class="material__link" href="https://www.pygame.org/docs/ref/mouse.html" target="_blank" rel="noopener noreferrer">документации по&nbsp;модулю mouse</a> или при помощи эксперимента разберитесь, как&nbsp;же работать с&nbsp;колесиком мыши?</p>
</section>
<section class="material__chapter">
<h2 id="4">События по&nbsp;таймеру</h2>
<p>Иногда требуется создавать свои собственные события, которые должны возникать с&nbsp;определенной периодичностью. Например, каждые 10&nbsp;миллисекунд необходимо проверять значение некоторой переменной, которую могут менять различные обработчики.</p>
<p>Для этого есть следующий механизм:</p>
<ol>
<li>Объявляем свое событие. Это целочисленная константа, ее значение должно находиться между значениями констант <var>pygame.USEREVENT</var> и&nbsp;<var>pygame.NUMEVENTS</var>
<pre><code class="language-python">MYEVENTTYPE = pygame.USEREVENT + 1
</code></pre>
</li>
<li>Вызываем функцию
<pre><code class="language-python">pygame.time.set_timer(MYEVENTTYPE, 10)
</code></pre>
</li>
<li>Обрабатываем событие в&nbsp;основном цикле игры так&nbsp;же, как и&nbsp;другие стандартные события
<pre><code class="language-python">for event in pygame.event.get():
    if event.type == MYEVENTTYPE:
        print("Мое событие сработало")
</code></pre>
</li>
<li>Если в&nbsp;какой-то момент необходимо отменить генерацию этого события, необходимо вызвать эту&nbsp;же функцию и&nbsp;передать ей&nbsp;в&nbsp;качестве аргумента&nbsp;0
<pre><code class="language-python">pygame.time.set_timer(MYEVENTTYPE, 0)
</code></pre>
</li>
</ol>
</section>
<section class="material__chapter">
<h2 id="5">Холст (Surface)</h2>
<p>Допустим, мы&nbsp;хотим написать мини-графический редактор.</p>
<p>Ведь каждый программист должен в&nbsp;своей жизни хотя&nbsp;бы раз:</p>
<ol>
<li>Отсортировать массив</li>
<li>Написать свой мини-фотошоп</li>
<li>Реализовать свой тетрис</li>
</ol>
<p>Шутка!</p>
<p>Кстати, <a class="material__link" href="https://ru.wikipedia.org/wiki/Тетрис" target="_blank" rel="noopener noreferrer">Тетрис</a>&nbsp;&mdash; вполне хороший итоговый проект по&nbsp;этому модулю.</p>
<p>Но&nbsp;вернемся к&nbsp;написанию своего графического редактора. Кажется, что все совсем просто. Возьмем предыдущий пример, уберем очистку экрана, перенесем строку <code>screen.fill((0, 0, 0))</code> за&nbsp;цикл&nbsp;&mdash; и&nbsp;все! Простейший фотошоп готов!</p>
<pre><code class="language-python"># очищаем экран один раз в самом начале
screen.fill((0, 0, 0))
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.MOUSEMOTION:
            pygame.draw.circle(screen, (0, 0, 255), event.pos, 20)

    pygame.display.flip()
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-2/sdraw.gif" width="600" height="auto" /></div>
<p>Рисовать он&nbsp;может только синим цветом, постоянно и&nbsp;от&nbsp;края экрана, но&nbsp;это легко исправить.</p>
<p>Проблема возникнет в&nbsp;тот момент, когда мы&nbsp;захотим отменить последнее действие или, как в&nbsp;настоящих редакторах, сначала наметить место будущего прямоугольника, а&nbsp;потом уже нарисовать его.</p>
<p>Принципиально есть два решения:</p>
<ol>
<li>Сохранять изображения в&nbsp;виде команд, построив таким образом аналог редакторов векторной графики</li>
<li>Рисовать прямоугольник на&nbsp;отдельном холсте и&nbsp;накладывать новый холст на&nbsp;старый. Для этого в&nbsp;классе <var>Surface</var> предусмотрен метод <code>blit()</code>. Два его основных параметра: переменная холста и&nbsp;позиция, куда копировать. Если необходимо, третьим параметром можно указать, какую часть изображения копировать</li>
</ol>
<p>Реализуем задуманное вторым путем.</p>
<p>Создадим второй холст и&nbsp;будем:</p>
<ul>
<li>Копировать второй холст на&nbsp;основной (на&nbsp;экран). Если мы&nbsp;в&nbsp;режиме рисования, то&nbsp;рисовать на&nbsp;экране текущий прямоугольник</li>
<li>При <strong>нажатии</strong> на&nbsp;кнопку мыши&nbsp;&mdash; запоминать начальную вершину и&nbsp;включать режим &laquo;рисование&raquo;</li>
<li>При <strong>движении</strong> мыши запоминать ширину и&nbsp;высоту</li>
<li>При <strong>отпускании</strong> мыши копировать основной холст (экран) на&nbsp;второй холст: фиксировать изменения. И&nbsp;выключать режим &laquo;рисование&raquo;</li>
</ul>
<pre><code class="language-python">screen2 = pygame.Surface(screen.get_size())
x1, y1, w, h = 0, 0, 0, 0
drawing = False  # режим рисования выключен
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.MOUSEBUTTONDOWN:
            drawing = True  # включаем режим рисования
            # запоминаем координаты одного угла
            x1, y1 = event.pos
        if event.type == pygame.MOUSEBUTTONUP:
            # сохраняем нарисованное (на втором холсте)
            screen2.blit(screen, (0, 0))
            drawing = False
            x1, y1, w, h = 0, 0, 0, 0
        if event.type == pygame.MOUSEMOTION:
            # запоминаем текущие размеры
            if drawing:
                w, h = event.pos[0] - x1, event.pos[1] - y1
    # рисуем на экране сохранённое на втором холсте
    screen.fill(pygame.Color('black'))
    screen.blit(screen2, (0, 0))
    if drawing:  # и, если надо, текущий прямоугольник
        if w &gt; 0 and h &gt; 0:
            pygame.draw.rect(screen, (0, 0, 255), ((x1, y1), (w, h)), 5)
    pygame.display.flip()
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pygame-2/drawrect2.gif" width="600" height="auto" /></div>
<p>На&nbsp;самом деле, мы&nbsp;уже пользовались вторым холстом на&nbsp;первом занятии, когда выводили текст:</p>
<pre><code class="language-python">font = pygame.font.Font(None, 50)
text = font.render("Hello, Pygame!", 1, (100, 255, 100))
text_x = width // 2 - text.get_width() // 2
text_y = height // 2 - text.get_height() // 2
text_w = text.get_width()
text_h = text.get_height()
screen.blit(text, (text_x, text_y))
</code></pre>
<p>В&nbsp;этом фрагменте переменная <var>text</var>&nbsp;&mdash; это тоже холст. Его создает метод <code>render()</code>, а&nbsp;дальше он&nbsp;просто копируется в&nbsp;нужное место методом <code>blit().</code></p>
</section>
<section class="material__chapter">
<h2 id="6">Памятка по&nbsp;решению задач</h2>
<p>При решении задач считайте, что:</p>
<ul>
<li>Цвета соответствуют цветам, определенным в&nbsp;Pygame теми&nbsp;же названиями. Например, &laquo;желтый&raquo; соответствует <code>pygame.Color('yellow')</code></li>
<li>Если цвет в&nbsp;условии не&nbsp;указан, считайте цвет фона черным, цвет рисования&nbsp;&mdash; белым</li>
<li>Если толщина линии не&nbsp;указана, считайте, что фигуры должны быть нарисованы закрашенными</li>
</ul>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>