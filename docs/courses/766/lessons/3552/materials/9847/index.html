<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Игра в целом </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок PG. Игра</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Игра в&nbsp;целом</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Заставка и&nbsp;экран конца игры</a></li>
<li><a class="material__link" href="#2">Уровни игры и&nbsp;их&nbsp;загрузка</a></li>
<li><a class="material__link" href="#3">Отрисовка уровня</a></li>
<li><a class="material__link" href="#4">Камера</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;этом занятии мы&nbsp;поговорим об&nbsp;игре в&nbsp;целом. Игра&nbsp;&mdash; это достаточно большая программа, и&nbsp;важно организовать ее&nbsp;правильно. Сегодня мы&nbsp;будем проектировать заготовку для игры Mario.</p>
</section>
<section class="material__chapter">
<h2 id="1">Заставка и&nbsp;экран конца игры</h2>
<p>Практически каждая игра состоит из&nbsp;нескольких экранов, на&nbsp;которых происходит действие. Такими экранами являются <strong>заставка</strong> и&nbsp;<strong>конец игры</strong>.</p>
<p>На&nbsp;отдельном экране (а&nbsp;в&nbsp;небольших играх&nbsp;&mdash; прямо на&nbsp;экране) заставки можно расположить правила. Небольшая проблема в&nbsp;том, что Pygame не&nbsp;умеет выводить несколько строк одновременно, приходится делать это построчно вручную.</p>
<p>В&nbsp;функции <code>start_screen()</code>, приведенной ниже, мы&nbsp;организовали свой мини-игровой цикл, который выполняется до&nbsp;тех пор, пока игрок не&nbsp;нажмет клавишу на&nbsp;клавиатуре или кнопку мыши.</p>
<p>На&nbsp;экране окончания игры обычно выводится итоговый счет, авторы игры, прочая рекламная информация.</p>
<p>Преждевременный выход из&nbsp;игры возможен на&nbsp;любом экране, поэтому удобно &laquo;аварийное завершение&raquo; оформить в&nbsp;виде отдельной функции <code>terminate()</code>:</p>
<pre><code class="language-python">FPS = 50

def terminate():
    pygame.quit()
    sys.exit()

def start_screen():
    intro_text = ["ЗАСТАВКА", "",
                  "Правила игры",
                  "Если в правилах несколько строк,",
                  "приходится выводить их построчно"]

    fon = pygame.transform.scale(load_image('fon.jpg'), (WIDTH, HEIGHT))
    screen.blit(fon, (0, 0))
    font = pygame.font.Font(None, 30)
    text_coord = 50
    for line in intro_text:
        string_rendered = font.render(line, 1, pygame.Color('black'))
        intro_rect = string_rendered.get_rect()
        text_coord += 10
        intro_rect.top = text_coord
        intro_rect.x = 10
        text_coord += intro_rect.height
        screen.blit(string_rendered, intro_rect)

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                terminate()
            elif event.type == pygame.KEYDOWN or \
                    event.type == pygame.MOUSEBUTTONDOWN:
                return  # начинаем игру
        pygame.display.flip()
        clock.tick(FPS)
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-7-1.png" width="502" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="2">Уровни игры и&nbsp;их&nbsp;загрузка</h2>
<p>Уровни в&nbsp;игре удобно хранить в&nbsp;текстовых файлах. Так их&nbsp;очень удобно редактировать. В&nbsp;этом примере мы&nbsp;будем использовать всего три символа:</p>
<ol>
<li># &mdash; означает стену</li>
<li>@ &mdash; положение игрока</li>
<li>. &mdash;&nbsp;пустая клетка</li>
</ol>
<p>Например,</p>
<pre><code>...###
..##.#.####
.##..###..#
##........#
#...@..#..#
###..###..#
..#..#....#
.##.##.#.##
.#......##
.#.....##
.#######
</code></pre>
<p>Чтение карты из&nbsp;файла&nbsp;&mdash; это стандартная операция работы с&nbsp;файлами. После чтения удобно дополнить карту до&nbsp;прямоугольника.</p>
<pre><code class="language-python">def load_level(filename):
    filename = "data/" + filename
    # читаем уровень, убирая символы перевода строки
    with open(filename, 'r') as mapFile:
        level_map = [line.strip() for line in mapFile]

    # и подсчитываем максимальную длину    
    max_width = max(map(len, level_map))

    # дополняем каждую строку пустыми клетками ('.')    
    return list(map(lambda x: x.ljust(max_width, '.'), level_map))
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Отрисовка уровня</h2>
<p>С&nbsp;загруженным уровнем можно работать по-разному.</p>
<p>Для больших уровней может потребоваться большая производительность, и&nbsp;тогда стоит делать так:</p>
<ol>
<li>Сначала отрисовать неподвижные элементы карты один раз на&nbsp;отдельном Surface-e</li>
<li>А&nbsp;после выводить их&nbsp;как одну общую картинку</li>
</ol>
<p>Для &laquo;обычной жизни&raquo; достаточно сгенерировать соответствующие спрайты. И&nbsp;потом будет очень удобно проверять столкновения. Мы&nbsp;поступим именно так.</p>
<p>Изображения <strong>тайлов</strong> (клеточек) удобно хранить в&nbsp;словаре.</p>
<p>Стоит сразу определить тайлы и&nbsp;подвижные объекты в&nbsp;разные группы спрайтов.</p>
<pre><code class="language-python">tile_images = {
    'wall': load_image('box.png'),
    'empty': load_image('grass.png')
}
player_image = load_image('mario.png')

tile_width = tile_height = 50


class Tile(pygame.sprite.Sprite):
    def __init__(self, tile_type, pos_x, pos_y):
        super().__init__(tiles_group, all_sprites)
        self.image = tile_images[tile_type]
        self.rect = self.image.get_rect().move(
            tile_width * pos_x, tile_height * pos_y)


class Player(pygame.sprite.Sprite):
    def __init__(self, pos_x, pos_y):
        super().__init__(player_group, all_sprites)
        self.image = player_image
        self.rect = self.image.get_rect().move(
            tile_width * pos_x + 15, tile_height * pos_y + 5)
</code></pre>
<p>Генерацию спрайтов лучше оформить в&nbsp;виде отдельной функции, которая создаст все элементы игрового поля и&nbsp;вернет спрайт игрока.</p>
<pre><code class="language-python"># основной персонаж
player = None

# группы спрайтов
all_sprites = pygame.sprite.Group()
tiles_group = pygame.sprite.Group()
player_group = pygame.sprite.Group()

def generate_level(level):
    new_player, x, y = None, None, None
    for y in range(len(level)):
        for x in range(len(level[y])):
            if level[y][x] == '.':
                Tile('empty', x, y)
            elif level[y][x] == '#':
                Tile('wall', x, y)
            elif level[y][x] == '@':
                Tile('empty', x, y)
                new_player = Player(x, y)
    # вернем игрока, а также размер поля в клетках            
    return new_player, x, y
</code></pre>
<p>После этого для загрузки и&nbsp;отрисовки уровня нам понадобится примерно вот такой код:</p>
<pre><code class="language-python">player, level_x, level_y = generate_level(load_level('map.txt'))
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-7-2.png" width="502" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="4">Камера</h2>
<p>Если мы&nbsp;немного ошибемся в&nbsp;размерах экрана, то&nbsp;увидим, что игровое поле целиком на&nbsp;экран не&nbsp;влезает. Нам нужен скроллинг. Обычно в&nbsp;играх для этого добавляют специальный объект&nbsp;&mdash; камеру, которая &laquo;следит&raquo; за&nbsp;персонажем.</p>
<p>В&nbsp;Pygame нет специального класса камеры. Вернее, модуль камеры есть, но&nbsp;он&nbsp;предназначен для работы с&nbsp;видеокамерой, подключенной к&nbsp;компьютеру.</p>
<p>В&nbsp;простом случае камера должна выполнять две функции:</p>
<ol>
<li>Обновлять свое положение (менять viewpoint, область просмотра) и</li>
<li>Влиять на&nbsp;игровое поле таким образом, чтобы оно менялось в&nbsp;зависимости от&nbsp;положения камеры</li>
</ol>
<p>Часто игровые объекты реализуют так, чтобы они <strong>отрисовывались</strong> правильным образом, опираясь на&nbsp;положение камеры. То&nbsp;есть, объекты сохраняют свое положение в&nbsp;игровом мире и&nbsp;только в&nbsp;момент отрисовки смещаются.</p>
<p>В&nbsp;Pygame процесс отрисовки спрайтов не&nbsp;контролируется пользователем. И&nbsp;в&nbsp;простой игре вполне оправданно, чтобы камера изменяла <em>положение</em> объектов.</p>
<p>Тогда класс камеры, которая <strong>держит</strong> цель, например, главного персонажа, в&nbsp;центре окна может выглядеть так:</p>
<pre><code class="language-python">class Camera:
    # зададим начальный сдвиг камеры
    def __init__(self):
        self.dx = 0
        self.dy = 0
        
    # сдвинуть объект obj на смещение камеры
    def apply(self, obj):
        obj.rect.x += self.dx
        obj.rect.y += self.dy
    
    # позиционировать камеру на объекте target
    def update(self, target):
        self.dx = -(target.rect.x + target.rect.w // 2 - width // 2)
        self.dy = -(target.rect.y + target.rect.h // 2 - height // 2)
</code></pre>
<p>Перед началом игрового цикла создадим камеру:</p>
<pre><code class="language-python">camera = Camera()
</code></pre>
<p>И&nbsp;потом на&nbsp;каждой итерации игрового цикла будем обновлять ракурс камеры и&nbsp;корректировать положение всех объектов в&nbsp;группе <var>all_sprites</var>:</p>
<pre><code class="language-python"># изменяем ракурс камеры
camera.update(player)
# обновляем положение всех спрайтов
for sprite in all_sprites:
      camera.apply(sprite)
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-7-3.png" width="300" height="auto" /> <img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/pygame/pygame-7-4.png" width="300" height="auto" /></div>
<p>Легко сделать, чтобы камера следила за&nbsp;другим объектом или управлялась игроком.</p>
<p>Доведите до&nbsp;логического завершения разбираемую задачу, а&nbsp;затем продолжайте работать над своим проектом.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>