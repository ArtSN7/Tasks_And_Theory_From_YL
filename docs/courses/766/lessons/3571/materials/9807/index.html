<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Flask-sqlalchemy </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок sqlalchemy 2</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Flask и&nbsp;sqlalchemy</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Куки и&nbsp;сессии</a></li>
<li><a class="material__link" href="#2">Авторизация пользователя</a></li>
<li><a class="material__link" href="#3">Добавление, изменение и&nbsp;удаление данных</a></li>
<li><a class="material__link" href="#4">Отношение многие ко&nbsp;многим</a></li>
<li><a class="material__link" href="#5">Заключение</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Сегодня мы&nbsp;доделаем процесс авторизации пользователей в&nbsp;веб-приложении, а&nbsp;также рассмотрим еще несколько важных моментов, связанных с&nbsp;работой с&nbsp;библиотеками flask и&nbsp;sqlalchemy.</p>
</section>
<section class="material__chapter">
<h2 id="1">Куки и&nbsp;сессии</h2>
<p>Продолжим работать над веб-приложением, которое мы&nbsp;начали делать на&nbsp;прошлом уроке. Прежде чем писать форму логина, давайте поговорим о&nbsp;том, как работает процесс аутентификации в&nbsp;вебе. Как вы&nbsp;наверняка заметили, пока наше веб-приложение не&nbsp;запоминает никакой информации о&nbsp;клиенте между его запросами, то&nbsp;есть мы&nbsp;никак не&nbsp;проверяем, пришел&nbsp;ли следующий запрос от&nbsp;того&nbsp;же клиента или от&nbsp;другого. Чтобы удостовериться в&nbsp;том, что пользователь был на&nbsp;нашем сайте и&nbsp;уже делал какие-то действия, есть несколько способов.</p>
<p>Первый из&nbsp;них&nbsp;&mdash; <a class="material__link" href="https://ru.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener noreferrer">куки</a>. Куки&nbsp;&mdash; это небольшой фрагмент данных, который сервер устанавливает в&nbsp;браузере клиента. Это работает следующим образом:</p>
<ol>
<li>Клиент отправляет запрос на&nbsp;получение страницы от&nbsp;сервера, то&nbsp;есть вызывает какой-то из&nbsp;наших flask-обработчиков url.</li>
<li>Сервер отвечает на&nbsp;запрос и&nbsp;вместе со&nbsp;страницей ответа отправляет одно или несколько куки.</li>
<li>При всех следующих запросах клиент отправляет информацию из&nbsp;полученных куки серверу (пока не&nbsp;истечет их&nbsp;&laquo;срок годности&raquo;).</li>
</ol>
<p>Как и&nbsp;со&nbsp;всеми остальными параметрами, которые мы&nbsp;получаем от&nbsp;пользователя, работа с&nbsp;куки очень похожа на&nbsp;работу со&nbsp;словарями. Давайте сделаем вот такой небольшой пример:</p>
<pre><code class="language-python">@app.route("/cookie_test")
def cookie_test():
    visits_count = int(request.cookies.get("visits_count", 0))
    if visits_count:
        res = make_response(
            f"Вы пришли на эту страницу {visits_count + 1} раз")
        res.set_cookie("visits_count", str(visits_count + 1),
                       max_age=60 * 60 * 24 * 365 * 2)
    else:
        res = make_response(
            "Вы пришли на эту страницу в первый раз за последние 2 года")
        res.set_cookie("visits_count", '1',
                       max_age=60 * 60 * 24 * 365 * 2)
    return res
</code></pre>
<p>Сначала мы&nbsp;пытаемся получить куки по&nbsp;ключу <var>visits_count</var>, и&nbsp;если она не&nbsp;установлена у&nbsp;пользователя, получаем ноль. Ноль означает, что пользователь пришел на&nbsp;нашу страницу первый раз, о&nbsp;чем мы&nbsp;ему и&nbsp;сообщаем с&nbsp;помощью строки, которую передаем в&nbsp;функцию <var>flask.make_response</var>. После чего у&nbsp;получившегося объекта вызываем метод <var>set_cookie</var>, куда передаем имя куки, значение, а&nbsp;также максимальное время жизни, после которого браузер удалит куки.</p>
<p>Если куки уже установлено, мы&nbsp;увеличиваем счетчик на&nbsp;1&nbsp;и&nbsp;переустанавливаем куки, обновляя срок жизни. Обратите внимание: у&nbsp;куки ключи могут быть типа <var>str</var>, а&nbsp;значения&nbsp;&mdash; типа <var>str</var> или <var>bytes</var>.</p>
<p>Запустите программу, перейдите по&nbsp;адресу <code>http://127.0.0.1:5000/cookie_test</code> и&nbsp;посмотрите, как будет меняться отображаемая информация в&nbsp;браузере, когда вы&nbsp;обновляете страницу (это можно делать при помощи клавиши F5). Также значение куки можно посмотреть непосредственно в&nbsp;браузере, перейдя в&nbsp;режим разработчика при помощи клавиши F12.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/cookies.png" width="680" height="auto" /></div>
<p>Если мы&nbsp;хотим сделать не&nbsp;простой текстовый ответ, необходимо передать в&nbsp;функцию <var>make_response</var> результат функции <var>render_template</var>.</p>
<p>Например, в&nbsp;обработчике для страницы новостей это могло выглядеть примерно вот так:</p>
<pre><code class="language-python">res = make_response(render_template("index.html", news=news))
res.set_cookie("visits_count", '1', max_age=60 * 60 * 24 * 365 * 2)
</code></pre>
<p>Для удаления куки достаточно установить для нее нулевое время жизни:</p>
<pre><code class="language-python">res.set_cookie("visits_count", '1', max_age=0)
</code></pre>
<p>Куки классные, но&nbsp;у&nbsp;них есть недостатки:</p>
<ol>
<li>Вся информация, записанная в&nbsp;куки, хранится в&nbsp;открытом виде (не&nbsp;шифруется) и&nbsp;может быть доступна любому человеку для чтения и&nbsp;изменения. Поэтому в&nbsp;куки нельзя хранить пароли, данные банковских карт и&nbsp;другие чувствительные для потери данные.</li>
<li>Куки можно отключить в&nbsp;браузере, и&nbsp;если пользователь их&nbsp;отключит, мы&nbsp;об&nbsp;об&nbsp;этом не&nbsp;узнаем.</li>
<li>Куки не&nbsp;безразмерные. Каждая может хранить до&nbsp;4&nbsp;КБ данных, кроме того, у&nbsp;любого браузера есть свое ограничение на&nbsp;количество куки, которое может установить каждый сайт (это число всегда меньше&nbsp;50).</li>
<li>Куки отправляются с&nbsp;каждым запросом к&nbsp;серверу, поэтому, если установить большое число больших куки, запросы к&nbsp;серверу будут тяжелыми и&nbsp;сайт будет работать медленно.</li>
</ol>
<p>Сессии во&nbsp;Flask очень похожи на&nbsp;куки, но&nbsp;имеют большое преимущество: гарантируется, что содержимое сессии не&nbsp;может быть изменено пользователем (если у&nbsp;него нет нашего секретного ключа). Для работы с&nbsp;сессиями есть специальный объект <var>flask.session</var>, его надо импортировать. Давайте перепишем часть со&nbsp;счетчиком посещений на&nbsp;сессии:</p>
<pre><code class="language-python">@app.route("/session_test")
def session_test():
    visits_count = session.get('visits_count', 0)
    session['visits_count'] = visits_count + 1
    return make_response(
        f"Вы пришли на эту страницу {visits_count + 1} раз")
</code></pre>
<p>Сессии также хранятся в&nbsp;куках, но&nbsp;в&nbsp;зашифрованном виде. По&nbsp;умолчанию сессии существуют до&nbsp;тех пор, пока пользователь не&nbsp;закроет браузер. Чтобы продлить жизнь сессии, нужно присвоить атрибуту <var>session.permanent</var> значение True. В&nbsp;таком случае срок жизни сессии будет продлен до&nbsp;31&nbsp;дня. Если нужно еще больше (например, год) тогда после создания нашего приложения надо установить параметр PERMANENT_SESSION_LIFETIME.</p>
<pre><code class="language-python">app = Flask(__name__)
app.config['PERMANENT_SESSION_LIFETIME'] = datetime.timedelta(
    days=365
)
</code></pre>
<p>Удаление данных из&nbsp;сессии происходит так&nbsp;же, как и&nbsp;удаление пары &laquo;ключ-значение&raquo; из&nbsp;словаря. Например, это можно сделать так:</p>
<pre><code class="language-python">session.pop('visits_count', None)
</code></pre>
<p>На&nbsp;использовании объекта сессии можно построить простую систему авторизации для нашего приложения. Для этого можно после правильного ввода пользователем логина и&nbsp;пароля записывать в&nbsp;его сессию некоторое сложноподбираемое значение, которое использовать как ключ доступа к&nbsp;личным разделам пользователя. Несмотря на&nbsp;то, что значение сессии нельзя изменить, злоумышленник может перехватить значение сессии и&nbsp;начать отправлять свои запросы, представляясь другим пользователем, так как при передаче данных от&nbsp;клиента до&nbsp;сервера и&nbsp;обратно по&nbsp;протоколу HTTP данные не&nbsp;шифруются. Для шифрованной передачи используется протокол HTTPS.</p>
</section>
<section class="material__chapter">
<h2 id="2">Авторизация пользователя</h2>
<p>Для добавления функциональности авторизации пользователей можно воспользоваться библиотекой flask-login. Для начала установим библиотеку:</p>
<pre><code>pip install flask-login
</code></pre>
<p>Выполним первоначальную настройку модуля. Сначала импортируем нужный класс:</p>
<pre><code>from flask_login import LoginManager
</code></pre>
<p>Затем сразу после создания приложения flask инициализируем <var>LoginManager</var>:</p>
<pre><code class="language-python">login_manager = LoginManager()
login_manager.init_app(app)
</code></pre>
<p>Для верной работы flask-login у&nbsp;нас должна быть функция для получения пользователя, украшенная декоратором <var>login_manager.user_loader</var>. Добавим&nbsp;ее:</p>
<pre><code class="language-python">@login_manager.user_loader
def load_user(user_id):
    db_sess = db_session.create_session()
    return db_sess.query(User).get(user_id)
</code></pre>
<p>Кроме того, наша модель для пользователей должна содержать ряд методов для корректной работы flask-login, но&nbsp;мы&nbsp;не&nbsp;будем создавать их&nbsp;руками, а&nbsp;воспользуемся множественным наследованием. И&nbsp;помимо <var>SqlAlchemyBase</var> унаследуем <var>User</var> от&nbsp;<var>UserMixin</var> из&nbsp;модуля flask-login, то&nbsp;есть заголовок класса модели пользователей будет выглядеть так:</p>
<pre><code class="language-python">class User(SqlAlchemyBase, UserMixin):
</code></pre>
<p>Сделаем форму авторизации пользователя, назовем ее&nbsp;<var>LoginForm</var>. Она будет практически совпадать с&nbsp;той, что мы&nbsp;делали на&nbsp;уроке знакомства с&nbsp;flask-wtf:</p>
<pre><code class="language-python">class LoginForm(FlaskForm):
    email = EmailField('Почта', validators=[DataRequired()])
    password = PasswordField('Пароль', validators=[DataRequired()])
    remember_me = BooleanField('Запомнить меня')
    submit = SubmitField('Войти')
</code></pre>
<p>Сделаем к&nbsp;ней шаблон login.html:</p>
<pre><code class="language-python">{% extends "base.html" %}

{% block content %}
    &lt;h1&gt;Авторизация&lt;/h1&gt;
    &lt;form action="" method="post"&gt;
        {{ form.hidden_tag() }}
        &lt;p&gt;
            {{ form.email.label }}&lt;br&gt;
            {{ form.email(class="form-control", type="email") }}&lt;br&gt;
            {% for error in form.email.errors %}
                &lt;div class="alert alert-danger" role="alert"&gt;
                    {{ error }}
                &lt;/div&gt;
            {% endfor %}
        &lt;/p&gt;
        &lt;p&gt;
            {{ form.password.label }}&lt;br&gt;
            {{ form.password(class="form-control", type="password") }}&lt;br&gt;
            {% for error in form.password.errors %}
                &lt;div class="alert alert-danger" role="alert"&gt;
                    {{ error }}
                &lt;/div&gt;
            {% endfor %}
        &lt;/p&gt;
        &lt;p&gt;{{ form.remember_me() }} {{ form.remember_me.label }}&lt;/p&gt;
        &lt;p&gt;{{ form.submit(type="submit", class="btn btn-primary") }}&lt;/p&gt;
        &lt;div&gt;{{ message }}&lt;/div&gt;
    &lt;/form&gt;
{% endblock %}
</code></pre>
<p>И, наконец, сделаем обработчик адреса <code>/login</code>:</p>
<pre><code class="language-python">@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        db_sess = db_session.create_session()
        user = db_sess.query(User).filter(User.email == form.email.data).first()
        if user and user.check_password(form.password.data):
            login_user(user, remember=form.remember_me.data)
            return redirect("/")
        return render_template('login.html',
                               message="Неправильный логин или пароль",
                               form=form)
    return render_template('login.html', title='Авторизация', form=form)
</code></pre>
<p>(Не&nbsp;забудьте импортировать класс <var>LoginForm</var> и&nbsp;метод <var>login_user</var> из&nbsp;модуля flask-login.)</p>
<p>Если форма логина прошла валидацию, мы&nbsp;находим пользователя с&nbsp;введенной почтой, проверяем, введен&nbsp;ли для него правильный пароль, если&nbsp;да, вызываем функцию <var>login_user</var> модуля flask-login и&nbsp;передаем туда объект нашего пользователя, а&nbsp;также значение галочки &laquo;Запомнить меня&raquo;. После чего перенаправляем пользователя на&nbsp;главную страницу нашего приложения.</p>
<p>Давайте запустим и&nbsp;попробуем. После ввода правильного логина и&nbsp;пароля нас действительно перенаправляет на&nbsp;главную страницу веб-приложения. Но&nbsp;как понять что что-то поменялось? Для этого существует атрибут <var>flask_login.current_user</var>, доступный в&nbsp;любом обработчике URL и&nbsp;в&nbsp;шаблонах. Если пользователь залогинен, то&nbsp;там содержится объект класса <var>User</var> текущего пользователя, а&nbsp;если никто не&nbsp;авторизовался&nbsp;&mdash; анонимного пользователя.</p>
<p>Давайте добавим следующий код в&nbsp;элемент nav базового шаблона:</p>
<pre><code class="language-python">{% if current_user.is_authenticated %}
    &lt;a class="navbar-brand" href="/logout"&gt;{{ current_user.name }}&lt;/a&gt;
{% else %}
    &lt;p&gt;
        &lt;a class="btn btn-primary " href="/register"&gt;Зарегистрироваться&lt;/a&gt;
        &lt;a class="btn btn-success" href="/login"&gt;Войти&lt;/a&gt;
    &lt;/p&gt;
{% endif %}
</code></pre>
<p>Теперь после входа и&nbsp;перенаправления на&nbsp;главную страницу мы&nbsp;увидим имя залогиненного пользователя:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/flask-sql-1.png" width="680" height="auto" /></div>
<p>Теперь добавим обработчик адреса <code>/logout</code>. Для него нам не&nbsp;понадобится отдельный шаблон, поскольку это не&nbsp;отдельная страница, а&nbsp;действие.</p>
<pre><code class="language-python">@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect("/")
</code></pre>
<p>Тут все просто&nbsp;&mdash; мы&nbsp;&laquo;забываем&raquo; пользователя при помощи функции <var>logout_user</var> и&nbsp;перенаправляем его на&nbsp;главную страницу нашего приложения. Из&nbsp;интересного здесь&nbsp;&mdash; декоратор <var>login_required</var> (не&nbsp;забудьте это импортировать). Таким декоратором можно украшать обработчики страниц, на&nbsp;которые может попасть только авторизованный пользователь.</p>
<p>Давайте добавим небольшое изменение в&nbsp;главную страницу нашего приложения, чтобы для авторизованного пользователя отображались и&nbsp;его личные записи.</p>
<pre><code class="language-python">if current_user.is_authenticated:
    news = db_sess.query(News).filter(
        (News.user == current_user) | (News.is_private != True))
else:
    news = db_sess.query(News).filter(News.is_private != True)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Добавление, изменение и&nbsp;удаление данных</h2>
<p>Чтобы далеко не&nbsp;ходить, давайте рассмотрим добавление, изменение и&nbsp;удаление данных на&nbsp;примере новостей. Начнем с&nbsp;добавления. Разумеется, добавлять новости у&nbsp;нас могут только авторизованные пользователи, поэтому давайте добавим в&nbsp;шаблон отображения списка новостей кнопку, доступную только&nbsp;им:</p>
<pre><code class="language-python">{% if current_user.is_authenticated %}
    &lt;a href="news" class="btn btn-secondary"&gt;Добавить новость&lt;/a&gt;
{% endif %}
</code></pre>
<p>Создадим форму добавления новости <var>NewsForm</var>, в&nbsp;каталог forms добавим файл news.py:</p>
<pre><code class="language-python">from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField
from wtforms import BooleanField, SubmitField
from wtforms.validators import DataRequired


class NewsForm(FlaskForm):
    title = StringField('Заголовок', validators=[DataRequired()])
    content = TextAreaField("Содержание")
    is_private = BooleanField("Личное")
    submit = SubmitField('Применить')
</code></pre>
<p>Шаблон для редактирования новости news.html:</p>
<pre><code class="language-python">{% extends "base.html" %}

{% block content %}
&lt;h1&gt;Добавление новости&lt;/h1&gt;
&lt;form action="" method="post"&gt;
    {{ form.hidden_tag() }}
    &lt;p&gt;
        {{ form.title.label }}&lt;br&gt;
        {{ form.title(class="form-control") }}&lt;br&gt;
        {% for error in form.title.errors %}
            &lt;p class="alert alert-danger" role="alert"&gt;
                {{ error }}
            &lt;/p&gt;
        {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;
        {{ form.content.label }}&lt;br&gt;
        {{ form.content(class="form-control") }}&lt;br&gt;
        {% for error in form.content.errors %}
            &lt;p content="alert alert-danger" role="alert"&gt;
                {{ error }}
            &lt;/p&gt;
        {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;{{ form.is_private() }} {{ form.is_private.label }}&lt;/p&gt;
    &lt;p&gt;{{ form.submit(type="submit", class="btn btn-primary") }}&lt;/p&gt;
    {{message}}
&lt;/form&gt;
{% endblock %}
</code></pre>
<p>И&nbsp;обработчик:</p>
<pre><code class="language-python">@app.route('/news',  methods=['GET', 'POST'])
@login_required
def add_news():
    form = NewsForm()
    if form.validate_on_submit():
        db_sess = db_session.create_session()
        news = News()
        news.title = form.title.data
        news.content = form.content.data
        news.is_private = form.is_private.data
        current_user.news.append(news)
        db_sess.merge(current_user)
        db_sess.commit()
        return redirect('/')
    return render_template('news.html', title='Добавление новости', 
                           form=form)
</code></pre>
<p>Тут нет ничего такого, что мы&nbsp;уже не&nbsp;делали. Единственный интересный момент&nbsp;&mdash; сказать сессии, что мы&nbsp;изменили текущего пользователя с&nbsp;помощью метода <var>merge</var>.</p>
<p>Сделаем редактирование новости. Будем использовать уже созданную форму и&nbsp;шаблон, напишем только другой обработчик:</p>
<pre><code class="language-python">@app.route('/news/&lt;int:id&gt;', methods=['GET', 'POST'])
@login_required
def edit_news(id):
    form = NewsForm()
    if request.method == "GET":
        db_sess = db_session.create_session()
        news = db_sess.query(News).filter(News.id == id,
                                          News.user == current_user
                                          ).first()
        if news:
            form.title.data = news.title
            form.content.data = news.content
            form.is_private.data = news.is_private
        else:
            abort(404)
    if form.validate_on_submit():
        db_sess = db_session.create_session()
        news = db_sess.query(News).filter(News.id == id,
                                          News.user == current_user
                                          ).first()
        if news:
            news.title = form.title.data
            news.content = form.content.data
            news.is_private = form.is_private.data
            db_sess.commit()
            return redirect('/')
        else:
            abort(404)
    return render_template('news.html',
                           title='Редактирование новости',
                           form=form
                           )
</code></pre>
<p>Если мы&nbsp;запросили страницу записи, ищем ее&nbsp;в&nbsp;базе по&nbsp;<var>id</var>, причем автор новости должен совпадать с&nbsp;текущим пользователем. Если что-то нашли, предзаполняем форму, иначе показываем пользователю страницу 404. Такую&nbsp;же проверку на&nbsp;всякий случай делаем перед изменением новости.</p>
<p>Добавим кнопки &laquo;Изменить&raquo; и&nbsp;&laquo;Удалить&raquo; к&nbsp;каждой новости в&nbsp;списке новостей, но&nbsp;только для тех записей, автором которых является <var>current_user</var>. Немного изменим шаблон index.html.</p>
<pre><code class="language-python">{% if current_user.is_authenticated and current_user == item.user %}
    &lt;div&gt;
        &lt;a href="/news/{{ item.id }}" class="btn btn-warning"&gt;
            Изменить
        &lt;/a&gt;
        &lt;a href="/news_delete/{{ item.id }}" class="btn btn-danger"&gt;
            Удалить
        &lt;/a&gt;
    &lt;/div&gt;
{% endif %}
</code></pre>
<p>В&nbsp;адреса каждой из&nbsp;ссылок допишем <var>id</var>&nbsp;новости.</p>
<p>У&nbsp;нас получится что-то вроде:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/flask-sql-2.png" width="680" height="auto" /></div>
<p>Добавим еще обработчик удаления записи:</p>
<pre><code class="language-python">@app.route('/news_delete/&lt;int:id&gt;', methods=['GET', 'POST'])
@login_required
def news_delete(id):
    db_sess = db_session.create_session()
    news = db_sess.query(News).filter(News.id == id,
                                      News.user == current_user
                                      ).first()
    if news:
        db_sess.delete(news)
        db_sess.commit()
    else:
        abort(404)
    return redirect('/')
</code></pre>
<p>Итак, у&nbsp;нас получилось достаточно функциональное рабочее приложение. Давайте добавим еще пару штрихов.</p>
</section>
<section class="material__chapter">
<h2 id="4">Отношение многие ко&nbsp;многим</h2>
<p>Когда вы&nbsp;создавали базы данных, наверняка обратили внимание, что когда сущности связаны <strong>одна ко&nbsp;многим</strong> (у&nbsp;одного пользователя есть несколько записей, в&nbsp;одном жанре есть несколько фильмов), то&nbsp;проблем с&nbsp;проектированием базы данных не&nbsp;возникает. Трудности начинаются, когда сущности связаны <strong>многие ко&nbsp;многим</strong> (в&nbsp;одном заказе может быть несколько наименований товаров, но&nbsp;эти&nbsp;же товары могут быть во&nbsp;многих заказах). Те, кто столкнулся с&nbsp;этой проблемой, вероятно, провели исследования и&nbsp;уже знают, что в&nbsp;SQL такая ситуация решается созданием промежуточной таблицы. Давайте посмотрим, как связь <strong>многие ко&nbsp;многим</strong> можно реализовать с&nbsp;помощью sqlalchemy.</p>
<p>Давайте представим, что наши записи могут принадлежать к&nbsp;одной или нескольким категориям, чтобы можно было проще их&nbsp;фильтровать по&nbsp;интересующей пользователя теме.</p>
<p>Добавим модель <var>Category</var>, сделаем для этого новый файл category.py в&nbsp;папке data:</p>
<pre><code class="language-python">import sqlalchemy
from .db_session import SqlAlchemyBase
   
   
class Category(SqlAlchemyBase):
    __tablename__ = 'category'
    id = sqlalchemy.Column(sqlalchemy.Integer, primary_key=True, 
                           autoincrement=True)
    name = sqlalchemy.Column(sqlalchemy.String, nullable=True)
</code></pre>
<p>Кроме того, добавим перед моделью с&nbsp;категориями информацию о&nbsp;промежуточной таблице:</p>
<pre><code class="language-python">association_table = sqlalchemy.Table(
    'association',
    SqlAlchemyBase.metadata,
    sqlalchemy.Column('news', sqlalchemy.Integer,
                      sqlalchemy.ForeignKey('news.id')),
    sqlalchemy.Column('category', sqlalchemy.Integer,
                      sqlalchemy.ForeignKey('category.id'))
)
</code></pre>
<p>Тут мы&nbsp;говорим sqlalchemy, что нам нужна вспомогательная таблица <var>association</var> (не&nbsp;обязательно такое имя, часто их&nbsp;называют <code>имя_сущности1_to_имя_сущности2</code>, то&nbsp;есть в&nbsp;нашем случае <code>news_to_category</code>), которая будет содержать только несколько внешних ключей на&nbsp;каждую из&nbsp;таблиц.</p>
<p>Немного обновим модель <var>News</var>, чтобы можно было получать доступ к&nbsp;категориям новости как к&nbsp;списку:</p>
<pre><code class="language-python">categories = orm.relationship("Category",
                          secondary="association",
                          backref="news")
</code></pre>
<p>К&nbsp;сожалению, чтобы sqlalchemy применил изменения, надо удалить уже существующие таблицы в&nbsp;базе данных, которые затрагивают эти изменения. В&nbsp;данном случае необходимо удалить таблицу <var>news</var>. После перезапуска приложения таблицы будут созданы уже с&nbsp;правильной структурой. Такое поведение не&nbsp;очень удобно, скоро мы&nbsp;узнаем, как с&nbsp;этим можно справиться.</p>
<p>Не забудьте добавить в&nbsp;файл __all_models.py импорт новой модели:</p>
<pre><code class="language-python">from . import category
</code></pre>
<p>Если мы&nbsp;все сделали правильно, наша база данных станет выглядеть примерно вот так:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/flask-sql-3.png" width="680" height="auto" /></div>
<p>Теперь, когда мы&nbsp;будем вызывать метод <code>news.categories.append(category)</code> и&nbsp;передавать туда объект типа <var>Category</var>, у&nbsp;нас будет создаваться запись именно в&nbsp;промежуточной таблице.</p>
<p>Чтобы удалить категорию у&nbsp;новости, достаточно сделать:</p>
<pre><code class="language-python">news.categories.remove(category)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="5">Заключение</h2>
<p>На&nbsp;этом мы&nbsp;завершаем рассмотрение функциональности SQLalchemy, хотя в&nbsp;следующих темах будем использовать полученные знания (и&nbsp;еще вернемся к&nbsp;ней, когда будем рассматривать механизм миграций), а&nbsp;теперь нас ждет создание своего собственного API.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>