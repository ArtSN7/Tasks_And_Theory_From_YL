<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Знакомство с API </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок WEB.  API</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Знакомство с&nbsp;API</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Что такое API</a></li>
<li><a class="material__link" href="#2">Зачем нужен API?</a></li>
<li><a class="material__link" href="#3">Варианты реализации API</a></li>
<li><a class="material__link" href="#4">Немного о&nbsp;протоколах взаимодействия</a></li>
<li><a class="material__link" href="#5">Подробнее о протоколе HTTP</a></li>
<li><a class="material__link" href="#6">Знакомство с&nbsp;Yandex.Maps API</a></li>
<li><a class="material__link" href="#7">Yandex.Maps Static API</a></li>
<li><a class="material__link" href="#8">Геокодер (поиск топонимических объектов)</a></li>
<li><a class="material__link" href="#9">Обращение к&nbsp;HTTP-сервису на&nbsp;языке Python</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке рассказывается о&nbsp;том, что такое API, почему и&nbsp;для чего создается API, как изучать новый API и&nbsp;работать с&nbsp;ним. Разбирается HTTP-API на&nbsp;базе StaticMapsAPI и&nbsp;Geocoder API. Изучается принцип работы с&nbsp;HTTP-API на&nbsp;языке Python.</p>
<p>На&nbsp;этом и&nbsp;последующих уроках для работы всех примеров необходимо подключение к&nbsp;сети Интернет.</p>
</section>
<section class="material__chapter">
<h2 id="1">Что такое API</h2>
<p>Давайте представим себе, что мы&nbsp;с&nbsp;вами разработали какую-нибудь очень полезную программу. Например, электронную карту города. Программой пользуется все большее количество людей. У&nbsp;нас, конечно&nbsp;же, есть канал обратной связи, по&nbsp;которому пользователи сообщают нам об&nbsp;ошибках в&nbsp;программе и&nbsp;каких функций им&nbsp;не&nbsp;хватает. Мы&nbsp;исправляем ошибки и&nbsp;стараемся расширять функциональность. Но&nbsp;силы наши конечны, а&nbsp;пожеланий с&nbsp;ростом популярности программы становится все больше и&nbsp;больше. Делать все мы&nbsp;не&nbsp;успеваем. Да&nbsp;и&nbsp;нет смысла выполнять каждое пожелание, если мы&nbsp;понимаем, что данная функция нужна лишь очень небольшой аудитории. Но&nbsp;любым отказом мы&nbsp;расстраиваем наших пользователей, а&nbsp;это делать совсем не&nbsp;хочется. Как быть?</p>
<p>Вот одно из&nbsp;решений. Давайте вместо того, чтобы выполнять пожелания пользователей, дадим им&nbsp;инструмент, с&nbsp;помощью которого они сами смогут воплотить свои идеи. Например, можно написать библиотеку (вы&nbsp;ведь знакомы с&nbsp;библиотеками), в&nbsp;которой будут функции, если мы&nbsp;говорим про карты:</p>
<ul>
<li>Нарисовать карту</li>
<li>Нарисовать на&nbsp;ней точки, линии или какие-нибудь картинки</li>
<li>Построить маршрут по карте</li>
<li>Найти координаты какого-либо объекта и&nbsp;тому подобное</li>
</ul>
<p>Понятно, что таким образом мы&nbsp;дадим инструмент только программистам, но&nbsp;программиста можно нанять, и&nbsp;это уже не&nbsp;обязательно должен быть наш сотрудник. Если&nbsp;мы, помимо библиотеки, напишем инструкцию к&nbsp;ней, опишем ее&nbsp;функции, как ими пользоваться и&nbsp;как построить приложение на&nbsp;основе нашей библиотеки, то&nbsp;сторонний программист вполне сможет разобраться с&nbsp;ней и&nbsp;решить задачу заказчика.</p>
<p>И&nbsp;вот так мы&nbsp;как&nbsp;бы строим мостик между нашей <strong>очень полезной программой</strong> и&nbsp;программистом, который хочет пользоваться ее&nbsp;возможностями. Мостик&nbsp;&mdash; это интерфейс. В&nbsp;англоязычной терминологии это называется Application Programming Interface или сокращенно API [эй-пи-ай].</p>
<p>API существует у&nbsp;большого количества программных продуктов: от&nbsp;операционной системы до&nbsp;интернет-сервисов. API&nbsp;&mdash; это обычный этап развития программных продуктов.</p>
</section>
<section class="material__chapter">
<h2 id="2">Зачем нужен API?</h2>
<p>Как правило, API появляется, когда аудитория, использующая программный продукт, разрастается настолько, что своими силами команда-разработчик уже не&nbsp;успевает реализовывать все запросы пользователей.</p>
<p>Естественно, в&nbsp;коммерческом рабочем процессе ничто не&nbsp;делается просто так. Создавая API, разработчики обязательно понимают, какие коммерческие цели они преследуют.</p>
<p>Можно просто предоставлять API за&nbsp;деньги: продавать разовую лицензию или брать плату за&nbsp;обращение к&nbsp;функциям. Часто API&nbsp;&mdash; это средство развития платформы. Например, Windows API. Все пишут программы под ОС&nbsp;Windows, в&nbsp;результате чего выигрывает вся платформа. API может решать и&nbsp;репутационные задачи&nbsp;&mdash; создавать лояльную пользовательскую аудиторию.</p>
<p>Встречаются и&nbsp;смешанные решения: одновременно существует бесплатное API с&nbsp;определенными ограничениями (использование только в&nbsp;бесплатных открытых продуктах, с&nbsp;ограничением по&nbsp;количеству обращений) и&nbsp;его платная версия без таковых. На&nbsp;этом принципе построено большинство API в&nbsp;Яндексе.</p>
<p>Если это технически реально и&nbsp;логически осмысленно, то&nbsp;в&nbsp;интерфейс можно встраивать рекламу, которая добавляет заработок команде.</p>
<p>Полезно помнить, что API выпускается не&nbsp;просто так, и&nbsp;соотносить свои задачи с&nbsp;используемым инструментом. Особенно важно не&nbsp;забывать про возможные технические (по&nbsp;скорости работы, количеству запросов и&nbsp;т.&nbsp;п.) и&nbsp;юридические (лицензионные) ограничения использования того или иного API.</p>
</section>
<section class="material__chapter">
<h2 id="3">Варианты реализации API</h2>
<p>Давайте посмотрим, как может выглядеть API. Один из&nbsp;вариантов&nbsp;&mdash; это библиотека, собранная под одну или несколько платформ. Она может либо содержать нужные нам функции или объекты непосредственно в&nbsp;себе, либо использовать Интернет для доступа к&nbsp;удаленному серверу с&nbsp;работающим на&nbsp;нем сервисом. Чтобы начать пользоваться такой библиотекой, надо ее&nbsp;получить (скачать, например), бесплатно или заплатив ее&nbsp;стоимость, установить и&nbsp;дальше применять, как и&nbsp;любую другую библиотеку. Иногда при оплате или регистрации к&nbsp;библиотеке прилагается уникальный ключ для того, чтобы она работала.</p>
<p>Ключ&nbsp;&mdash; это хитрая последовательность символов, для которой выполняется какое-то неизвестное нам, но&nbsp;известное авторам ключа условие. Случайно сгенерировать или подобрать ключ очень сложно. Обычно достаточно сложно для того, чтобы проще и&nbsp;дешевле было получить ключ легальным способом.</p>
<p>Есть вариант, при котором скачивать не&nbsp;требуется ничего. Это возможно, если сервис реализован как удаленный, использующий для доступа какой-либо стандартный протокол. Например, HTTP. Обычно для доступа к&nbsp;такому сервису требуется иметь ключ и&nbsp;передавать его при каждом обращении к&nbsp;сервису. Ключ можно получить либо в&nbsp;автоматическом, либо в&nbsp;полуавтоматическом режиме, как правило, заполнив форму и&nbsp;выразив согласие с&nbsp;лицензионными соглашениями.</p>
<p>Протокол состоит из&nbsp;набора запросов и&nbsp;форматов ответов, предоставляемых сервисом.</p>
<p>HTTP-сервисы можно &laquo;пощупать&raquo; просто из&nbsp;браузера, поскольку протокол состоит из&nbsp;HTTP-запросов и&nbsp;ответов в&nbsp;форматах, поддерживаемых браузерами.</p>
<p>Пусть для нас изучение HTTP не&nbsp;является самоцелью, но&nbsp;остановиться на&nbsp;нем необходимо. Это тот инструмент, через который мы&nbsp;дальше будем взаимодействовать с&nbsp;различными API.</p>
</section>
<section class="material__chapter">
<h2 id="4">Немного о&nbsp;протоколах взаимодействия</h2>
<p>Мы&nbsp;уже много-много раз писали программы, которые работают только на&nbsp;одном компьютере и&nbsp;никак не&nbsp;взаимодействуют с&nbsp;внешним миром. В&nbsp;последние годы приложения, которые функционируют в&nbsp;пределах только одной машины и&nbsp;не&nbsp;смотрят &laquo;по&nbsp;сторонам&raquo;, стали достаточно большой редкостью. Практически в&nbsp;каждую, даже самую маленькую, утилиту автор или авторы старается встроить как минимум механизм автоматического обновления, который поможет быстро доставлять пользователям модули, в&nbsp;которых добавлены новые функции или исправлены ошибки. Самыми массовыми приложениями для взаимодействия в&nbsp;сети Интернет и&nbsp;корпоративных сетях Интранетах являются веб-приложения, от&nbsp;небольших сайтов, до&nbsp;огромных порталов, которые обрабатывают информацию из&nbsp;сотен источников. Но&nbsp;прежде чем мы&nbsp;начнем обращаться к&nbsp;стороннему HTTP API (а&nbsp;затем и&nbsp;создавать свой), сделаем небольшое &laquo;лирическое отступление&raquo;.</p>
<p>Все из&nbsp;вас наверняка знают, что такое компьютерная сеть, но&nbsp;не&nbsp;все задумывались о&nbsp;механизмах взаимодействия устройств внутри сети, ведь даже физическая среда распространения сигналов может быть сильно различна:</p>
<ul>
<li>Беспроводная среда (WiFi, 4G, Bluetooth)</li>
<li>Обычные провода</li>
<li>Телефонные провода</li>
<li>Оптические кабели и&nbsp;т.&nbsp;д.</li>
</ul>
<p>Разумеется, при написании своего приложения большинство программистов не&nbsp;задумывается о&nbsp;том, по&nbsp;каким физическим каналам будет происходить взаимодействие. Это стало возможным благодаря стандартизации в&nbsp;этой области и&nbsp;четкому разделению уровней взаимодействия. Сетевая модель OSI (Open systems interconnection basic reference model) представляет собой набор протоколов (стандартов, описывающих правила взаимодействия разных частей систем при передаче данных), каждый из&nbsp;которых отвечает за&nbsp;определенный уровень взаимодействия. Модель имеет семь уровней:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/api-1/OSI.svg" width="680" height="auto" /></div>
<ol>
<li>Физический, на&nbsp;котором происходит преобразование двоичных данных в&nbsp;вид, пригодный для передачи в&nbsp;среде (USB, витая пара, WiFi)</li>
<li>Канальный, на&nbsp;котором происходит физическая адресация, например, с&nbsp;использованием MAC-адресов сетевой платы</li>
<li>Сетевой, на&nbsp;котором происходит логическая адресация. Сюда относятся хорошо известные IPv4 и&nbsp;IPv6</li>
<li>Транспортный&nbsp;&mdash; для обеспечения связи между конечными точками и&nbsp;обеспечения надежности</li>
<li>Сеансовый &mdash; для обеспечения сеанса связи</li>
<li>Представительский (представления) для представления и&nbsp;шифрования/дешифрования данных.На&nbsp;вышеперечисленные уровни разработчики прикладных программ забираются нечасто, обычно при написании специализированного программного обеспечения и&nbsp;сетевых игр. Протоколы&nbsp;же последнего, седьмого, уровня нужны в&nbsp;повседневной работе гораздо чаще</li>
<li>Прикладной, на&nbsp;котором происходит доступ к&nbsp;сетевым службам (SMTP, FTP, HTTP). Именно с&nbsp;использованием протоколов прикладного уровня построен &laquo;видимый&raquo; интернет, хотя при открытии любой странички по&nbsp;протоколу HTTP ваш запрос проходит по&nbsp;всем уровням модели, превращаясь из&nbsp;данных в&nbsp;физические сигналы, затем собираясь в&nbsp;точке приема обратно для прикладного уровня. Ответ на&nbsp;запрос ждет такая&nbsp;же нелегкая судьба</li>
</ol>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/api-1/OSI-2.svg" width="680" height="auto" /></div>
<p>Более подробно про модель OSI можете почитать, например, на&nbsp;<a class="material__link" href="https://ru.wikipedia.org/wiki/Сетевая_модель_OSI" target="_blank" rel="noopener noreferrer">Википедии</a>.</p>
<p>Вообще история Интернета довольно увлекательна сама по&nbsp;себе, рекомендуем вам ознакомиться с&nbsp;ней самостоятельно, начать можно, например, на&nbsp;<a class="material__link" href="https://ru.wikipedia.org/wiki/История_Интернета" target="_blank" rel="noopener noreferrer">Википедии</a>. Мы&nbsp;в&nbsp;нее вдаваться не&nbsp;будем, отметим лишь, что самый первый веб-сайт появился 6&nbsp;августа 1991 года с&nbsp;доменным именем info.cern.ch. На&nbsp;этом сайте его создатель, Тим Бернерс-Ли, разместил описание новой технологии World Wide Web, основанной на&nbsp;протоколе HTTP, системе адресации URI и&nbsp;языке гипертекстовой разметки HTML.</p>
</section>
<section class="material__chapter">
<h2 id="5">Подробнее о протоколе HTTP</h2>
<p>Что&nbsp;же такое HTTP? Это протокол, позволяющий отправлять запросы Интернет-сервису и&nbsp;получать на&nbsp;них ответы.</p>
<p>В&nbsp;протоколе есть несколько разного вида запросов: GET, POST, HEAD, DELETE и&nbsp;т.&nbsp;д.</p>
<p>Как правило, запросы используются следующим образом:</p>
<ul>
<li>GET&nbsp;&mdash; для получения каких-либо данных с&nbsp;сервера</li>
<li>POST&nbsp;&mdash; для передачи большого объема данных на&nbsp;сервер и&nbsp;получения ответа</li>
<li>HEAD&nbsp;&mdash; для получения информации о&nbsp;данных с&nbsp;сервера</li>
<li>DELETE&nbsp;&mdash; для удаления данных с&nbsp;сервера</li>
</ul>
<p>Помимо вида запроса обычно требуется указать:</p>
<ul>
<li>Адрес сервера, которому запрос направлен</li>
<li>Путь к&nbsp;конкретной странице на&nbsp;сервере, которую необходимо получить, или к&nbsp;скрипту, который должен обработать запрос</li>
<li>Дополнительные параметры запроса</li>
<li>Вид ожидаемого ответа</li>
</ul>
<p>Протокол HTTP используется браузерами при просмотре интернет-страниц. По&nbsp;умолчанию применяется метод GET, формат ответа&nbsp;&mdash; html, json или какой-либо еще стандартный формат, и&nbsp;указывать это при каждом запросе не&nbsp;требуется. Остальная часть запроса записывается в&nbsp;виде:</p>
<pre><code>http://static-maps.yandex.ru/1.x/?ll=37.677751,55.757718&amp;spn=0.016457,0.00619&amp;l=map
</code></pre>
<p>Здесь указаны:</p>
<ul>
<li>Название протокола (http)</li>
<li>Адрес сервера, к&nbsp;которому мы&nbsp;обращаемся (static-maps.yandex.ru)</li>
<li>Путь к&nbsp;странице на&nbsp;этом сервере (до&nbsp;знака &laquo;?&raquo;) (/1.x/)</li>
<li>Параметры вида <strong>ключ=значение</strong>, разделенные амперсандом (например, ll=37.677751,55.757718)</li>
</ul>
<p>Запросы такого вида можно задавать в&nbsp;адресной строке браузера.</p>
<p>Кликните на&nbsp;приведенную ссылку и&nbsp;посмотрите на&nbsp;ответ: <a class="material__link" href="http://static-maps.yandex.ru/1.x/?ll=37.677751,55.757718&amp;spn=0.016457,0.00619&amp;l=map" target="_blank" rel="noopener noreferrer">http://static-maps.yandex.ru/1.x/?ll=37.677751,55.757718&amp;spn=0.016457,0.00619&amp;l=map</a></p>
<p>В&nbsp;браузере Chrome для этого нажмите клавишу F12.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/web-2-request.png" width="680" height="auto" /></div>
<p>Ответ состоит из&nbsp;заголовка, в&nbsp;котором указан формат ответа, статус выполнения запроса и&nbsp;сам ответ. Вы&nbsp;наверняка слышали про коды состояния HTTP:</p>
<ul>
<li>200 означает, что все прошло успешно</li>
<li>3xx&nbsp;&mdash; ошибки, связанные с&nbsp;перемещением страницы и&nbsp;т.&nbsp;п.</li>
<li>4xx&nbsp;&mdash; ошибки клиента (например, 403&nbsp;&mdash; не&nbsp;хватает прав, 404&nbsp;&mdash; файл не&nbsp;найден)</li>
<li>5xx&nbsp;&mdash; ошибки уровня приложения (запрос получен, а&nbsp;скрипт, который должен выдать ответ, ответа не&nbsp;выдал)</li>
</ul>
<p>Если возвращаться к&nbsp;браузеру, то&nbsp;из&nbsp;всего этого пользователю показывается только содержимое ответа в&nbsp;основном окне браузера. При ошибке показывается код и&nbsp;расшифровка ошибки.</p>
<p>Про другие запросы, а&nbsp;также про коды ошибок можно самостоятельно почитать на&nbsp;этой <a class="material__link" href="https://ru.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener noreferrer">странице</a>.</p>
<p>Кстати, среди кодов HTTP-ошибок есть код <strong>418</strong>. Узнайте на&nbsp;досуге, как он&nbsp;расшифровывается и&nbsp;что обозначает, это забавно.</p>
<p>Но&nbsp;давайте от&nbsp;слов перейдем к&nbsp;делу и&nbsp;попробуем пощупать Static API Яндекс.Карт.</p>
</section>
<section class="material__chapter">
<h2 id="6">Знакомство с&nbsp;Yandex.Maps API</h2>
<p>Вопрос: откуда нам знать про пути, ключи и&nbsp;их&nbsp;значения, из&nbsp;которых состоят запросы к&nbsp;API? Как понять, в&nbsp;каком формате придет ответ, и&nbsp;что он&nbsp;означает?</p>
<p>На&nbsp;все эти вопросы как раз и&nbsp;отвечает документация API. Страницу с&nbsp;документацией обычно можно обнаружить Поиском. Что&nbsp;же нужно там искать? Давайте посмотрим на&nbsp;содержание этого <a class="material__link" href="https://tech.yandex.ru/maps/mapsapi/" target="_blank" rel="noopener noreferrer">ресурса</a>.</p>
<p>Здесь описываются состав, правила работы и&nbsp;протокол API Yandex.Maps.</p>
<p>HTTP-API состоит из&nbsp;трех частей:</p>
<ul>
<li>Static API Карт (получить картинку с&nbsp;картой какой-то области с&nbsp;заданными параметрами)</li>
<li>Геокодер (поиск топонимов, то&nbsp;есть картографических объектов)</li>
<li>ППО (Поиск По&nbsp;Организациям)</li>
</ul>
<p>Кроме того, в&nbsp;документации указано, что ключ для доступа <strong>не&nbsp;нужен</strong>. Лицензионное соглашение предписывает использование API в&nbsp;некоммерческих общедоступных <strong>веб-приложениях</strong>.</p>
<p>Здесь необходимо оговориться, что в&nbsp;рамках данного курса мы&nbsp;рассматриваем серверное программирование. Для того чтобы не&nbsp;нарушать лицензионное соглашение, необходимо, чтобы итоговое приложение имело и&nbsp;веб-составляющую. Понятно, что во&nbsp;время разработки показывать результаты каждого запроса в&nbsp;веб невозможно. Никто этого и&nbsp;не&nbsp;требует. Но&nbsp;в&nbsp;итоговом приложении веб-составляющая должна быть. Пока&nbsp;же мы&nbsp;только изучаем API и&nbsp;не&nbsp;создаем программных продуктов как таковых&nbsp;&mdash; это требование нас не&nbsp;затрагивает. Но&nbsp;если в&nbsp;будущем вам предстоит им&nbsp;воспользоваться, учтите это требование сразу и&nbsp;потрудитесь его выполнить. Иначе придется использовать платную версию API.</p>
</section>
<section class="material__chapter">
<h2 id="7">Yandex.Maps Static API</h2>
<p>Static API позволяет получить изображение нужного фрагмента карты, которое можно разместить на&nbsp;сайте или в&nbsp;приложении. Такое изображение оптимизировано, &laquo;весит&raquo; не&nbsp;очень много и&nbsp;загружается быстро даже при медленном Интернете.</p>
<p>Static API возвращает изображение карты в&nbsp;ответ на&nbsp;HTTPS-запрос (HTTPS&nbsp;&mdash; защищенная разновидность HTTP). Добавляя в&nbsp;URL разные параметры и&nbsp;задавая их&nbsp;значения, вы&nbsp;можете определить центр карты, ее&nbsp;размер и&nbsp;область показа, отметить нужные объекты и&nbsp;даже отобразить пробки. При этом при каждом новом запросе будет возвращаться изображение с&nbsp;актуальными данными.</p>
<p>Документация для Static API находится на&nbsp;странице: <a class="material__link" href="https://tech.yandex.ru/maps/doc/staticapi/1.x/dg/concepts/input_params-docpage/" target="_blank" rel="noopener noreferrer">https://tech.yandex.ru/maps/doc/staticapi/1.x/dg/concepts/input_params-docpage/</a></p>
<p>Здесь можно почитать про&nbsp;то, какие параметры могут быть в&nbsp;запросе, и&nbsp;что они означают.</p>
<p>Пример запроса: <a class="material__link" href="https://static-maps.yandex.ru/1.x/?ll=37.677751,55.757718&amp;spn=0.016457,0.00619&amp;l=map" target="_blank" rel="noopener noreferrer">https://static-maps.yandex.ru/1.x/?ll=37.677751,55.757718&amp;spn=0.016457,0.00619&amp;l=map</a></p>
<p>В&nbsp;ответ придет картинка с&nbsp;картой запрошенной области.</p>
<p>Посмотрите, что означают параметры&nbsp;<var>ll</var>, <var>spn</var>, <var>l</var>&nbsp;и&nbsp;поработайте с&nbsp;ними.</p>
<p><strong>Тренировочное задание 1</strong>. C&nbsp;помощью запросов к&nbsp;API через браузер получить:</p>
<ol>
<li>Крупномасштабную схему с&nbsp;МГУ им. Ломоносова</li>
<li>Спутниковый снимок Эйфелевой башни</li>
<li>Спутниковый снимок Авачинского вулкана</li>
<li>Спутниковый снимок космодрома Байконур</li>
</ol>
<p><em>Подсказка:</em> для решения задачи можно открыть в&nbsp;браузере Я.Карты, найти объекты через поиск, щелкнуть мышкой на&nbsp;карте и&nbsp;получить координаты для параметра&nbsp;<var>ll</var>. Параметр <var>spn</var> можно подобрать экспериментально.</p>
</section>
<section class="material__chapter">
<h2 id="8">Геокодер (поиск топонимических объектов)</h2>
<p>Геокодер помогает определить координаты объекта по&nbsp;его адресу или, наоборот, установить адрес по&nbsp;координатам. К&nbsp;геокодеру можно также обращаться по&nbsp;протоколу HTTPS.</p>
<p>Для обращения к&nbsp;этому API нужен ключ, бесплатный ключ имеет ряд <a class="material__link" href="https://tech.yandex.ru/maps/geocoder/doc/desc/concepts/limits-docpage/" target="_blank" rel="noopener noreferrer">ограничений</a>, но&nbsp;он&nbsp;полностью подойдет для наших целей, получить его можно <a class="material__link" href="https://developer.tech.yandex.ru/" target="_blank" rel="noopener noreferrer">тут</a>. Кроме того мы&nbsp;сделали ключ, который может использоваться в&nbsp;рамках нашего курса всеми учащимися проекта, вот&nbsp;он:</p>
<p><strong>apikey = "40d1649f-0493-4b70-98ba-98533de7710b"</strong></p>
<p>Мы&nbsp;предлагаем вам самостоятельно ознакомиться с&nbsp;<a class="material__link" href="https://tech.yandex.ru/maps/doc/geocoder/desc/concepts/About-docpage/" target="_blank" rel="noopener noreferrer">документацией</a>, попробовать сделать запросы, понять, что означают ответы геокодера, и&nbsp;ответить на&nbsp;вопрос второго тренировочного задания.</p>
<p><strong>Тренировочное задание 2</strong>. Получите координаты Якутска и&nbsp;Магадана в&nbsp;формате JSON. Выясните, какой город находится севернее: Якутск или Магадан?</p>
</section>
<section class="material__chapter">
<h2 id="9">Обращение к&nbsp;HTTP-сервису на&nbsp;языке Python</h2>
<p>Поиграли? Замечательно. Теперь вспомните, что мы&nbsp;программируем на&nbsp;языке Python. Что&nbsp;же нужно для того, чтобы общаться с&nbsp;API Yandex.Карт из&nbsp;программы на&nbsp;Python?</p>
<p>Нужно написать программу, которая выполнит ровно те&nbsp;действия, которые вы&nbsp;только что совершили в&nbsp;браузере руками. Но&nbsp;как?</p>
<p>Нам потребуется библиотека для работы с&nbsp;протоколами http/https. Таких библиотек существует несколько. Все они позволяют передавать запросы и&nbsp;получать ответы от&nbsp;удаленных серверов. Одной из&nbsp;самых популярных библиотек для этого (ее&nbsp;мы&nbsp;и&nbsp;рассмотрим) является библиотека <a class="material__link" href="https://pypi.python.org/pypi/requests" target="_blank" rel="noopener noreferrer">requests</a>. Девиз этой библиотеки&nbsp;&mdash; HTTP for Humans (HTTP для людей). Она простая в&nbsp;освоении и&nbsp;при этом обладает очень-очень широкой функциональностью.</p>
<p>Библиотека requests не&nbsp;входит в&nbsp;стандартную библиотеку Python, поэтому перед использованием ее&nbsp;надо установить:</p>
<pre><code>pip install requests
</code></pre>
<p>Для выполнения запроса GET (вспоминаем протокол HTTP) используется функция <code>get()</code>. Разумеется, предварительно надо импортировать библиотеку :)</p>
<pre><code class="language-python">import requests

response = requests.get("http://geocode-maps.yandex.ru/1.x/?apikey=40d1649f-0493-4b70-98ba-98533de7710b&amp;geocode=Якутск&amp;format=json")
print(response, type(response))
</code></pre>
<pre><samp>&lt;Response [200]&gt; &lt;class 'requests.models.Response'&gt;</samp></pre>
<p>Если вместо &laquo;красивого&raquo; результата вы&nbsp;увидите много-много текста с&nbsp;исключениями, то, скорее всего, вы&nbsp;не&nbsp;смогли подключиться к&nbsp;серверу и&nbsp;получить ответ. В&nbsp;этом случае надо посмотреть на&nbsp;самую последнюю часть ответа и&nbsp;попытаться понять, в&nbsp;чем заключается проблема.</p>
<p>Функция <code>get()</code> возвращает объект класса <var>requests.models.Response</var>, который среди прочих содержит поля:</p>
<ul>
<li><var>status_code</var>&nbsp;&mdash; код статуса (200&nbsp;означает, что запрос выполнен успешно)</li>
<li><var>reason</var>&nbsp;&mdash; текстовая расшифровка статуса на&nbsp;английском языке (например, &laquo;Ok&raquo; или &laquo;Not Found&raquo;)</li>
<li><var>content</var>&nbsp;&mdash; ответ сервера</li>
</ul>
<p>У&nbsp;класса есть метод <code>_bool_()</code>, возвращающий True в&nbsp;случае успешного запроса и&nbsp;False в&nbsp;случае ошибки. Если произошла ошибка, то&nbsp;ответ сервера будет пустым. Таким образом, мы&nbsp;можем очень элегантно проверять успешность запроса.</p>
<p>Соберем полученные знания воедино.</p>
<p>Простейшая программа, выполняющая запрос к&nbsp;серверу, анализирующая код ответа и&nbsp;в&nbsp;случае успешного запроса печатающая полученную страницу, выглядит следующим образом:</p>
<pre><code class="language-python">import requests

# Готовим запрос.
geocoder_request = "http://geocode-maps.yandex.ru/1.x/?apikey=40d1649f-0493-4b70-98ba-98533de7710b&amp;geocode=Якутск&amp;format=json"

# Выполняем запрос.
response = requests.get(geocoder_request)
if response:
    # Запрос успешно выполнен, печатаем полученные данные.
    print(response.content)
else:
    # Произошла ошибка выполнения запроса. Обрабатываем http-статус.
    print("Ошибка выполнения запроса:")
    print(geocoder_request)
    print("Http статус:", response.status_code, "(", response.reason, ")")
</code></pre>
<pre><samp>b'{"response":{"GeoObjectCollection":{"metaDataProperty":{"GeocoderResponseMetaData":{"request":"\xd0\xaf\xd0\xba\xd1\x83\xd1\x82\xd1\x81\xd0\xba","found":"3","results":"10"}},"featureMember":[{"GeoObject":{"metaDataProperty":{"GeocoderMetaData":{"kind":"locality","text":"\xd0\xa0\xd0\xbe\xd1\x81\xd1\x81\xd0\xb8\xd1\x8f, \xd0\xa0\xd0\xb5\xd1\x81\xd0\xbf\xd1\x83\xd0\xb1\xd0\xbb\xd0\xb8\xd0\xba\xd0\xb0 \xd0\xa1\xd0\xb0\xd1\x85\xd0\xb0 (\xd0\xaf\xd0\xba\xd1\x83\xd1\x82\xd0\xb8\xd1\x8f), \xd0\xaf\xd0\xba\xd1\x83\xd1\x82\xd1\x81\xd0\xba","precision":"other","Address":{"country_code":"RU","formatted":"\xd0\xa0\xd0\xb5\xd1\x81\xd0\xbf\xd1\x83\xd0\xb1\xd0\xbb\xd0\xb8\xd0\xba\xd0\xb0 \xd0\xa1\xd0\xb0\xd1\x85\xd0\xb0 (\xd0\xaf\xd0\xba\xd1\x83\xd1\x82\xd0\xb8\xd1\x8f), \xd0\xaf\xd0\xba\xd1\x83\xd1\x82\xd1\x81\xd0\xba","Components":...</samp></pre>
<p><strong>Тренировочное задание 3</strong>. Попробуйте &laquo;испортить&raquo; запрос (например, заменив 1.x на&nbsp;1.x.1), чтобы увидеть, как обрабатывается ошибка запроса.</p>
<p>Если мы&nbsp;передадим в&nbsp;программу строку, содержащую правильно сформулированный запрос к&nbsp;API, то&nbsp;полученный ответ сможем дальше обработать в&nbsp;программе.</p>
<p>Например, из&nbsp;ответа геокодера сможем выбрать и&nbsp;отобразить отдельные поля так, чтобы ответ стал удобочитаемым для пользователя.</p>
<p>Поскольку json&nbsp;&mdash; это одним из&nbsp;популярнейших форматов обмена данными, у&nbsp;объекта <var>requests.Response</var> уже есть готовый метод <code>json()</code>, конструирующий json-объект из&nbsp;текста полученного ответа.</p>
<pre><code class="language-python">import requests

geocoder_request = "http://geocode-maps.yandex.ru/1.x/?apikey=40d1649f-0493-4b70-98ba-98533de7710b&amp;geocode=Якутск&amp;format=json"

# Выполняем запрос.
response = requests.get(geocoder_request)
if response:
    # Преобразуем ответ в json-объект
    json_response = response.json()

    # Получаем первый топоним из ответа геокодера.
    # Согласно описанию ответа, он находится по следующему пути:
    toponym = json_response["response"]["GeoObjectCollection"]["featureMember"][0]["GeoObject"]
    # Полный адрес топонима:
    toponym_address = toponym["metaDataProperty"]["GeocoderMetaData"]["text"]
    # Координаты центра топонима:
    toponym_coodrinates = toponym["Point"]["pos"]
    # Печатаем извлечённые из ответа поля:
    print(toponym_address, "имеет координаты:", toponym_coodrinates)
else:
    print("Ошибка выполнения запроса:")
    print(geocoder_request)
    print("Http статус:", response.status_code, "(", response.reason, ")")
</code></pre>
<pre><samp>Россия, Республика Саха (Якутия), Якутск имеет координаты: 129.731235 62.027757</samp></pre>
<p>Запросив изображение карты через Static API, мы&nbsp;можем отрисовать его в&nbsp;окне программы.</p>
<p>Если посмотреть в&nbsp;браузере информацию о&nbsp;странице-картинке, полученной от&nbsp;Static API, то&nbsp;можно найти формат этой картинки. Это PNG. Для того чтобы отобразить картинку на&nbsp;экране, запишем ее&nbsp;в&nbsp;файл c&nbsp;расширением .png и&nbsp;отрисуем файл с&nbsp;помощью библиотеки pygame. Давайте посмотрим, как будет выглядеть такая программа.</p>
<pre><code class="language-python">import os
import sys

import pygame
import requests

map_request = "http://static-maps.yandex.ru/1.x/?ll=37.530887,55.703118&amp;spn=0.002,0.002&amp;l=map"
response = requests.get(map_request)

if not response:
    print("Ошибка выполнения запроса:")
    print(map_request)
    print("Http статус:", response.status_code, "(", response.reason, ")")
    sys.exit(1)

# Запишем полученное изображение в файл.
map_file = "map.png"
with open(map_file, "wb") as file:
    file.write(response.content)

# Инициализируем pygame
pygame.init()
screen = pygame.display.set_mode((600, 450))
# Рисуем картинку, загружаемую из только что созданного файла.
screen.blit(pygame.image.load(map_file), (0, 0))
# Переключаем экран и ждем закрытия окна.
pygame.display.flip()
while pygame.event.wait().type != pygame.QUIT:
    pass
pygame.quit()

# Удаляем за собой файл с изображением.
os.remove(map_file)
</code></pre>
<p>Нам уже встречалась функция <code>sys.exit()</code>, когда мы&nbsp;разрабатывали приложения для PyQt. Она прекращает работу программы и&nbsp;возвращает результатом значение, переданное в&nbsp;нее в&nbsp;качестве параметра, в&nbsp;блоке по&nbsp;PyQt мы&nbsp;возвращали код ошибки&nbsp;Qt, но&nbsp;никто не&nbsp;запрещает нам возвращать информацию, которая поможет нам в&nbsp;отладке программы и&nbsp;выявлении причины завершения приложения.</p>
<p>Разумеется, отображение результатов запроса можно делать не&nbsp;только с&nbsp;помощью PyGame, но&nbsp;и&nbsp;с&nbsp;использованием виджетов PyQt. Давайте перепишем этот&nbsp;же пример:</p>
<pre><code class="language-python">import os
import sys

import requests
from PyQt5.QtGui import QPixmap
from PyQt5.QtWidgets import QApplication, QWidget, QLabel

SCREEN_SIZE = [600, 450]


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.getImage()
        self.initUI()

    def getImage(self):
        map_request = "http://static-maps.yandex.ru/1.x/?ll=37.530887,55.703118&amp;spn=0.002,0.002&amp;l=map"
        response = requests.get(map_request)

        if not response:
            print("Ошибка выполнения запроса:")
            print(map_request)
            print("Http статус:", response.status_code, "(", response.reason, ")")
            sys.exit(1)

        # Запишем полученное изображение в файл.
        self.map_file = "map.png"
        with open(self.map_file, "wb") as file:
            file.write(response.content)

    def initUI(self):
        self.setGeometry(100, 100, *SCREEN_SIZE)
        self.setWindowTitle('Отображение карты')

        ## Изображение
        self.pixmap = QPixmap(self.map_file)
        self.image = QLabel(self)
        self.image.move(0, 0)
        self.image.resize(600, 450)
        self.image.setPixmap(self.pixmap)

    def closeEvent(self, event):
        """При закрытии формы подчищаем за собой"""
        os.remove(self.map_file)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Выполните примеры. Попробуйте задать другие параметры запроса. Подумайте, можно&nbsp;ли обойтись без сохранения полученного контента в&nbsp;файл, а&nbsp;сразу передать его в&nbsp;окно pygame/PyQt?</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>