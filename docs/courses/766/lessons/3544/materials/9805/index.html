<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Введение в БД, работа с SQL-таблицами и отображение данных в PyQT 1 </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок QT SQL 1</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Введение в&nbsp;БД, работа с&nbsp;SQL-таблицами и&nbsp;отображение данных в&nbsp;PyQT. Часть 1</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Введение в&nbsp;базы данных</a></li>
<li><a class="material__link" href="#2">Основы SQL</a></li>
<li><a class="material__link" href="#3">Работаем с&nbsp;SQLite базой данных из&nbsp;Python</a></li>
<li><a class="material__link" href="#4">Возможности PyQT по&nbsp;работе с&nbsp;базами данных</a></li>
<li><a class="material__link" href="#5">SQL: Получение данных из нескольких таблиц</a></li>
<li><a class="material__link" href="#6">Заключение</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;уроке мы&nbsp;начнем знакомство с&nbsp;базами данных и&nbsp;языком SQL. Это большая тема, которая будет сопровождать нас до&nbsp;конца обучения, периодически &laquo;обрастая&raquo; новыми подробностями.</p>
</section>
<section class="material__chapter">
<h2 id="1">Введение в&nbsp;базы данных</h2>
<p>На&nbsp;прошлых уроках вы&nbsp;уже сталкивались с&nbsp;хранением данных во&nbsp;внешних источниках: простых текстовых документах, документах с&nbsp;особым форматированием, например, csv-таблицах. Однако такая организация хранения мало пригодна при большом объеме информации по&nbsp;нескольким причинам: в&nbsp;них много дублирования, из-за чего требуется значительно больше места на&nbsp;жестком диске, а&nbsp;поиск работает медленно и&nbsp;слишком &laquo;дорогой&raquo; при сколько-либо значимом количестве обращений. Разработчики промышленного программного обеспечения столкнулись с&nbsp;этими проблемами достаточно давно, и&nbsp;в&nbsp;качестве одного из&nbsp;решений еще в&nbsp;1970 году <a class="material__link" href="https://ru.wikipedia.org/wiki/Кодд,_Эдгар" target="_blank" rel="noopener noreferrer">Эдгар Кодд</a> предложил реляционную модель данных (файловые базы данных появились еще раньше&nbsp;&mdash; в&nbsp;1955&nbsp;году). Эта идея развилась в&nbsp;привычные сегодня для почти каждого программиста реляционные базы данных (БД).</p>
<p>База данных&nbsp;&mdash; это непосредственное хранилище информации, которое без инструментов для взаимодействия с&nbsp;ним не&nbsp;очень то&nbsp;и&nbsp;полезно. Такой интерфейс для общения с&nbsp;БД разработчикам и&nbsp;системным администраторам предоставляет специальное программное обеспечение&nbsp;&mdash; Системы управления базами данных (<strong>СУБД</strong>).</p>
<p>Существует достаточно много различных коммерческих и&nbsp;бесплатных СУБД. В&nbsp;наших проектах мы&nbsp;будем использовать компактную встраиваемую реляционную СУБД SQLite по&nbsp;нескольким причинам:</p>
<ol>
<li>SQLite&nbsp;&mdash; встраиваемая СУБД, поэтому не&nbsp;требует установки дополнительного программного обеспечения, а&nbsp;движок SQLite представляет собой отдельную библиотеку, написанную на&nbsp;C, которую можно использовать как составную часть вашей программы.</li>
<li>SQLite база данных представляет собой один файл, с&nbsp;которым удобно работать.</li>
<li>Исходный код SQLite передан в&nbsp;общественное достояние, то&nbsp;есть не&nbsp;существует никаких лицензионных ограничений на&nbsp;использование СУБД, как в&nbsp;некоммерческих, так и&nbsp;в&nbsp;коммерческих целях.</li>
<li>Большая часть дополнительных инструментов для работы с&nbsp;SQLite бесплатна.</li>
<li>И, наконец, в&nbsp;составе стандартной библиотеки Python уже содержится библиотека для работы с&nbsp;SQLite, даже не&nbsp;придется ничего устанавливать с&nbsp;использованием pip.</li>
</ol>
<p>Но&nbsp;не&nbsp;надо думать, что раз &laquo;SQLite&raquo; имеет слово &laquo;lite&raquo; в&nbsp;названии, то&nbsp;это какая-то &laquo;игрушечная&raquo; СУБД, которая используется только для обучения и&nbsp;при создании &laquo;настоящего&raquo; программного обеспечения не&nbsp;используется. Простота и&nbsp;удобство встраивания SQLite привели к&nbsp;тому, что библиотека используется в&nbsp;браузерах, музыкальных плеерах и&nbsp;многих других программах, например: Skype, Viber, Яндекс.Браузер, Google Chrome, Mozilla Firefox, Safari, Opera, Adobe Lightroom и&nbsp;т.&nbsp;д.</p>
<p>Данные в&nbsp;SQLite базе данных, как и&nbsp;в&nbsp;любых других реляционных&nbsp;БД, хранятся с&nbsp;помощью таблиц и&nbsp;связей между этими таблицами. Если говорить в&nbsp;терминах баз данных, то&nbsp;таблицы&nbsp;&mdash; это сущности, а&nbsp;связи&nbsp;&mdash; отношения между этими сущностями. Строго говоря, проектирование и&nbsp;использование баз данных&nbsp;&mdash; серьезная область знаний в&nbsp;информационных технологиях, существует несколько разных профессий, специалисты в&nbsp;каждой из&nbsp;которых отвечают за&nbsp;отдельные части жизненного цикла базы данных. Поэтому рассмотреть все детали в&nbsp;рамках нашего курса, очевидно, не&nbsp;получится, и&nbsp;мы&nbsp;постараемся сосредоточиться на&nbsp;основных понятиях этой предметной области, которые вам пригодятся с&nbsp;вероятностью около ста процентов.</p>
</section>
<section class="material__chapter">
<h2 id="2">Основы SQL</h2>
<p>Давайте рассмотрим модельный пример SQLite-базы данных. Она представляет собой хранилище информации о&nbsp;фильмах: название, год выпуска, жанр и&nbsp;продолжительность в&nbsp;минутах. Каждое поле занимает определенный объем в&nbsp;зависимости от&nbsp;типа данных: целочисленный, строковый или используемый для хранения времени. Подробнее о&nbsp;том, какие типы данных поддерживает SQLite, можно почитать <a class="material__link" href="https://www.sqlite.org/datatype3.html" target="_blank" rel="noopener noreferrer">тут</a>.</p>
<p>Как мы&nbsp;уже говорили, отмечая недостатки хранения информации в&nbsp;csv-файлах, при хранении информации о&nbsp;каждом фильме полностью придется занимать место под название жанра. Поскольку у&nbsp;нас может быть в&nbsp;общем случае сотни тысяч записей о&nbsp;фильмах и&nbsp;всего несколько десятков разных названий жанров, хранить эту информацию в&nbsp;таком виде очень расточительно по&nbsp;отношению к&nbsp;ресурсам. В&nbsp;реляционных базах данных в&nbsp;подобных случаях создается дополнительная таблица, в&nbsp;которой в&nbsp;нашем случае будем хранить пару формата <strong>Ключ: Значение</strong>, где в&nbsp;качестве ключа используется уникальный целочисленный идентификатор (id), а&nbsp;в&nbsp;качестве значения&nbsp;&mdash; название жанра (title). А&nbsp;в&nbsp;первой таблице просто хранится ссылка на&nbsp;вторую.</p>
<p>Итак у&nbsp;нас есть база данных <a class="material__link" href="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/films_db.sqlite" target="_blank" rel="noopener noreferrer">films_db.sqlite</a>. Давайте сначала посмотрим, как она выглядит в&nbsp;виде визуализации:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/qt-6-1.png" width="300" height="auto" /></div>
<p>Такие визуализации используют достаточно часто для наглядного представления таблиц и&nbsp;связей, и&nbsp;называются они ER-диаграммами (сокращение от&nbsp;Entity-Relation или Сущность-Отношение).</p>
<p>Итак, разберем, что есть в&nbsp;нашей базе данных. Есть две таблицы-сущности: films для хранения информации о&nbsp;фильмах и&nbsp;genres для хранения информации о&nbsp;жанрах. Таблица genres состоит всего из&nbsp;двух полей: id&nbsp;и&nbsp;title, в&nbsp;которых для каждого жанра хранится его идентификатор и&nbsp;название соответственно.</p>
<p>Таблица films чуть сложнее. Там есть поля&nbsp;id, title, year, genre, duration для хранения идентификатора фильма, его названия, года выпуска, идентификатора жанра и&nbsp;длительности в&nbsp;минутах.</p>
<p>Кроме того, как видно на&nbsp;диаграмме, между таблицами есть связь, которая говорит о&nbsp;том, что номер жанра genre у&nbsp;записи films соответствует записи в&nbsp;таблице genres с&nbsp;таким&nbsp;же значением идентификатора.</p>
<p>Для работы с&nbsp;базами данных был придуман специальный язык&nbsp;&mdash; SQL (structured query language&nbsp;&mdash; &laquo;язык структурированных запросов&raquo;). Прежде чем начать работать с&nbsp;БД из&nbsp;Python, давайте немного попрактикуемся в&nbsp;написании запросов с&nbsp;помощью отдельного программного продукта. <a class="material__link" href="https://sqlitestudio.pl/" target="_blank" rel="noopener noreferrer">SQLiteStudio</a>&nbsp;&mdash; официальный менеджер SQLite баз данных. Менеджеры баз данных&nbsp;&mdash; это специальный класс&nbsp;ПО, предназначенный для удобного создания и&nbsp;управления базами данных, написания и&nbsp;отладки SQL-запросов.</p>
<p>Скачайте и&nbsp;установите SQLiteStudio.</p>
<p>Первое, что необходимо сделать после установки&nbsp;&mdash; добавить нашу базу. Для этого в&nbsp;основном меню необходимо выбрать пункт <strong>Add a&nbsp;Database</strong> и&nbsp;в&nbsp;открывшемся окне указать путь к&nbsp;файлу нашей&nbsp;БД.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/qt-6-2.png" width="420" height="auto" /></div>
<p>Если все прошло успешно, можно писать запросы. Для этого необходимо открыть редактор SQL. Его логотип выглядит как свиток бумаги с&nbsp;карандашом. Интерфейс редактора состоит из&nbsp;двух частей: первая, где пишется сам запрос, и&nbsp;вторая, где отображаются результаты.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/qt-6-3.png" width="680" height="auto" /></div>
<p>Основной командой для получения какой-либо информации из&nbsp;БД является команда <var>SELECT</var>. Ее&nbsp;базовый синтаксис выглядит так:</p>
<pre><code class="language-python">SELECT перечень_полей FROM имя_таблицы
        WHERE условие
</code></pre>
<p>Кроме этого, есть и&nbsp;различные модификаторы этой команды. Например, <code>ORDER BY&nbsp;ПОЛЕ</code>&nbsp;&mdash; тогда результаты будут выведены в&nbsp;отсортированном виде по&nbsp;заданному полю или нескольким полям, а&nbsp;в&nbsp;условии может быть вложенный запрос.</p>
<p>Напишем наш первый запрос. Получим все фильмы, выпущенные в&nbsp;2010&nbsp;году.</p>
<pre><code class="language-python">SELECT * FROM Films
    WHERE year = 2010
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/qt-6-4.png" width="469" height="auto" /></div>
<p>Символ <code>*</code> обозначает, что нам необходимо получить все поля. Однако очень часто нам нужно получить только одно или два поля. Модифицируем запрос так, чтобы выводилось только название.</p>
<pre><code class="language-python">SELECT title FROM Films
    WHERE year = 2010
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/qt-6-5.png" width="228" height="auto" /></div>
<p>Условий может быть и&nbsp;несколько: работают все знакомые нам логические операторы NOT, AND и&nbsp;OR. Например, выберем фильмы, выпущенные после 2005 года с&nbsp;продолжительностью от&nbsp;40&nbsp;минут до&nbsp;1,5&nbsp;часов:</p>
<pre><code class="language-python">SELECT * FROM Films
    WHERE year &gt; 2005 AND duration &gt;= 45 AND duration &lt;= 90
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/qt-6-6.png" width="649" height="auto" /></div>
<p>А&nbsp;как вывести все фильмы определенного жанра, например, <strong>фантастика</strong>? Конечно, можно сходить в&nbsp;таблицу genres и&nbsp;посмотреть, какой id&nbsp;у&nbsp;жанра фантастика, а&nbsp;потом написать запрос вроде такого:</p>
<pre><code class="language-python">SELECT title FROM films 
    WHERE genre = 8
</code></pre>
<p>Но&nbsp;это плохой путь, потому что через некоторое время данные могут измениться, и&nbsp;id&nbsp;у&nbsp;фантастики может стать другим, тогда наш запрос будет давать ошибочный результат. Поэтому правильным решением в&nbsp;данной ситуации будет написать подзапрос, который сам найдет нам необходимое значение&nbsp;id.</p>
<pre><code class="language-python">SELECT title FROM Films 
    WHERE genre=(
SELECT id FROM genres 
    WHERE title = 'фантастика')
</code></pre>
<p>Сначала выполнится внутренний запрос: из&nbsp;таблицы <var>genres</var> будет получен id&nbsp;для записи с&nbsp;title&laquo;Фантастика&raquo;, а&nbsp;затем будет выполнено сравнение и&nbsp;выведен результат.</p>
<p>Помимо того, может быть выполнено сравнение не&nbsp;с&nbsp;одним элементом, а&nbsp;проверка на&nbsp;попадание в&nbsp;список. Это делается с&nbsp;помощью уже знакомого нам оператора <var>IN</var>. Например, так можно выбрать фильмы, продолжительность которых строго 45&nbsp;или 90&nbsp;минут:</p>
<pre><code class="language-python">SELECT title, duration FROM Films 
WHERE duration IN (45, 90)
</code></pre>
<p>Кроме уже операторов знакомых нам по&nbsp;Python, SQL содержит еще и&nbsp;ряд тех, которых в&nbsp;Python нет. Давайте рассмотрим несколько из&nbsp;них.</p>
<p>Оператор <var>BETWEEN</var>&nbsp;&mdash; проверяет, попадает&nbsp;ли заданное значение в&nbsp;диапазон (включая границы).</p>
<pre><code class="language-python">SELECT * FROM Films
    WHERE (year &gt; 2005) AND duration BETWEEN 45 AND 60 
</code></pre>
<p>Оператор <var>LIKE</var> позволяет проверить, насколько похожа та&nbsp;или иная строка на&nbsp;заданный шаблон. Для шаблонов используются специальные символы:</p>
<ul>
<li><code>%</code>&nbsp;&mdash; обозначает любое количество, в&nbsp;том числе нулевое, любых символов</li>
<li><code>_</code>&nbsp;&mdash; обозначает один любой символ</li>
</ul>
<p>Давайте получим список фильмов, у&nbsp;которых первая буква в&nbsp;названии&nbsp;&mdash; <strong>А</strong> и&nbsp;третья&nbsp;&mdash; <strong>к</strong>.</p>
<pre><code class="language-python">SELECT * FROM Films
    WHERE title like 'А_к%'
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/qt-6-7.png" width="412" height="auto" /></div>
<p>Оператор <var>LIKE</var> работает также в&nbsp;паре с&nbsp;<var>NOT</var>. Например, получим список фильмов, у&nbsp;которых третья буква в&nbsp;названии не&nbsp;равна&nbsp;<strong>д</strong>, а&nbsp;последняя не&nbsp;равна <strong>a</strong>.</p>
<pre><code class="language-python">SELECT * FROM films
    WHERE title NOT LIKE '__д%а'
</code></pre>
<p>Кроме этого, есть возможность избавиться от&nbsp;повторов, используя в&nbsp;запросе специальный оператор&nbsp;&mdash; <code>DISTINCT</code>. Например, вот так можно получить список годов, в&nbsp;которые выходили фильмы в&nbsp;нашей базе данных, без повторений.</p>
<pre><code class="language-python">SELECT DISTINCT year FROM Films
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Работаем с&nbsp;SQLite базой данных из&nbsp;Python</h2>
<p>Так как различных СУБД достаточно много, крайне неудобно было&nbsp;бы, если при переходе на&nbsp;новую СУБД приходилось&nbsp;бы с&nbsp;нуля изучать библиотеку для работы с&nbsp;ней. Чтобы избежать таких ситуаций, есть специальный стандарт <strong>PEP 249</strong> (Python Database API Specification v2.0), в&nbsp;котором, помимо всего прочего, описано, какой интерфейс должна предоставлять программисту любая библиотека для работы с&nbsp;базами данных. Поэтому, какую&nbsp;бы СУБД вы&nbsp;не&nbsp;выбрали для управления хранением данных вашего приложения, принципы работы с&nbsp;ней будут очень похожи. Для работы с&nbsp;SQLite из&nbsp;Python используется библиотека sqlite3, которая реализует этот стандарт.</p>
<p>PEP 249 оперирует такими понятиями, как подключения и&nbsp;курсоры:</p>
<ul>
<li><strong>Подключение</strong>&nbsp;&mdash; объект, в&nbsp;котором чаще всего указывается либо путь к&nbsp;файлу, либо путь к&nbsp;серверу. Он&nbsp;отвечает только за&nbsp;подключение к&nbsp;БД и, соответственно, отключение от&nbsp;нее</li>
<li><strong>Курсор</strong>&nbsp;&mdash; объект, в&nbsp;котором непосредственно производится работа с&nbsp;БД</li>
</ul>
<p>Напишем программу (пока что без графического интерфейса), которая получает результаты одного из&nbsp;рассмотренных выше запросов и&nbsp;выводит их&nbsp;в&nbsp;консоль.</p>
<pre><code class="language-python"># Импорт библиотеки
import sqlite3

# Подключение к БД
con = sqlite3.connect("films_db.sqlite")

# Создание курсора
cur = con.cursor()

# Выполнение запроса и получение всех результатов
result = cur.execute("""SELECT * FROM films
            WHERE year = 2010""").fetchall()

# Вывод результатов на экран
for elem in result:
    print(elem)

con.close()
</code></pre>
<pre><samp>(248, 'Алиса в стране чудес', 2010, 13, 201)
(4382, 'Железный человек 2', 2010, 11, 287)
(9138, 'Ноттингем', 2010, 11, 188)
(15495, 'Утомленные солнцем: Предстояние', 2010, 2, 139)</samp></pre>
<p>Как можно заметить, результат запроса&nbsp;&mdash; это список кортежей.</p>
<p>Метод <code>.fetchall()</code> возвращает все полученные элементы. Существует еще метод <code>.fetchone()</code>, возвращающий, как несложно догадаться, только первый элемент, и&nbsp;метод <code>.fetchmany(n)</code>, возвращающий n&nbsp;первых записей.</p>
<p>Для запросов очень часто необходимо указывать какие-либо параметры, в&nbsp;нашем случае: год выпуска, продолжительность фильма и&nbsp;т.&nbsp;д. Для этого существует удобный синтаксис. Вместо значения в&nbsp;запросе указывается вопросительный знак, а&nbsp;затем вторым параметром в&nbsp;итерируемом объекте (чаще всего в&nbsp;кортеже) указываются необходимые значения для подстановки.</p>
<pre><code class="language-python">result = cur.execute("""SELECT * FROM films
            WHERE year = ? and duration &gt; ?""", (2010, 90)).fetchall()
</code></pre>
<p>Важно не&nbsp;забыть, что, если мы&nbsp;указываем кортеж из&nbsp;одного элемента, нам все равно необходимо после него поставить запятую.</p>
<pre><code class="language-python">result = cur.execute("""SELECT * FROM Films
            WHERE year = ?""", (2009,)).fetchall()
</code></pre>
<p>Давайте добавим к&nbsp;нашему приложению графический пользовательский интерфейс. Напишем программу, которая будет отображать результаты введенного запроса в&nbsp;таблице QTableWidget.</p>
<p>С&nbsp;помощью QtDesigner создадим интерфейс: поле для ввода запроса, таблица для отображения результатов и&nbsp;кнопка для запуска выполнения запроса. Работа с&nbsp;данными из&nbsp;таблицы базы данных с&nbsp;помощью виджета QTableWidget полностью аналогична тому, что мы&nbsp;рассматривали на&nbsp;прошлом уроке во&nbsp;время работы с .csv-файлами.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/pyqt-6/qt-6-8.png" width="540" height="auto" /></div>
<pre><code class="language-python">import sqlite3
import sys

from PyQt5 import uic
from PyQt5.QtWidgets import QApplication
from PyQt5.QtWidgets import QMainWindow, QTableWidgetItem


class DBSample(QMainWindow):
    def __init__(self):
        super().__init__()
        uic.loadUi('UI1.ui', self)
        self.connection = sqlite3.connect("films_db.sqlite")
        self.pushButton.clicked.connect(self.select_data)
        # По умолчанию будем выводить все данные из таблицы films
        self.textEdit.setPlainText("SELECT * FROM films")
        self.select_data()

    def select_data(self):
        # Получим результат запроса, 
        # который ввели в текстовое поле
        query = self.textEdit.toPlainText()
        res = self.connection.cursor().execute(query).fetchall()
        # Заполним размеры таблицы
        self.tableWidget.setColumnCount(5)
        self.tableWidget.setRowCount(0)
        # Заполняем таблицу элементами
        for i, row in enumerate(res):
            self.tableWidget.setRowCount(
                self.tableWidget.rowCount() + 1)
            for j, elem in enumerate(row):
                self.tableWidget.setItem(
                    i, j, QTableWidgetItem(str(elem)))

    def closeEvent(self, event):
        # При закрытии формы закроем и наше соединение 
        # с базой данных
        self.connection.close()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = DBSample()
    ex.show()
    sys.exit(app.exec())
</code></pre>
</section>
<section class="material__chapter">
<h2 id="4">Возможности PyQT по&nbsp;работе с&nbsp;базами данных</h2>
<p>В&nbsp;курсе мы&nbsp;и&nbsp;дальше будем говорить про работу с&nbsp;базами данных как можно более обще, но&nbsp;нельзя не&nbsp;отметить&nbsp;то, что у&nbsp;PyQT (как и&nbsp;у&nbsp;некоторых других больших библиотек) есть своя универсальная надстройка для работы с&nbsp;БД&nbsp;&mdash; модуль PyQt5.QtSql. Рассмотрим простейший пример: отобразим все данные из&nbsp;таблицы films.</p>
<pre><code class="language-python">import sys

from PyQt5.QtSql import QSqlDatabase, QSqlTableModel
from PyQt5.QtWidgets import QWidget, QTableView, QApplication


class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        # Зададим тип базы данных
        db = QSqlDatabase.addDatabase('QSQLITE')
        # Укажем имя базы данных
        db.setDatabaseName('films_db.sqlite')
        # И откроем подключение
        db.open()

        # QTableView - виджет для отображения данных из базы
        view = QTableView(self)
        # Создадим объект QSqlTableModel,
        # зададим таблицу, с которой он будет работать,
        #  и выберем все данные
        model = QSqlTableModel(self, db)
        model.setTable('films')
        model.select()

        # Для отображения данных на виджете
        # свяжем его и нашу модель данных
        view.setModel(model)
        view.move(10, 10)
        view.resize(617, 315)

        self.setGeometry(300, 100, 650, 450)
        self.setWindowTitle('Пример работы с QtSql')


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    ex.show()
    sys.exit(app.exec())
</code></pre>
<p>Общий принцип работы с&nbsp;модулем следующий:</p>
<ul>
<li>Создаем и&nbsp;настраиваем объект QSqlDatabase для связи с&nbsp;базой данных</li>
<li>С&nbsp;помощью QSqlTableModel или QSqlQueryModel получаем и&nbsp;управляем данными из&nbsp;базы данных</li>
<li>С&nbsp;помощью виджета QTableView отображаем данные в&nbsp;табличном виде</li>
</ul>
<p>Подробнее почитать про работу с&nbsp;базами данных, использованием модуля QtSql можно почитать в&nbsp;официальной <a class="material__link" href="https://doc.qt.io/qt-5/sql-programming.html" target="_blank" rel="noopener noreferrer">документации</a>.</p>
</section>
<section class="material__chapter">
<h2 id="5">SQL: Получение данных из нескольких таблиц</h2>
<p>Язык SQL позволяет при помощи одного запроса получать информацию сразу из нескольких таблиц в базе данных. Рассмотрим для примера базу данных <a class="material__link" href="https://yastatic.net/s3/lyceum/content/presentation/Chinook_Sqlite.sqlite" target="_blank" rel="noopener noreferrer">Chinook_Sqlite.sqlite</a></p>
<p>В ней много таблиц, но нас интересуют только некоторые.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://contest.yandex.ru/testsys/statement-image?imageId=1abd6854107cadb975d54191d7b1c272f50f5b300bb8af37f4ef12ee6436a19d" height="auto" /></div>
<p>В таблице <strong>Album</strong> в колонке <strong>ArtistId</strong> содержится код артиста из таблицы <strong>Artist</strong>. Каждому артисту может принадлежать несколько или ноль альбомов. Чтобы получить сразу данные из двух таблиц <strong>Album</strong> и <strong>Artist</strong> можно использовать команды <var>INNER JOIN</var>, <var>LEFT JOIN</var>.</p>
<p>Приведенный ниже запрос вернет названия альбомов и соответствующие им имена артистов.</p>
<pre><code class="language-python">SELECT
    album.Title,
    artist.Name
FROM
    album
INNER JOIN artist
    ON artist.ArtistId = album.ArtistId;
</code></pre>
<p>Вот, что мы получим:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/presentation/photo_2021-10-11%2012.23.26.jpeg" width="auto" height="auto" /></div>
<p>В этом примере команда <var>INNER JOIN</var> сопоставляет каждую строку из таблицы <strong>Album</strong> с каждой строкой из таблицы <strong>Artist</strong> основываясь на условии <var>artist.ArtistId = album.ArtistId</var>, которое указано после ключевого слова <var>ON</var>. Если условие выполняется, то значения из обеих таблиц для колонок, которые мы указали в секции <var>SELECT</var> запроса, добавляются в результат его выполнения. Таким образом, если для альбома не будет найдено соответствие в таблице с артистами или наоборот, то такие записи <strong>не будут добавлены в результат выполнения запроса</strong>.</p>
<p>Приведенный ниже запрос так же вернет названия альбомов и соответствующие им имена артистов.</p>
<pre><code class="language-python">SELECT
    album.Title,
    artist.Name
FROM
    album
LEFT JOIN artist
    ON artist.ArtistId = album.ArtistId;
</code></pre>
<p>В этом примере команда <var>LEFT JOIN</var> выберет <strong>все записи из таблицы <strong>Album</strong> </strong>(таблица находится слева от команды) и для тех строк, для которых выполняется условие <var>artist.ArtistId = album.ArtistId</var>, указанное после ключевого слова <var>ON</var>, сопоставит строку из таблицы <strong>Artist</strong>. Если же для каких-то строк условие не выполнится, то колонки, получаемые из таблицы <strong>Artist</strong> <strong>останутся пустыми (null)</strong>.</p>
<p>В одном запросе можно использовать неограниченное количество соединений (JOIN'ов). В запросе приведенном ниже мы выберем названия всех треков из таблицы <strong>Track</strong> добавим к нему название жанра из таблицы <strong>Genre</strong>, название альбома из таблицы <strong>Album</strong> и имя артиста из таблицы <strong>Artist</strong>, и упорядочим результат по имени трека.</p>
<pre><code class="language-python">SELECT
    Track.Name as TrackName,
    Genre.Name as GenreName,
    Album.Title as AlbumTitle,
    Artist.Name
FROM
    Track
LEFT JOIN Genre ON Track.GenreId = Genre.GenreId
LEFT JOIN Album ON Track.AlbumId = Album.AlbumId
LEFT JOIN Artist ON Album.ArtistId = Artist.ArtistId
ORDER BY TrackName;
</code></pre>
<p>Результат:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/presentation/photo_2021-10-11%2012.23.24.jpeg" width="auto" height="auto" /></div>
<p>Результаты запросов с соединениями (JOIN) также можно фильтровать при помощи команды <var>WHERE</var>. Добавим в предыдущий запрос условие, для получения только треков исполнителя "U2".</p>
<pre><code class="language-python">SELECT
    Track.Name as TrackName,
    Genre.Name as GenreName,
    Album.Title as AlbumTitle,
    Artist.Name
FROM
    Track
LEFT JOIN Genre ON Track.GenreId = Genre.GenreId
LEFT JOIN Album ON Track.AlbumId = Album.AlbumId
LEFT JOIN Artist ON Album.ArtistId = Artist.ArtistId
WHERE Artist.Name = "U2"
ORDER BY TrackName;
</code></pre>
<p>Результат:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/presentation/photo_2021-10-11%2012.23.22.jpeg" width="auto" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="6">Заключение</h2>
<p>Итак, сегодня мы&nbsp;познакомились с&nbsp;базами данных в&nbsp;целом, подробнее остановились на&nbsp;реляционных на&nbsp;примере SQLite. Изучили одну из&nbsp;основных конструкций SQL&nbsp;&mdash; запрос SELECT для выборки произвольных данных из&nbsp;БД (разумеется, увидели только небольшую часть возможностей, более детально можно почитать <a class="material__link" href="http://www.sqlitetutorial.net/" target="_blank" rel="noopener noreferrer">тут</a>). Кроме того, посмотрели, как подключаться и&nbsp;взаимодействовать с&nbsp;базами данных из&nbsp;Python-приложений.</p>
<p>На&nbsp;следующем уроке мы&nbsp;продолжим работу с&nbsp;базами данных и&nbsp;посмотрим, как можно манипулировать данными: создавать новые записи, изменять и&nbsp;удалять существующие.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>