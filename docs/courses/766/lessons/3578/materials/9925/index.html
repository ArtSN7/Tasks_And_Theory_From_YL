<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Чат-боты 2 (Telegram) </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Чат-боты Tlg</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Чат-боты 2. Telegram</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Мессенджер Telegram</a></li>
<li><a class="material__link" href="#2">Как завести пользователя в&nbsp;Телеграме?</a></li>
<li><a class="material__link" href="#3">API python-telegram-bot</a></li>
<li><a class="material__link" href="#4">Эхо-бот</a></li>
<li><a class="material__link" href="#5">Подключение через прокси-сервер</a></li>
<li><a class="material__link" href="#6">Обработка команд</a></li>
<li><a class="material__link" href="#7">Создание клавиатуры в&nbsp;диалоге пользователя</a></li>
<li><a class="material__link" href="#8">Установка и&nbsp;удаление таймера</a></li>
<li><a class="material__link" href="#9">Создание сценариев диалогов</a></li>
<li><a class="material__link" href="#10">Передача пользовательских данных в&nbsp;сценарии</a></li>
<li><a class="material__link" href="#11">Использование HTTP-API в&nbsp;телеграм-ботах</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке рассказывается про реализацию telegram API в&nbsp;виде библиотеки на&nbsp;примере telegram-bot-API. Мы&nbsp;будем учиться на&nbsp;конкретных задачах: разберем устройство telegram-бота и&nbsp;узнаем об&nbsp;основных возможностях API, создав несколько простых ботов.</p>
</section>
<section class="material__chapter">
<h2 id="1">Мессенджер Telegram</h2>
<p>Для начала разберемся, что такое Telegram, что такое telegram-bot и&nbsp;какие задачи можно решать с&nbsp;помощью этой технологии.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Телеграм</strong></p>
<p>Телеграм&nbsp;&mdash; это мессенджер (программа для обмена сообщениями), реализованный по&nbsp;клиент-серверной архитектуре. Используя сервер для создания диалога между двумя клиентами, Телеграм пересылает через него или напрямую текстовые сообщения, а&nbsp;также изображения, видео или документы других форматов.</p>
</section>
<p>Подробнее о&nbsp;нем можно почитать <a class="material__link" href="https://ru.wikipedia.org/wiki/Telegram" target="_blank" rel="noopener noreferrer">тут</a>.</p>
<p>Что&nbsp;же такое <strong>телеграм-бот</strong>?</p>
<p>Представьте, что у&nbsp;нас есть зарегистрированный аккаунт. Все сообщения, присылаемые на&nbsp;него, попадают на&nbsp;вход некоторой программе, а&nbsp;выход этой программы отправляется в&nbsp;виде сообщения тому, от&nbsp;кого пришло исходное сообщение. Это и&nbsp;есть бот. Иными словами, Телеграм-бот&nbsp;&mdash; это специальный пользователь, поведением которого управляет некоторая программа. Технически для сервера нет разницы, является данный пользователь человеком или ботом: для сервера оба клиента выглядят одинаково. Эта идеология очень похожа на&nbsp;пользователей-сообществ в&nbsp;vk.com.</p>
<p>API, которое мы&nbsp;изучим, позволит удобным образом получать сообщения от&nbsp;пользователей, обрабатывать их&nbsp;и&nbsp;отсылать ответы. Вся системная часть (получение ключей, шифрование, маршрутизация и&nbsp;т.&nbsp;д.) остается зоной ответственности библиотеки и&nbsp;архитектуры Telegram. Разработчику&nbsp;же дается удобный интерфейс, поэтому создателю нужно только реализовать логику поведения бота.</p>
<p>Какие задачи можно решать Телеграм-ботом?</p>
<p>Все ограничивается только фантазией. Приведем несколько примеров:</p>
<ul>
<li>Автоответчики. Все ситуации, когда требуется однозначный ответ на&nbsp;запрос. Например, бот может сообщать телефоны и&nbsp;другие контакты организации, ее&nbsp;рабочее время или предоставлять другую справочную информацию по&nbsp;запросу</li>
<li>Интерфейс доступа к&nbsp;веб-сервисам. Бот может выполнять запросы к&nbsp;различным API и&nbsp;отдавать ответы в&nbsp;виде телеграм-сообщений</li>
<li>Сценарии действий. Бот может пройти по&nbsp;какому-либо сценарию, задать пользователю определенные вопросы и&nbsp;собрать ответы на&nbsp;них. Например, при регистрации в&nbsp;каком-либо сервисе или при заявке на&nbsp;услугу</li>
<li>Игры. Бот умеет пересылать картинки, поэтому можно создавать любые игры, не&nbsp;требующие мгновенной реакции. Например, подумайте, как реализовать игру в&nbsp;шахматы?</li>
<li>Куда фантазия заведет (умные дома, управление автомобильной сигнализацией и&nbsp;т.&nbsp;д. Но&nbsp;помним о&nbsp;безопасности!)</li>
</ul>
</section>
<section class="material__chapter">
<h2 id="2">Как завести пользователя в&nbsp;Телеграме?</h2>
<p>Прежде чем мы&nbsp;сможем писать программу для бота, надо его зарегистрировать. Для этого нужно присвоить ему номер, который раздает &laquo;отец всех ботов&raquo;. Тоже, кстати, бот, с&nbsp;именем <strong>@BotFather</strong> (такая вот рекурсия).</p>
<p>В&nbsp;режиме диалога он&nbsp;задаст несколько вопросов о&nbsp;назначении бота, поможет выбрать для него имя и&nbsp;выдаст специальный токен&nbsp;&mdash; уникальный ключ, с&nbsp;помощью которого в&nbsp;дальнейшем система будет идентифицировать нашего бота.</p>
<p>Подробная информация находится <a class="material__link" href="https://core.telegram.org/bots#6-botfather" target="_blank" rel="noopener noreferrer">здесь</a>. Очень рекомендуем предварительно с&nbsp;ней ознакомиться. Если кратко:</p>
<ul>
<li>Необходимо связаться с <a class="material__link" href="https://telegram.me/botfather" target="_blank" rel="noopener noreferrer">@BotFather</a>, дать ему команду <code>/newbot</code> и&nbsp;ответить на&nbsp;его вопросы</li>
<li>Придумать имя (name) для бота (это имя будет указано в&nbsp;чатах с&nbsp;ботом)</li>
<li>Придумать системное имя (username) (оно будет использоваться для логина бота на&nbsp;сервер. Это имя должно быть уникальным и&nbsp;обязано оканчиваться на&nbsp;&laquo;bot&raquo;)</li>
</ul>
<p>А&nbsp;дальше надо написать собственно бота. Давайте разберемся, как это делать.</p>
</section>
<section class="material__chapter">
<h2 id="3">API python-telegram-bot</h2>
<p>Полное описание Telegram Bot API находится <a class="material__link" href="https://core.telegram.org/bots/api" target="_blank" rel="noopener noreferrer">здесь</a>.</p>
<p>Над API реализована обертка в&nbsp;виде библиотеки python-telegram-bot. Она делает написание кода более удобным. Как и&nbsp;в&nbsp;случае с&nbsp;vk.com, telegram предоставляет API в&nbsp;виде доступа к&nbsp;базовым примитивам системы. Это делается для того, чтобы дать пользователям API возможность максимально свободно и&nbsp;гибко применять возможности системы.</p>
<p>Однако на&nbsp;практике такая свобода и&nbsp;гибкость нужна далеко не&nbsp;всем. Подавляющее большинство программ, использующих API, повторяют одни и&nbsp;те&nbsp;же сценарии. При этом программисты вынуждены многократно повторять один и&nbsp;тот&nbsp;же код. Чтобы освободить разработку от&nbsp;этого, выпускается обертка над базовым API, реализующая большинство общих сценариев. При этом можно использовать и&nbsp;сам базовый API.</p>
<p>В&nbsp;итоге для обычных сценариев не&nbsp;приходится писать лишний код, но&nbsp;при этом можно сделать и&nbsp;то, что в&nbsp;эти базовые сценарии не&nbsp;вписывается.</p>
<p>Установим библиотеку:</p>
<pre><code>pip install python-telegram-bot[ext] --upgrade
</code></pre>
<p>У&nbsp;этой библиотеки есть неплохая документация, которая находится <a class="material__link" href="https://python-telegram-bot.readthedocs.io/en/stable/" target="_blank" rel="noopener noreferrer">тут</a>. Кроме того, в&nbsp;репозитории библиотеки есть ряд <a class="material__link" href="https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/README.md" target="_blank" rel="noopener noreferrer">примеров программ</a>, изучая которые можно понять, как ей&nbsp;правильно пользоваться и&nbsp;как выглядят типовые операции.</p>
<p>Библиотека <strong>python-telegram-bot версии 20</strong> написана с использованием <var>asyncio.</var> Чтобы материал, изложенный в уроке был понятнее рекомендуем сначала изучить материалы урока <strong>"Введение в асинхронное программирование"</strong>.</p>
</section>
<section class="material__chapter">
<h2 id="4">Эхо-бот</h2>
<p>Давайте разберем простейший пример.</p>
<p>Это <strong>Эхо-бот</strong>, то&nbsp;есть бот, который просто присылает полученное текстовое сообщение назад. Обычно такие боты используются системой для проверки связи.</p>
<p>Устройство телеграм-бота очень похоже на&nbsp;Flask веб-приложение (да&nbsp;и&nbsp;вообще на&nbsp;все&nbsp;то, чем мы&nbsp;занимаемся на&nbsp;втором году обучения): мы&nbsp;создаем обработчики для различных действий пользователя, а&nbsp;потом запускаем приложение, которое ждет этих действий и&nbsp;реагирует соответственно. В&nbsp;терминах библиотеки это выглядит следующим образом:</p>
<p><var>Applicaton</var> &rarr; <var>Handlers</var> &rarr; <var>start</var> &rarr; <var>wait_for_the_end</var></p>
<p>Входом в&nbsp;программу-бота является <var>Application</var>. Это объект, получающий на&nbsp;вход сообщения от&nbsp;telegram-сервера. Задача этого объекта&nbsp;&mdash; организация сетевого взаимодействия между клиентом и&nbsp;сервером.</p>
<p>Полученные сообщения <var>Application</var> передает <var>Dispatcher</var>&rsquo;у, который автоматически создается внутри <var>Application</var>&rsquo;а.</p>
<p>Диспечер отвечает за&nbsp;вызов обработчиков сообщений. Как и&nbsp;следует из&nbsp;названия объекта, он&nbsp;перенаправляет сообщения внутри программы (от&nbsp;англ. dispatch&nbsp;&mdash; пересылать).</p>
<p>Диспечер хранит обработчики сообщений&nbsp;&mdash; <var>handler</var>&rsquo;ы. Это функции, а точнее, корутины, имеющие определенную сигнатуру, получающие на&nbsp;вход сообщения уже определенных типов с&nbsp;информацией о&nbsp;том, от&nbsp;каких пользователей пришли данные сообщения.</p>
<p>Внутри <var>Application</var>&rsquo;а реализован цикл приема-передачи сообщений.</p>
<p>Таким образом, программа-бот должна:</p>
<ol>
<li>Создать объект <var>Application</var>, передав ему токен, полученный от&nbsp;@BotFather.</li>
<li>Получить корутины-обработчики для сообщений и&nbsp;команд и&nbsp;зарегистрировать их.</li>
<li>Запустить цикл приема и&nbsp;обработки сообщений.</li>
<li>Дожидаться окончания/прерывания работы программы.</li>
</ol>
<p>Приведем пример кода, реализующего простейший эхо-бот, который объяснит эту теорию.</p>
<pre><code class="language-python"># Импортируем необходимые классы.
import logging
from telegram.ext import Application, MessageHandler, filters
from config import BOT_TOKEN

# Запускаем логгирование
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.DEBUG
)

logger = logging.getLogger(__name__)


# Определяем функцию-обработчик сообщений.
# У неё два параметра, updater, принявший сообщение и контекст - дополнительная информация о сообщении.
async def echo(update, context):
    # У объекта класса Updater есть поле message,
    # являющееся объектом сообщения.
    # У message есть поле text, содержащее текст полученного сообщения,
    # а также метод reply_text(str),
    # отсылающий ответ пользователю, от которого получено сообщение.
    await update.message.reply_text(update.message.text)


def main():
    # Создаём объект Application.
    # Вместо слова "TOKEN" надо разместить полученный от @BotFather токен
    application = Application.builder().token(BOT_TOKEN).build()

    # Создаём обработчик сообщений типа filters.TEXT
    # из описанной выше асинхронной функции echo()
    # После регистрации обработчика в приложении
    # эта асинхронная функция будет вызываться при получении сообщения
    # с типом "текст", т. е. текстовых сообщений.
    text_handler = MessageHandler(filters.TEXT, echo)

    # Регистрируем обработчик в приложении.
    application.add_handler(text_handler)

    # Запускаем приложение.
    application.run_polling()


# Запускаем функцию main() в случае запуска скрипта.
if __name__ == '__main__':
    main()
</code></pre>
<p>Каждый из&nbsp;использованных классов подробно описан в&nbsp;документации:</p>
<ul>
<li><a class="material__link" href="https://docs.python-telegram-bot.org/en/stable/telegram.ext.application.html" target="_blank" rel="noopener noreferrer">Application</a></li>
<li><a class="material__link" href="https://python-telegram-bot.readthedocs.io/en/stable/telegram.ext.messagehandler.html" target="_blank" rel="noopener noreferrer">MessageHandler</a></li>
<li><a class="material__link" href="https://python-telegram-bot.readthedocs.io/en/stable/telegram.message.html" target="_blank" rel="noopener noreferrer">Message</a></li>
</ul>
<p>Теперь бота можно запустить как обычный python-скрипт.</p>
<p>Найдите его по&nbsp;имени или системному имени из&nbsp;любого Telegram-клиента и&nbsp;попробуйте с&nbsp;ним пообщаться. В&nbsp;ответ на&nbsp;любое текстовое сообщение бот пришлет его назад.</p>
</section>
<section class="material__chapter">
<h2 id="5">Подключение через прокси-сервер</h2>
<p>К&nbsp;сожалению, у&nbsp;некоторых провайдеров заблокированы интернет-адреса серверов, на&nbsp;которых размещено API Telegram. В&nbsp;этом случае необходимо либо разместить бота на&nbsp;ресурсе, с&nbsp;которого есть доступ к&nbsp;серверам, либо использовать подключение через промежуточный прокси-сервер. Сначала установим дополнительный модуль:</p>
<pre><code>pip install python-telegram-bot[socks]
</code></pre>
<p>Теперь для того, чтобы подключиться через прокси, необходимо указать настройки сервера при создании <var>Application</var>:</p>
<pre><code class="language-python">from telegram.ext import ApplicationBuilder

proxy_url = "socks5://user:pass@host:port"

app = ApplicationBuilder().token("TOKEN").proxy_url(proxy_url).build()
</code></pre>
</section>
<section class="material__chapter">
<h2 id="6">Обработка команд</h2>
<p>У&nbsp;внимательного ученика при виде строчки:</p>
<pre><code class="language-python">text_handler = MessageHandler(filters.TEXT, echo)
</code></pre>
<p>должно возникнуть два вопроса:</p>
<ol>
<li>Какие еще типы обработчиков существуют?</li>
<li>Какие еще фильтры сообщений существуют?</li>
</ol>
<p>Ответим сначала на&nbsp;первый вопрос.</p>
<p>Кроме сообщений бот может получать <strong>команды</strong>, <strong>inline-запросы</strong> и&nbsp;некоторые другие объекты. Все возможные варианты перечислены <a class="material__link" href="https://docs.python-telegram-bot.org/en/stable/telegram.ext.handlers-tree.html" target="_blank" rel="noopener noreferrer">здесь</a>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Команда</strong></p>
<p>Команда&nbsp;&mdash; это особое сообщение, начинающееся с&nbsp;символа &laquo;/&raquo;. Команда предполагает какое-либо конкретное действие бота.</p>
</section>
<p>Есть несколько стандартных команд. Например:</p>
<ul>
<li><strong>/start</strong> (команда начала общения с&nbsp;ботом, обычно она присылает сообщение о&nbsp;возможностях бота и&nbsp;как с&nbsp;ним общаться)</li>
<li><strong>/help</strong> (в&nbsp;ответ на&nbsp;команду бот присылает инструкцию по&nbsp;работе с&nbsp;собой)</li>
</ul>
<p>Команды, на&nbsp;которые отвечает бот, могут быть любыми, в&nbsp;зависимости от&nbsp;назначения бота.</p>
<p>Добавим обработчики команд <strong>/start</strong> и&nbsp;<strong>/help</strong>.</p>
<p>По&nbsp;аналогии с&nbsp;обработкой сообщений, обработчик команд нужно создать из&nbsp;функции и&nbsp;зарегистрировать в&nbsp;приложении.</p>
<pre><code class="language-python"># Добавим необходимый объект из модуля telegram.ext
from telegram.ext import CommandHandler


# Напишем соответствующие функции.
# Их сигнатура и поведение аналогичны обработчикам текстовых сообщений.
async def start(update, context):
    """Отправляет сообщение когда получена команда /start"""
    user = update.effective_user
    await update.message.reply_html(
        rf"Привет {user.mention_html()}! Я эхо-бот. Напишите мне что-нибудь, и я пришлю это назад!",
    )


async def help_command(update, context):
    """Отправляет сообщение когда получена команда /help"""
    await update.message.reply_text("Я пока не умею помогать... Я только ваше эхо.")




# Зарегистрируем их в приложении перед
# регистрацией обработчика текстовых сообщений.
# Первым параметром конструктора CommandHandler я
# вляется название команды.
application.add_handler(CommandHandler("start", start))
application.add_handler(CommandHandler("help", help_command))
</code></pre>
<p>Также откорректируем строку <code class="language-python">text_handler = MessageHandler(filters.TEXT,
        echo)</code> запишем ее так: <code class="language-python">text_handler = MessageHandler(filters.TEXT &amp; ~filters.COMMAND,
            echo)</code>, таким способом мы укажем, что обработчик <strong>echo</strong> будет использован только для обработки текстовых сообщений, но не для обработки команд.</p>
</section>
<section class="material__chapter">
<h2 id="7">Создание клавиатуры в&nbsp;диалоге пользователя</h2>
<p>Одна из&nbsp;возможных задач бота&nbsp;&mdash; предоставлять разную справочную информацию. Мы&nbsp;уже знаем, что для реализации такого поведения можно завести специальные команды. Однако для пользователя вводить команды&nbsp;&mdash; дело сравнительно долгое. А&nbsp;если он&nbsp;пришел к&nbsp;боту с&nbsp;мобильного телефона, то&nbsp;и&nbsp;просто неудобное.</p>
<p>Для того чтобы справиться с&nbsp;этой трудностью, в&nbsp;API сделан механизм предразмеченных ответов. Если предполагается, что собеседник будет пользоваться какими-либо командами бота, можно вывести набор кнопок, каждая из&nbsp;которых присылает боту определенную команду. Это делает взаимодействие с&nbsp;ботом быстрее, удобнее и&nbsp;понятнее.</p>
<p>Давайте рассмотрим пример. Разработаем бот-справочник, который будет сообщать некоторую справочную информацию о&nbsp;фирме. Для начала: адрес, телефон, сайт и&nbsp;время работы.</p>
<p>Заведем четыре команды: /address, /phone, /site, /work_time, каждая из&nbsp;которых будет просто присылать пользователю текстовое сообщение с&nbsp;нужной информацией.</p>
<pre><code class="language-python"># Напишем соответствующие функции.
async def help(update, context):
    await update.message.reply_text(
        "Я бот справочник.")


async def address(update, context):
    await update.message.reply_text(
        "Адрес: г. Москва, ул. Льва Толстого, 16")


async def phone(update, context):
    await update.message.reply_text("Телефон: +7(495)776-3030")


async def site(update, context):
    await update.message.reply_text(
        "Сайт: http://www.yandex.ru/company")


async def work_time(update, context):
    await update.message.reply_text(
        "Время работы: круглосуточно.")


def main():
    application = Application.builder().token(BOT_TOKEN).build()
    application.add_handler(CommandHandler("address", address))
    application.add_handler(CommandHandler("phone", phone))
    application.add_handler(CommandHandler("site", site))
    application.add_handler(CommandHandler("work_time", work_time))
    application.add_handler(CommandHandler("help", help))
    application.run_polling()
</code></pre>
<p>Теперь создадим клавиатуру с&nbsp;четырьмя кнопками для этих команд. Для этого воспользуемся классом <var>ReplyKeyboardMarkup</var>. Чтобы им&nbsp;воспользоваться, нужно импортировать его из&nbsp;модуля telegram:</p>
<pre><code class="language-python">from telegram import ReplyKeyboardMarkup
</code></pre>
<p>Первым параметром конструктора <var>ReplyKeyboardMarkup</var> является список кнопок. Обратите внимание: в&nbsp;примере список состоит из&nbsp;двух подсписков, каждый из&nbsp;которых определяет строчку кнопок.</p>
<pre><code class="language-python">reply_keyboard = [['/address', '/phone'],
                  ['/site', '/work_time']]
markup = ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=False)
</code></pre>
<p>Если передать все четыре строчки в&nbsp;виде одного списка, то&nbsp;получим клавиатуру с&nbsp;четырьмя кнопками в&nbsp;одну строку.</p>
<p>Параметр <var>one_time_keyboard</var> указывает, нужно&nbsp;ли скрыть клавиатуру после нажатия на&nbsp;одну из&nbsp;кнопок (<code>one_time_keyboard = True</code>, клавиатура получается одноразовой) или не&nbsp;нужно (<code>one_time_keyboard
            = False</code>, как у&nbsp;нас в&nbsp;примере).</p>
<p>Для того чтобы клавиатура появилась в&nbsp;диалоге у&nbsp;пользователя, необходимо добавить ее&nbsp;в&nbsp;качестве параметра <var>reply_markup</var> в&nbsp;функцию <var>reply_text</var>. Тогда, помимо текста, API перешлет и&nbsp;размеченную клавиатуру.</p>
<pre><code class="language-python">async def start(update, context):
    await update.message.reply_text(
        "Я бот-справочник. Какая информация вам нужна?",
        reply_markup=markup
    )
</code></pre>
<p>Переданная однажды клавиатура будет оставаться в&nbsp;диалоге в&nbsp;свернутом или развернутом виде до&nbsp;тех пор, пока клиенту не&nbsp;перешлют новую или не&nbsp;укажут явно, что переданную клавиатуру надо удалить.</p>
<p>Для удаления нужно в&nbsp;качестве значения параметра <var>reply_markup</var> передать объект специального класса: <var>ReplyKeyboardRemove</var>.</p>
<pre><code class="language-python">from telegram import ReplyKeyboardRemove


async def close_keyboard(update, context):
    await update.message.reply_text(
        "Ok",
        reply_markup=ReplyKeyboardRemove()
    )


application.add_handler(CommandHandler("close", close_keyboard))
</code></pre>
</section>
<section class="material__chapter">
<h2 id="8">Установка и&nbsp;удаление таймера</h2>
<p>Рассмотрим еще одну возможность API python-telegram-bot&nbsp;&mdash; установку таймера.</p>
<p>Таймер позволяет выполнить действие не&nbsp;сразу, а&nbsp;через некоторое время. Например, периодически проверять доступность какого-либо сайта, напомнить о&nbsp;чем-нибудь и&nbsp;т.&nbsp;д.</p>
<p>Для этих целей у&nbsp;бота есть очередь задач, в&nbsp;которую мы&nbsp;можем добавлять свои задачи. Делается это следующим образом:</p>
<pre><code class="language-python">TIMER = 5  # таймер на 5 секунд


def remove_job_if_exists(name, context):
    """Удаляем задачу по имени.
    Возвращаем True если задача была успешно удалена."""
    current_jobs = context.job_queue.get_jobs_by_name(name)
    if not current_jobs:
        return False
    for job in current_jobs:
        job.schedule_removal()
    return True


# Обычный обработчик, как и те, которыми мы пользовались раньше.
async def set_timer(update, context):
    """Добавляем задачу в очередь"""
    chat_id = update.effective_message.chat_id
    # Добавляем задачу в очередь
    # и останавливаем предыдущую (если она была)
    job_removed = remove_job_if_exists(str(chat_id), context)
    context.job_queue.run_once(task, TIMER, chat_id=chat_id, name=str(chat_id), data=TIMER)

    text = f'Вернусь через 5 с.!'
    if job_removed:
        text += ' Старая задача удалена.'
    await update.effective_message.reply_text(text)
</code></pre>
<p>Задача&nbsp;&mdash; это корутина с&nbsp;одним параметром&nbsp;&mdash; контекстом.</p>
<p>Обратите внимание: сообщение мы&nbsp;отправляем, используя объект <var>bot</var> внутри контекста, а&nbsp;не&nbsp;<var>updater</var>. Это обращение к&nbsp;базовому API.</p>
<pre><code class="language-python">async def task(context):
    """Выводит сообщение"""
    await context.bot.send_message(context.job.chat_id, text=f'КУКУ! 5c. прошли!')
</code></pre>
<p>Задачу из&nbsp;очереди можно отменить. Добавим для этого специальную команду:</p>
<pre><code class="language-python">async def unset(update, context):
    """Удаляет задачу, если пользователь передумал"""
    chat_id = update.message.chat_id
    job_removed = remove_job_if_exists(str(chat_id), context)
    text = 'Таймер отменен!' if job_removed else 'У вас нет активных таймеров'
    await update.message.reply_text(text)
</code></pre>
<p>Регистрируем обработчики.</p>
<pre><code class="language-python">    application.add_handler(CommandHandler("set", set_timer))
    application.add_handler(CommandHandler("unset", unset))
</code></pre>
</section>
<section class="material__chapter">
<h2 id="9">Создание сценариев диалогов</h2>
<p>Обсуждая сферу применения ботов, мы&nbsp;говорили о&nbsp;разных сценариях, в&nbsp;которых пользователю последовательно задаются вопросы, а&nbsp;бот собирает ответы и&nbsp;что-то дальше с&nbsp;ними делает. Чем это отличается от&nbsp;того, что мы&nbsp;делали раньше? Главным образом тем, что в&nbsp;предыдущем примере мы&nbsp;<strong>не&nbsp;хранили контекст</strong> &laquo;разговора&raquo;. То&nbsp;есть бот &laquo;отвечал&raquo; на&nbsp;один вопрос и&nbsp;тут&nbsp;же &laquo;забывал&raquo;, кто и&nbsp;о&nbsp;чем его спрашивал.</p>
<p>Сценарий&nbsp;&mdash; это серия вопросов или реплик, в&nbsp;которой бот &laquo;помнит&raquo;, какие вопросы он&nbsp;уже задавал пользователю, какие ответы получил и&nbsp;что спрашивать дальше.</p>
<p>Для создания сценариев в&nbsp;telegram-bot-python есть специальный обработчик диалога: <var>ConversationHandler</var>.</p>
<p>Рассмотрим пример его использования.</p>
<pre><code class="language-python">    conv_handler = ConversationHandler(
        # Точка входа в диалог.
        # В данном случае &mdash; команда /start. Она задаёт первый вопрос.
        entry_points=[CommandHandler('start', start)],

        # Состояние внутри диалога.
        # Вариант с двумя обработчиками, фильтрующими текстовые сообщения.
        states={
            # Функция читает ответ на первый вопрос и задаёт второй.
            1: [MessageHandler(filters.TEXT &amp; ~filters.COMMAND, first_response)],
            # Функция читает ответ на второй вопрос и завершает диалог.
            2: [MessageHandler(filters.TEXT &amp; ~filters.COMMAND, second_response)]
        },

        # Точка прерывания диалога. В данном случае &mdash; команда /stop.
        fallbacks=[CommandHandler('stop', stop)]
    )

    application.add_handler(conv_handler)
</code></pre>
<p>В&nbsp;обычных обработчиках есть одна-единственная функция. Диспечер вызывает&nbsp;ее, если выполняется условие фильтра в&nbsp;обработчике. Сама&nbsp;же функция возвращает None, или, другими словами, не&nbsp;возвращает никакого значения.</p>
<p>Здесь мы&nbsp;регистрируем обработчик, состоящий из&nbsp;других обработчиков. Как&nbsp;же такой механизм работает?</p>
<p>В&nbsp;самом начале работы программы активен только обработчик <var>start</var>, описанный в&nbsp;параметре <var>entry_points</var>. Ровно так&nbsp;же, как если&nbsp;бы мы&nbsp;без создания <var>ConversationHandler</var> просто зарегистрировали&nbsp;бы его в&nbsp;Диспечере, как делали ранее.</p>
<p>Однако, в&nbsp;отличие от&nbsp;предыдущих случаев, обработчик <var>start</var> должен будет вернуть значение. И&nbsp;это значение укажет Диспечеру, какой обработчик выбрать для <strong>последующих</strong> сообщений.</p>
<p>В&nbsp;нашем случае мы&nbsp;вернем&nbsp;1, и&nbsp;это укажет Диспечеру, что к&nbsp;следующему сообщению надо применить обработчик из&nbsp;параметра <var>states</var> c&nbsp;индексом 1&nbsp;&mdash; <code>states[1]</code>. То&nbsp;есть тот, что связан с&nbsp;функцией <code>first_response()</code>. Получается, что, помимо обработки самой команды /start, мы&nbsp;еще и&nbsp;указываем Диспечеру, как работать дальше.</p>
<p>В&nbsp;свою очередь, <code>first_response()</code> вернет значение 2. После этого к&nbsp;следующим сообщениям Диспечер применит обработчик из&nbsp;<code>states[2]</code>.</p>
<p>Для окончания диалога нужно вернуть специальное значение <code>ConversationHandler.END</code>. После этого Диспечер будет, как и&nbsp;в&nbsp;самом начале, пробовать применить обработчик <var>entry_points</var>.</p>
<p>Обработчик из&nbsp;параметра <var>fallbacks</var> активен все время работы диалога и&nbsp;деактивируется после выхода из&nbsp;него. Он&nbsp;служит для прерывания диалога.</p>
<p>Давайте напишем упомянутые выше функции.</p>
<pre><code class="language-python">async def start(update, context):
    await update.message.reply_text(
        "Привет. Пройдите небольшой опрос, пожалуйста!\n"
        "Вы можете прервать опрос, послав команду /stop.\n"
        "В каком городе вы живёте?")

    # Число-ключ в словаре states &mdash;
    # втором параметре ConversationHandler'а.
    return 1
    # Оно указывает, что дальше на сообщения от этого пользователя
    # должен отвечать обработчик states[1].
    # До этого момента обработчиков текстовых сообщений
    # для этого пользователя не существовало,
    # поэтому текстовые сообщения игнорировались.


async def first_response(update, context):
    # Это ответ на первый вопрос.
    # Мы можем использовать его во втором вопросе.
    locality = update.message.text
    await update.message.reply_text(
        f"Какая погода в городе {locality}?")
    # Следующее текстовое сообщение будет обработано
    # обработчиком states[2]
    return 2


async def second_response(update, context):
    # Ответ на второй вопрос.
    # Мы можем его сохранить в базе данных или переслать куда-либо.
    weather = update.message.text
    logger.info(weather)
    await update.message.reply_text("Спасибо за участие в опросе! Всего доброго!")
    return ConversationHandler.END  # Константа, означающая конец диалога.
    # Все обработчики из states и fallbacks становятся неактивными.


async def stop(update, context):
    await update.message.reply_text("Всего доброго!")
    return ConversationHandler.END
</code></pre>
<p>Рассмотрим таблицу состояний созданного сценария:</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<tbody>
<tr>
<td>&nbsp;</td>
<td><strong>До диалога</strong></td>
<td><strong>После /start</strong></td>
<td><strong>После first_response</strong></td>
<td><strong>После second_response</strong></td>
<td><strong>После /stop</strong></td>
</tr>
<tr>
<td><strong>/start</strong></td>
<td style="text-align: center;">Активна</td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">Активна</td>
<td style="text-align: center;">Активна</td>
</tr>
<tr>
<td><strong>first_response</strong></td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">Активна</td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">&mdash;</td>
</tr>
<tr>
<td><strong>second_response</strong></td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">Активна</td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">&mdash;</td>
</tr>
<tr>
<td><strong>/stop</strong></td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">Активна</td>
<td style="text-align: center;">Активна</td>
<td style="text-align: center;">&mdash;</td>
<td style="text-align: center;">&mdash;</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>До&nbsp;начала диалога активна только команда /start. Остальные части диалога игнорируются.</li>
<li>После выполнения команда /start перестает работать, а&nbsp;активной становится команда /stop и&nbsp;обработчик <var>first_response</var>.</li>
<li>После выполнения обработчика <var>first_response</var> он&nbsp;деактивируется, а&nbsp;его место занимает обработчик <var>second_response</var>.</li>
<li>После выполнения обработчика <var>second_response</var> деактивируются он&nbsp;и&nbsp;команда /stop, и&nbsp;снова включается команда /start.</li>
</ol>
<p>Пускай наш бот находится в&nbsp;каком-то состоянии и&nbsp;может перейти в&nbsp;другие состояния. Описывать возможности перехода можно либо таблицей состояний, как мы&nbsp;делали выше, либо диаграммой состояний. Диаграмма состояний&nbsp;&mdash; это схема, на&nbsp;которой изображены состояния (например, в&nbsp;виде прямоугольников или кружков) и&nbsp;стрелками отмечены доступные переходы в&nbsp;из&nbsp;одних состояний в&nbsp;другие. Часто над стрелками пишут условия, при которых осуществляется тот или иной переход.</p>
<p>Диаграмма состояний нашего бота изображена на&nbsp;рисунке ниже.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/second-year/telegram-bot.svg" width="680" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="10">Передача пользовательских данных в&nbsp;сценарии</h2>
<p>Часто нужно хранить не&nbsp;только предыдущий ответ пользователя, но&nbsp;и&nbsp;большее количество данных, полученных в&nbsp;ходе диалога.</p>
<p>Для хранения и&nbsp;передачи таких данных телеграм поддерживает специальный словарь <var>context.user_data</var>.</p>
<p>Модифицируем нашего бота так, чтобы он&nbsp;в&nbsp;конце диалога мог <em>передать привет</em> в&nbsp;город, который пользователь указал в&nbsp;первом ответе.</p>
<pre><code class="language-python"># Добавили словарь user_data в параметры.
async def first_response(update, context):
    # Сохраняем ответ в словаре.
    context.user_data['locality'] = update.message.text
    await update.message.reply_text(
        f"Какая погода в городе {context.user_data['locality']}?")
    return 2


# Добавили словарь user_data в параметры.
async def second_response(update, context):
    weather = update.message.text
    logger.info(weather)
    # Используем user_data в ответе.
    await update.message.reply_text(
        f"Спасибо за участие в опросе! Привет, {context.user_data['locality']}!")
    context.user_data.clear()  # очищаем словарь с пользовательскими данными
    return ConversationHandler.END
</code></pre>
</section>
<section class="material__chapter">
<h2 id="11">Использование HTTP-API в&nbsp;телеграм-ботах</h2>
<p>Как вы&nbsp;понимаете, чат-боты могут работать не&nbsp;только с&nbsp;теми данными, которые находятся в&nbsp;их&nbsp;непосредственной доступности, но&nbsp;и&nbsp;запрашивать информацию у&nbsp;API сторонних сервисов. Идея проста: научим телеграм-бота &laquo;ходить&raquo; в&nbsp;HTTP API, превращая запросы пользователей в&nbsp;http-запросы к&nbsp;API, и&nbsp;транслировать ответы API в&nbsp;удобной и&nbsp;понятной для пользователя форме.</p>
<p>Давайте создадим бота, который по&nbsp;запросу пользователя присылает ему карту с&nbsp;запрошенным объектом. Например, пользователь запрашивает: &laquo;г. Москва, Тверская улица&raquo;. В&nbsp;ответ высылается картинка с&nbsp;картой улицы.</p>
<p>Алгоритм работы может быть таким:</p>
<ol>
<li>Бот &laquo;идет&raquo; с&nbsp;адресом в&nbsp;геокодер, получает координаты и&nbsp;размеры окна карты с&nbsp;нужным объектом.</li>
<li>С&nbsp;полученными координатами бот &laquo;идет&raquo; в&nbsp;StaticAPI и&nbsp;запрашивает по&nbsp;ним картинку карты.</li>
</ol>
<p>Необходимо разобраться, как отправлять изображения (фотографии, в&nbsp;нотации телеграм-бота). Об&nbsp;этом можно почитать <a class="material__link" href="https://python-telegram-bot.readthedocs.io/en/stable/telegram.bot.html#telegram.Bot.sendPhoto" target="_blank" rel="noopener noreferrer">здесь</a>.</p>
<p>Поскольку наш телеграм бот работает в асинхронном режиме, то применять стандартную библиотеку <var>requests</var> для обращения к сторонним api неправильно. Будем применять асинхронную библиотеку <var>aiohttp</var>, примеры ее использования есть в уроке <strong>"Введение в асинхронное программирование"</strong>.</p>
<p>Иногда получение ответа от стороннего API может требовать времени, и в синхронном режим эта операция становится блокирующей, т.е. пока не будет обработан запрос от одного пользователя, запросы и команды от остальных пользователей будут проигнорированы, точнее, будут ждать своей очереди на обработку. В асинхронном режиме пока наш бот ждет ответа от стороннего сервиса, он продолжает принимать и обрабатывать команды от пользователей в обычном режиме.</p>
<p>Функция, обрабатывающая сообщения, получится примерно следующая:</p>
<pre><code class="language-python">async def geocoder(update, context):
    geocoder_uri = "http://geocode-maps.yandex.ru/1.x/"
    response = await get_response(geocoder_uri, params={
        "apikey": "40d1649f-0493-4b70-98ba-98533de7710b",
        "format": "json",
        "geocode": update.message.text
    })

    toponym = response["response"]["GeoObjectCollection"][
        "featureMember"][0]["GeoObject"]
    ll, spn = get_ll_spn(toponym)
    # Можно воспользоваться готовой функцией,
    # которую предлагалось сделать на уроках, посвящённых HTTP-геокодеру.

    static_api_request = f"http://static-maps.yandex.ru/1.x/?ll={ll}&amp;spn={spn}&amp;l=map"
    await context.bot.send_photo(
        update.message.chat_id,  # Идентификатор чата. Куда посылать картинку.
        # Ссылка на static API, по сути, ссылка на картинку.
        # Телеграму можно передать прямо её, не скачивая предварительно карту.
        static_api_request,
        caption="Нашёл:"
    )


async def get_response(url, params):
    logger.info(f"getting {url}")
    async with aiohttp.ClientSession() as session:
        async with session.get(url, params=params) as resp:
            return await resp.json()
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>