<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Цели и подходы к тестированию. Создание «самодельных» тестов (без библиотек) </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Тестирование</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Цели и&nbsp;подходы к&nbsp;тестированию. Создание &laquo;самодельных&raquo; тестов (без библиотек)</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Когда и&nbsp;зачем нужно тестирование?</a></li>
<li><a class="material__link" href="#2">Пример написания тестов</a></li>
<li><a class="material__link" href="#3">Обсуждение: почему неудобно писать тесты самостоятельно</a></li>
<li><a class="material__link" href="#4">Резюме</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Мы&nbsp;узнаем, что такое тестирование и&nbsp;зачем оно нужно. Напишем несколько простых тестов и&nbsp;подготовимся к&nbsp;использованию более продвинутых инструментов (библиотек) для тестирования в&nbsp;Python.</p>
</section>
<section class="material__chapter">
<h2 id="1">Когда и&nbsp;зачем нужно тестирование?</h2>
<p>Мы&nbsp;уже изучили несколько полезных практик, которые помогают в&nbsp;написании больших сложных программ. Пришло время поговорить об&nbsp;еще одной важной практике&nbsp;&mdash; тестировании.</p>
<p>Чтобы лучше усвоить, когда и&nbsp;зачем нужно тестирование, давайте разберем некоторые отличия между маленькими учебными программами (с&nbsp;которыми мы&nbsp;имели дело на&nbsp;уроках, контрольных и&nbsp;в&nbsp;домашних заданиях) и&nbsp;большими &laquo;промышленными&raquo; программами:</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<thead>
<tr>
<th>В чем различие</th>
<th>Учебные программы</th>
<th>Промышленные программы</th>
<th>Следствия</th>
</tr>
</thead>
<tbody>
<tr>
<td>Размер</td>
<td>Несколько десятков строк</td>
<td>Сотни тысяч строк</td>
<td>Промышленную программу невозможно удерживать в&nbsp;голове целиком. Следовательно, нельзя полностью предсказать результаты изменений в&nbsp;коде</td>
</tr>
<tr>
<td>Изменяемость</td>
<td>Не изменяются, т.&nbsp;к. условие задачи не&nbsp;меняется</td>
<td>Постоянно меняются, т.&nbsp;к. меняются требования</td>
<td>Есть риски допустить ошибку при изменении программы (см. также предыдущий пункт)</td>
</tr>
<tr>
<td>Командная работа</td>
<td>Пишутся в одиночку (если вы, конечно, не&nbsp;списываете)</td>
<td>Пишутся несколькими разработчиками</td>
<td>Каждый разработчик может отвечать только за&nbsp;свои части кода и&nbsp;не&nbsp;знать, как устроен остальной код</td>
</tr>
<tr>
<td>Время жизни</td>
<td>Обычно &mdash; один урок</td>
<td>Месяцы и годы</td>
<td>В каждый момент времени нужна уверенность, что программа работает правильно</td>
</tr>
</tbody>
</table>
</div>
<p>Мы&nbsp;выяснили, что промышленные программы, с&nbsp;одной стороны, гораздо сложнее учебных, а&nbsp;с&nbsp;другой&nbsp;&mdash; должны работать правильно на&nbsp;протяжении гораздо более длительного времени, при этом постоянно меняясь.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Тестирование</strong></p>
<p>Тестирование&nbsp;&mdash; это проверка корректности работы программы путем сравнения результата ее&nbsp;работы с&nbsp;ожидаемым при заданных входных данных.</p>
</section>
<p>Тестирование нужно для того, чтобы снизить вероятность ошибок в&nbsp;программе при ее&nbsp;создании или изменении.</p>
<p>Один из&nbsp;способов тестирования программы&nbsp;&mdash; это <strong>юнит-тестирование</strong>, т.&nbsp;е. проверка правильности работы <strong>отдельных независимых компонентов</strong> программы (функций или методов). Юнит-тестирование полезно на&nbsp;всех этапах написания каждого из&nbsp;компонентов программы:</p>
<ul>
<li>Даже если компонент еще не&nbsp;реализован, вы&nbsp;уже можете написать тесты, проверяющие его функциональность. Такой подход называется test-driven development или TDD (Подробнее про это можно почитать <a class="material__link" href="https://ru.wikipedia.org/wiki/Разработка_через_тестирование" target="_blank" rel="noopener noreferrer">тут</a>)</li>
<li>Если вы&nbsp;меняете уже написанный компонент (например, добавляете новую функциональность или исправляете найденную ошибку), то&nbsp;вы&nbsp;предварительно можете написать тесты, которые проверяют, что новая функциональность работает правильно, или что ошибка больше не&nbsp;повторяется. А&nbsp;если до&nbsp;этого уже были написаны тесты, то&nbsp;вы&nbsp;заодно сможете проверить, что ваши изменения не&nbsp;приводят к&nbsp;поломкам старой функциональности</li>
</ul>
</section>
<section class="material__chapter">
<h2 id="2">Пример написания тестов</h2>
<p>Разберем совсем простой пример. Пусть нам нужно написать функцию, которая принимает на&nbsp;вход строку и&nbsp;&laquo;разворачивает&raquo; ее&nbsp;в&nbsp;обратном порядке. Сперва напишем тесты к&nbsp;ней, а&nbsp;саму функцию пока не&nbsp;будем реализовывать:</p>
<pre><code class="language-python">def reverse(s):
    # Пока что наша функция ничего не делает
    pass
</code></pre>
<p>Как написать тесты?</p>
<p>Общая рекомендация такая&nbsp;&mdash; всегда проверяйте как минимум три случая:</p>
<ul>
<li>Неправильные входные данные. В&nbsp;нашем случае функция принимает на&nbsp;вход только строки, все остальные типы считаются ошибочными</li>
<li>Граничные случаи. Например, пустые строки и&nbsp;массивы, или границы диапазона входных значений</li>
<li>Обычные случаи. Например, случайные корректные входные данные</li>
</ul>
<p>Мы&nbsp;подробнее разберем приемы написания тестов на&nbsp;следующем уроке, после знакомства с&nbsp;инструментами для тестирования (библиотеки unittest и&nbsp;pytest).</p>
<p>А&nbsp;пока напишем тесты сами в&nbsp;виде функции <code>test_reverse()</code>. Она будет запускать функцию <code>reverse()</code> на&nbsp;разных входных данных и&nbsp;сравнивать полученный результат с&nbsp;ожидаемым. Если все такие сравнения успешны (т.е., если &laquo;тесты пройдены&raquo;), функция <code>test_reverse()</code> вернет True, в&nbsp;противном случае&nbsp;&mdash; False.</p>
<pre><code class="language-python">def test_reverse():
    # Список тестов
    # Каждый тест &mdash; это пара (входное значение, ожидаемое выходное значение)
    test_data = (
        # неправильный тип входного аргумента, ни с чем не будем сравнивать
        (42, None),
        # тоже неправильный входной аргумент, но он "похож" на строку
        # (можно итерироваться и брать срезы)
        (['a', 'b', 'c'], None),
        # "граничный" случай &mdash; пустая строка
        ('', ''),
        # "особый" случай &mdash; строка, которая не меняется при разворачивании
        ('aba', 'aba'),
        # ещё один "особый" и почти "граничный" случай
        ('a', 'a'),
        # "обычный" случай
        ('abc', 'cba'),  
    )

    for input_s, correct_output_s in test_data:
        try:
            # Вычисляем результат на входных данных
            # Есть вариант, что наша функция выбросит исключение,
            # поэтому делаем это в блоке try
            output_s = reverse(input_s)
        except TypeError as E:
            if correct_output_s is None:
                # это исключение и ожидалось, продолжаем тестирование
                continue
            if type(input_s) == str:
                # вход корректный, но выброшено исключение TypeError &mdash; это ошибка
                print(f'Ошибка! Не удалось вычислить reverse("{input_s}"). Ошибка: {E}')
                return False
        except Exception as E:
            # Выброшено неожиданное исключение &mdash; это ошибка
            print(f'Ошибка! Не удалось вычислить reverse("{input_s}"). Ошибка: {E}')
            return False
        else:
            if output_s != correct_output_s:
                # если ответ не совпал с ожидаемым, завершаем тестирование и возвращаем False
                print(f'Ошибка! reverse({input_s}) равно {output_s} вместо "{correct_output_s}"')
                return False
    # тестирование успешно пройдено
    print('Все тесты пройдены успешно')
    return True</code></pre>
<p>Пока что функция <code>reverse()</code> не&nbsp;реализована, и&nbsp;тесты не&nbsp;проходят</p>
<pre><code class="language-python">test_reverse()
</code></pre>
<pre><samp>Ошибка! reverse() равно None вместо ""</samp></pre>
<p>Попробуем следующую реализацию <var>reverse</var>:</p>
<pre><code class="language-python">def reverse(s):
    r = ''
    for c in s:
        r = c + r
    return r
 
 
# проверим, что теперь тесты проходят
test_reverse()
</code></pre>
<pre><samp>Ошибка! reverse(['a', 'b', 'c']) равно cba вместо "None"</samp></pre>
<p>Точно, мы&nbsp;забыли проверить входное значение на&nbsp;корректность. Исправляем...</p>
<pre><code class="language-python">def reverse(s):
    if type(s) != str:
        raise TypeError()
    r = ''
    for c in s:
        r = c + r
    return r


# проверим, что теперь тесты проходят
test_reverse()
</code></pre>
<pre><samp>Все тесты пройдены успешно.</samp></pre>
<p>Давайте поупражняемся еще немного на&nbsp;<strong>рекурсивной</strong> функции.</p>
<pre><code class="language-python">def reverse(s):
    if type(s) != str:
        raise TypeError()
    # если строка состоит из одного символа, то разворачивать ее не нужно
    # кажется, логично...
    if len(s) == 1:
        return s
    return s[-1] + reverse(s[:-1])


test_reverse()
</code></pre>
<pre><samp>Ошибка! Не удалось вычислить reverse(""). Ошибка: string index out of range</samp></pre>
<p>Что не&nbsp;так? Конечно! Мы&nbsp;забыли про граничный случай&nbsp;&mdash; пустую строку.</p>
<p>При написании рекурсивных функций очень легко ошибиться именно в&nbsp;граничных случаях. Давайте исправим.</p>
<pre><code class="language-python">def reverse(s):
    if type(s) != str:
        raise TypeError()
    # если строка пустая или состоит из одного символа,
    # то разворачивать её не нужно
    if len(s) &lt;= 0:
        return s
    return s[-1] + reverse(s[:-1])


test_reverse()
</code></pre>
<pre><samp>Все тесты пройдены успешно.</samp></pre>
<p>Кажется, нашу функцию можно сильно упростить.</p>
<p>Тесты помогают проконтролировать, что после изменений ничего не&nbsp;сломалось.</p>
<pre><code class="language-python">def reverse(s):
    if type(s) != str:
        raise TypeError()
    return s[::-1]


test_reverse()
</code></pre>
<pre><samp>Все тесты пройдены успешно.</samp></pre>
<p>Ну&nbsp;и&nbsp;давайте проверим, что наша <var>test_reverse</var> корректно отрабатывает исключительные ситуации в&nbsp;функции <var>reverse</var>:</p>
<pre><code class="language-python">def reverse(s):
    # пишем заведомо ошибочный код
    return 1/0


test_reverse()
</code></pre>
<pre><samp>Ошибка! Не удалось вычислить reverse("42"). Ошибка: division by zero</samp></pre>
<p>Кажется, нам все удалось. Давайте решать задачи!</p>
</section>
<section class="material__chapter">
<h2 id="3">Обсуждение: почему неудобно писать тесты самостоятельно</h2>
<p>В&nbsp;чем недостатки нашей тестовой функции <code>test_reverse()</code>?</p>
<ul>
<li>Код теста получился сложнее, чем код тестируемой функции! Конечно, отчасти это из-за того, что мы&nbsp;выбрали очень простую функцию <code>reverse()</code> в&nbsp;качестве примера. Но&nbsp;все равно хотелось&nbsp;бы, чтобы по&nbsp;тесту было легко понять, что он&nbsp;делает. На&nbsp;самом деле, тесты&nbsp;&mdash; это еще и&nbsp;неявный способ документирования, поэтому <strong>писать и&nbsp;читать тесты должно быть просто</strong></li>
</ul>
<p>В&nbsp;частности, сложно <strong>обрабатываются исключения</strong>. Есть шанс допустить ошибку в&nbsp;тестирующей функции, а&nbsp;этого ни&nbsp;в&nbsp;коем случае не&nbsp;должно быть. Представьте, что у&nbsp;нас не&nbsp;одна функция <code>reverse()</code>, а, скажем, сто разных.</p>
<ul>
<li>К&nbsp;каждой из&nbsp;них придется писать свою тестирующую функцию. Если каждая будет такой&nbsp;же сложной, то&nbsp;на&nbsp;тестирование станет уходить слишком много времени</li>
<li>При каждом изменении какой-то из&nbsp;функций нужно найти соответствующую ей&nbsp;тестовую функцию, запустить ее&nbsp;и&nbsp;убедиться, что тесты по-прежнему проходят</li>
</ul>
<p>Иными словами, нет <strong>автоматизации тестирования</strong>.</p>
<p><strong>Отчет об&nbsp;ошибках</strong> тоже не&nbsp;очень удобен. Где именно произошла ошибка&nbsp;&mdash; при обработке неправильного входа, в&nbsp;граничном случае или в&nbsp;&laquo;обычном&raquo; случае?</p>
<p>Конечно, все указанные нами недостатки можно исправить самостоятельно. Но&nbsp;в&nbsp;этом нет необходимости, поскольку в&nbsp;языке Python есть удобные инструменты для тестирования, с&nbsp;которыми мы&nbsp;познакомимся на&nbsp;следующем уроке по&nbsp;тестированию.</p>
</section>
<section class="material__chapter">
<h2 id="4">Резюме</h2>
<ul>
<li>Мы&nbsp;узнали, что такое тестирование (проверка корректности путем сравнения выходных данных с&nbsp;ожидаемыми) и&nbsp;зачем оно нужно (чтобы защититься от&nbsp;ошибок при изменениях в&nbsp;больших программах)</li>
<li>Мы&nbsp;познакомились с&nbsp;понятием юнит-тестирования (тестирование независимых компонент программы)</li>
<li>Мы&nbsp;написали тесты для простой функции, с&nbsp;их&nbsp;помощью нашли ошибки и&nbsp;проверили корректность программы после внесения в&nbsp;нее изменений</li>
<li>Мы&nbsp;убедились, что для полноценного тестирования необходимы более удобные инструменты&nbsp;&mdash; о&nbsp;них мы&nbsp;узнаем на&nbsp;следующем уроке по&nbsp;тестированию</li>
<li>Ваша практическая работа будет построена по&nbsp;следующему принципу:
<ol>
<li>Сначала вам надо будет для уже созданной функции написать тесты</li>
<li>А&nbsp;потом попытаться самостоятельно воссоздать исходную функцию</li>
</ol>
</li>
</ul>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>