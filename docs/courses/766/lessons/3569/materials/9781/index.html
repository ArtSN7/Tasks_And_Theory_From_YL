<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Шаблоны. flask-wtf </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок WEB. flask-wtf</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Шаблоны. flask-wtf</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Шаблоны</a></li>
<li><a class="material__link" href="#2">Условия в&nbsp;шаблонах</a></li>
<li><a class="material__link" href="#3">Циклы в&nbsp;шаблонах</a></li>
<li><a class="material__link" href="#4">Создание переменных в&nbsp;шаблоне</a></li>
<li><a class="material__link" href="#5">Наследование шаблонов</a></li>
<li><a class="material__link" href="#6">Знакомство с&nbsp;Flask-WTF</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;этом уроке избавимся от&nbsp;необходимости создавать HTML-разметку непосредственно в&nbsp;коде, а&nbsp;также рассмотрим возможность создания форм с&nbsp;использованием объектного подхода с&nbsp;помощью библиотеки flask-wtf.</p>
</section>
<section class="material__chapter">
<h2 id="1">Шаблоны</h2>
<p>Делать разметку непосредственно в&nbsp;коде Python плохо в&nbsp;99,99&nbsp;% случаев. Это сложно поддерживать, неудобно писать, и&nbsp;наверняка вы&nbsp;почувствовали дискомфорт, пока делали предыдущие примеры. А&nbsp;у&nbsp;нас были достаточно простые страницы и&nbsp;небольшое количество информации, которая менялась динамически.</p>
<p>Для того чтобы сделать жизнь программистов лучше, во&nbsp;Flask есть прекрасный механизм создания HTML-шаблонов, который мы&nbsp;сейчас и&nbsp;рассмотрим.</p>
<p>Практически всегда отделение логики приложения от&nbsp;макетов веб-страниц&nbsp;&mdash; отличная идея. Таким образом достигается нормальная организация внутри команды и&nbsp;становится возможным разделение работ. Каждый занимается своим делом: веб-дизайнер делает красиво, а&nbsp;разработчик&nbsp;&mdash; чтобы работало. Шаблоны как раз помогают достичь этого разделения. Во&nbsp;Flask шаблоны записываются как отдельные файлы, хранящиеся в&nbsp;папке templates, которая находится (по&nbsp;умолчанию) в&nbsp;корневой папке приложения. Давайте ее&nbsp;создадим. И&nbsp;добавим в&nbsp;эту папку файл с&nbsp;HTML-разметкой&nbsp;&mdash; index.html со&nbsp;следующим содержимым:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;{{ title }}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Привет, {{ username }}!&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Для нас такая разметка не&nbsp;представляет ничего сложного. Интерес вызывают разве что непонятные параметры в&nbsp;двух фигурных скобках. Давайте посмотрим, как шаблон будет работать. Для этого импортируем <var>render_template</var> из&nbsp;flask и&nbsp;напишем для нашего приложения новый обработчик главной страницы:</p>
<pre><code class="language-python">@app.route('/')
@app.route('/index')
def index():
    user = "Ученик Яндекс.Лицея"
    return render_template('index.html', title='Домашняя страница', 
                           username=user)
</code></pre>
<p>И&nbsp;никакой разметки в&nbsp;нашем python-файле&nbsp;&mdash; прекрасно, не&nbsp;правда&nbsp;ли? Операция, которая преобразует шаблон в&nbsp;HTML-страницу, называется <strong>рендерингом</strong>. Чтобы отобразить шаблон, нам пришлось импортировать функцию <code>render_template()</code>. Эта функция принимает имя файла шаблона и&nbsp;перечень аргументов шаблона и&nbsp;возвращает тот&nbsp;же шаблон, но&nbsp;при этом все блоки <code>{{...}}</code> в&nbsp;нем заменяются фактическими значениями переданных аргументов. Этот процесс работает схоже с&nbsp;прекрасно знакомым нам методом <var>format</var> для строк в&nbsp;Python. Механизм шаблонов, встроенный во&nbsp;Flask, называется Jinja2.</p>
<p>Запустите приложение и&nbsp;перейдите по&nbsp;ссылке http://127.0.0.1:8080/, из&nbsp;контекстного меню по&nbsp;правому клику в&nbsp;браузере выбирите &laquo;Показать исходный код&raquo; или &laquo;view page source&raquo;. Посмотрите, какой HTML-код был сгенерирован на&nbsp;основе шаблона.</p>
<p>Важно не&nbsp;забывать, что кроме непосредственно переданных параметров внутри шаблона мы&nbsp;имеем доступ и&nbsp;к&nbsp;служебным объектам. Например, уже знакомый нам <var>request</var>, или <var>session</var>, о&nbsp;котором мы&nbsp;поговорим позже.</p>
<p>Параметры в&nbsp;шаблон не&nbsp;обязательно передавать по&nbsp;отдельности, так как их&nbsp;может быть много и&nbsp;получать мы&nbsp;их&nbsp;можем внутри нашей потенциально длиной функции в&nbsp;разных местах. Можно собирать их&nbsp;в&nbsp;словарь параметров, а&nbsp;потом распаковывать его в&nbsp;вызове функции <var>render_template</var>:</p>
<pre><code class="language-python">@app.route('/')
@app.route('/index')
def index():
    param = {}
    param['username'] = "Ученик Яндекс.Лицея"
    param['title'] = 'Домашняя страница'
    return render_template('index.html', **param)
</code></pre>
<p>Если мы&nbsp;не&nbsp;заполним какой-то из&nbsp;параметров шаблона, то&nbsp;он&nbsp;по&nbsp;умолчанию будет считаться равным пустой строке.</p>
<p>Кроме простой подстановки параметров Jinja2 умеет делать еще несколько полезных вещей. Речь о&nbsp;них пойдет далее.</p>
</section>
<section class="material__chapter">
<h2 id="2">Условия в&nbsp;шаблонах</h2>
<p>Шаблонизатор Flask поддерживает условные операторы, заданные внутри блоков <code>{% ...%}</code>. Давайте создадим шаблон odd_even.html:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Четное-нечетное&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 {% if number % 2 == 0 %}
        &lt;div&gt;{{ number }} - чётное&lt;/div&gt;
 {% else %}
       &lt;div&gt;{{ number }} - нечётное&lt;/div&gt;
 {% endif %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>И&nbsp;обработчик:</p>
<pre><code class="language-python">@app.route('/odd_even')
def odd_even():
    return render_template('odd_even.html', number=2)
</code></pre>
<p>Теперь в&nbsp;зависимости от&nbsp;того, что мы&nbsp;передали в&nbsp;шаблон, будет отрабатывать тот или иной блок.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/webserver-2-3.png" width="394" height="auto" /></div>
<p>Общий синтаксис условного оператора в&nbsp;шаблонах очень похож на&nbsp;тот, к&nbsp;которому мы&nbsp;привыкли в&nbsp;Python:</p>
<pre><code class="language-python"> {% if условие_1 %}
        ветка 1
  {% elif условие_2 %} (не обязательно)
        ветка 1
 {% else %} (не обязательно)
       ветка 2
 {% endif %}
</code></pre>
<p>Поддерживаются вложенные условия.</p>
</section>
<section class="material__chapter">
<h2 id="3">Циклы в&nbsp;шаблонах</h2>
<p>Jinja2 поддерживает еще и&nbsp;циклы <var>for</var>. Давайте создадим тестовый json-файл со&nbsp;списком новостей примерно следующего содержания:</p>
<pre><code class="language-python">{
    "news": [
        {
            "title": "Сегодня хорошая погода",
            "content": "Невероятно, сегодня хорошая погода"
        },
        {
            "title": "Завтра хорошая погода",
            "content": "С ума сойти, и завтра хорошая погода"
        },
        {
            "title": "Послезавтра дождь",
            "content": "Все вошло в норму"
        }
    ]
}
</code></pre>
<p>Напишем обработчик:</p>
<pre><code class="language-python">@app.route('/news')
def news():
    with open("news.json", "rt", encoding="utf8") as f:
        news_list = json.loads(f.read())
    print(news_list)
    return render_template('news.html', news=news_list)
</code></pre>
<p>И&nbsp;шаблон:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Новости&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {% for item in news['news'] %}
        &lt;h2&gt;{{item["title"]}}&lt;/h2&gt;
        &lt;div&gt;{{item["content"]}}&lt;/div&gt;
    {% endfor %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/webserver-2-4.png" width="354" height="auto" /></div>
<p>Как вы&nbsp;можете заметить, общий синтаксис цикла выглядит так:</p>
<pre><code class="language-python">{% for переменная цикла in набор значений %}
    код
{% endfor %}
</code></pre>
<p>В&nbsp;качестве набора значений может выступать все то&nbsp;же, что и&nbsp;в&nbsp;обычном цикле на&nbsp;Python. Можно использовать и&nbsp;<var>range</var> (тогда можно смоделировать ситуации, когда значение в&nbsp;шаблон передавать не&nbsp;нужно, а&nbsp;цикл все равно сработает). Поддерживается вложенность.</p>
<p>Внутри цикла доступна переменная <var>loop</var> с&nbsp;рядом полезных атрибутов, например:</p>
<ul>
<li><code>index</code>&nbsp;&mdash; индекс итерации с&nbsp;1</li>
<li><code>index0</code>&nbsp;&mdash; индекс итерации с&nbsp;нуля</li>
<li><code>first</code>&nbsp;&mdash; True, если первая итерация, иначе False</li>
<li><code>last</code>&nbsp;&mdash; True, если последняя итерация, иначе False</li>
</ul>
</section>
<section class="material__chapter">
<h2 id="4">Создание переменных в&nbsp;шаблоне</h2>
<p>Несмотря на&nbsp;то&nbsp;что практически все значения для шаблона мы&nbsp;передаем из&nbsp;нашего кода на&nbsp;Python, периодически возникают ситуации, когда возникает необходимость создать переменную непосредственно в&nbsp;шаблоне, например, для хранения промежуточного результата вычислений. Это можно сделать с&nbsp;помощью ключевого слова <var>set</var>.</p>
<pre><code class="language-python">{% set a = 10 %}
</code></pre>
<p>Давайте рассмотрим пример для иллюстрации создания переменных в&nbsp;шаблоне, а&nbsp;заодно посмотрим на&nbsp;переменную <var>loop</var> внутри цикла:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;{{ title }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Кто стоит в очереди?&lt;/h1&gt;
{% set user_list = ['Ваня', 'Петя', 'Саша', 'Кирилл'] %}
&lt;ul&gt;
    {% for user in user_list %}
    &lt;li&gt;{{ loop.index }} - {{ user }} {% if loop.first %} первый в очереди {% elif loop.last %} последний. {% endif %}
    &lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Добавим обработчик, запустим:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/web-wtf-1.png" width="450" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="5">Наследование шаблонов</h2>
<p>В&nbsp;большинстве веб-приложений вверху или сбоку страницы есть главное меню, панели навигации с&nbsp;несколькими часто используемыми ссылками, внизу страницы зачастую располагается подвал (футер) с&nbsp;контактной информацией и&nbsp;т.&nbsp;д. Если веб-приложение содержит несколько страниц, не&nbsp;составит большого труда добавить такую информацию во&nbsp;все шаблоны. Но&nbsp;по&nbsp;мере увеличения масштаба это будет становиться все труднее и&nbsp;труднее. Может возникнуть ситуация, когда при изменении номера телефона или добавлении нового пункта меню придется изменить несколько сотен шаблонов. Кроме того, вы&nbsp;помните, что надо переиспользовать код, где это возможно, а&nbsp;писать одно и&nbsp;тоже несколько раз&nbsp;&mdash; плохая практика.</p>
<p>Jinja2 имеет функцию наследования шаблона, которая решает эту проблему. Мы&nbsp;можем разместить общие для всех шаблонов части макета страницы в&nbsp;базовом шаблоне, из&nbsp;которого выводятся все остальные шаблоны.</p>
<p>Давайте создадим базовый шаблон, который будет содержать небольшое верхнее меню, в&nbsp;файле base.html:</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;
    &lt;link rel="stylesheet"
          href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
          integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
          crossorigin="anonymous"&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;header&gt;
    &lt;nav class="navbar navbar-light bg-light"&gt;
        &lt;a class="navbar-brand" href="#"&gt;Наше приложение&lt;/a&gt;
    &lt;/nav&gt;
&lt;/header&gt;
&lt;!-- Begin page content --&gt;
&lt;main role="main" class="container"&gt;
    {% block content %}{% endblock %}
&lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>В&nbsp;базовом шаблоне используется оператор управления блоком <code>{%&nbsp;block %}{% endblock&nbsp;%}</code>, чтобы определить место, куда будет вставляться содержимое дочерних шаблонов. Блокам присваивается уникальное имя (в&nbsp;нашем случае&nbsp;&mdash; content), на&nbsp;которое производные шаблоны могут ссылаться.</p>
<p>Давайте изменим и&nbsp;наш index.html, который теперь будет выглядеть следующим образом:</p>
<pre><code class="language-python">{% extends "base.html" %}

{% block content %}
    &lt;h1&gt;Привет, {{ username }}!&lt;/h1&gt;
{% endblock %}
</code></pre>
<p>В&nbsp;<var>extends</var> мы&nbsp;указываем, какой шаблон мы&nbsp;хотим расширить, а&nbsp;в&nbsp;<var>block</var>&nbsp;&mdash; какой именно блок (их&nbsp;может быть несколько).</p>
<p>Обычно базовые шаблоны делают таким образом, чтобы они отвечали за&nbsp;общую структуру страницы. Новые страницы веб-приложения создают как производные шаблоны из&nbsp;одного и&nbsp;того&nbsp;же базового шаблона для избежания дублирования кода. Дочерний шаблон может расширять несколько блоков родительского шаблона, и&nbsp;при этом сам быть родительским для другого шаблона. Про все тонкости можно почитать в&nbsp;<a class="material__link" href="https://jinja.palletsprojects.com/en/2.10.x/templates/#template-inheritance" target="_blank" rel="noopener noreferrer">официальной документации</a>.</p>
<p><strong>И еще.</strong></p>
<p>Jinja поддерживает еще много интересного:</p>
<ul>
<li>Макросы&nbsp;&mdash; аналог функций из&nbsp;Python&nbsp;&mdash; куски кода шаблона, которые можно переиспользовать, обращаясь по&nbsp;имени</li>
<li>Фильтры&nbsp;&mdash; некоторые функции, которые можно применять к&nbsp;данным при выводе, в&nbsp;большинстве случаев они дублируют функциональность методов строк, и&nbsp;позволяют немного модифицировать данные при отображении в&nbsp;шаблоне</li>
</ul>
<p>Про это и&nbsp;много другое можно почитать в&nbsp;<a class="material__link" href="https://jinja.palletsprojects.com/en/2.10.x/" target="_blank" rel="noopener noreferrer">документации</a>.</p>
</section>
<section class="material__chapter">
<h2 id="6">Знакомство с&nbsp;Flask-WTF</h2>
<p>Микрофреймворк Flask силен, в&nbsp;том числе, и&nbsp;своей расширяемостью, которая позволяет значительно наращивать функциональность веб-приложения за&nbsp;счет дополнительных модулей с&nbsp;небольшими усилиями. Мы&nbsp;рассмотрим модуль flask-wtf для создания и&nbsp;обработки форм. У&nbsp;вас может возникнуть закономерный вопрос&nbsp;&mdash; зачем, ведь мы&nbsp;уже научились работать с&nbsp;формами? На&nbsp;самом деле, работа со&nbsp;сложными формами через разметку все равно достаточно непростая задача, а&nbsp;flask-wtf помогает не&nbsp;только скрыть эту сложность, но&nbsp;и&nbsp;использует при этом объектно-ориентированный подход.</p>
<p>Чтобы установить flask-wtf, достаточно выполнить команду:</p>
<pre><code>pip install flask-wtf
</code></pre>
<p>Прежде чем приступить к&nbsp;дальнейшей работе, давайте сделаем небольшую настройку нашего приложения и&nbsp;добавим следующую строку после создания переменной <var>app</var>:</p>
<pre><code class="language-python">app.config['SECRET_KEY'] = 'yandexlyceum_secret_key'
</code></pre>
<p>Эта настройка защитит наше приложение от&nbsp;<a class="material__link" href="https://ru.wikipedia.org/wiki/Межсайтовая_подделка_запроса" target="_blank" rel="noopener noreferrer">межсайтовой подделки запросов</a>.</p>
<p>Конечно, наш придуманный ключ довольно простой, но&nbsp;этот параметр необходим для корректной работы модуля. В&nbsp;принципе, защиту от&nbsp;CSRF-атаки можно отключить, но&nbsp;это не&nbsp;рекомендуется даже в&nbsp;учебных приложениях, как наше, чтобы при разработке своих больших проектов вы&nbsp;про это ненароком не&nbsp;забыли. Хорошая идея&nbsp;&mdash; хранить настройки приложения в&nbsp;отдельном файле конфигурации и&nbsp;считывать их&nbsp;при старте приложения.</p>
<p>Давайте создадим форму авторизации для входа в&nbsp;наше абстрактное приложение, которая будет содержать текстовое поле для ввода логина, поле для ввода пароля, чекбокс &laquo;Запомнить меня&raquo; и&nbsp;кнопку отправки формы на&nbsp;сервер. Для начала создадим класс нашей будущей формы. Создадим файл loginform.py, в&nbsp;котором напишем следующий код:</p>
<pre><code class="language-python">from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired


class LoginForm(FlaskForm):
    username = StringField('Логин', validators=[DataRequired()])
    password = PasswordField('Пароль', validators=[DataRequired()])
    remember_me = BooleanField('Запомнить меня')
    submit = SubmitField('Войти')
</code></pre>
<p>Как видно из&nbsp;примера, мы&nbsp;импортируем класс <var>FlaskForm</var> из&nbsp;модуля flask_wtf&nbsp;&mdash; основной класс, от&nbsp;которого мы&nbsp;будем наследоваться при создании своей формы. Из&nbsp;модуля wtforms (flask_wtf&nbsp;&mdash; обертка для этого модуля) мы&nbsp;импортируем типы полей, которые нам пригодятся для создания нашей формы: текстовое поле, поле ввода пароля, булевое поле (из&nbsp;него получается чекбокс), и&nbsp;кнопку отправки данных.</p>
<p>Кроме этого, из&nbsp;модуля <code>wtforms.validators</code> импортируем проверку, которая скажет нам о&nbsp;том, введены&nbsp;ли данные в&nbsp;поле или нет. Создаем необходимые поля, на&nbsp;поля ввода логина и&nbsp;пароля вешаем проверку наличия там введенной информации.</p>
<p>Прежде чем добраться до&nbsp;шаблона, давайте напишем обработчик, который будет оперировать пока не&nbsp;созданным шаблоном login.html (шаблон мы&nbsp;оставим на&nbsp;потом, чтобы посмотреть несколько вариантов):</p>
<pre><code class="language-python">@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        return redirect('/success')
    return render_template('login.html', title='Авторизация', form=form)
</code></pre>
<p>Тут мы&nbsp;создаем нашу форму, и&nbsp;если все поля прошли валидацию, после нажатия на&nbsp;кнопку отправки данных отправляем нашего пользователя на&nbsp;страницу удачного логина (не&nbsp;забудьте ее&nbsp;сначала создать, а&nbsp;также импортировать <var>redirect</var> из&nbsp;модуля flask).</p>
<p>Теперь перейдем к&nbsp;шаблону. Давайте создадим новый шаблон login.html, который будет расширять уже существующий шаблон base.html. Есть несколько вариантов того, как мы&nbsp;можем отобразить поля нашей формы <var>LoginForm</var>. Если мы&nbsp;хотим просто создать поля и&nbsp;отобразить их&nbsp;с&nbsp;минимальной настройкой внешнего вида, тогда можно просто обойти их&nbsp;в&nbsp;цикле вот таким достаточно универсальным кодом:</p>
<pre><code class="language-python">{% extends "base.html" %}

{% block content %}
    &lt;form action="" method="post" novalidate&gt;
        &lt;div&gt;
            {{ form.csrf_token }}
        &lt;/div&gt;
        {% for field in form if field.name != 'csrf_token' %}
            &lt;div&gt;
                {{ field.label() }}
                {{ field() }}
                {% for error in field.errors %}
                    &lt;div class="error"&gt;{{ error }}&lt;/div&gt;
                {% endfor %}
            &lt;/div&gt;
        {% endfor %}
    &lt;/form&gt;
{% endblock %}
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/web-wtf-2.png" width="640" height="auto" /></div>
<p>Если нам нужно больше контроля над отображением полей, можно обращаться в&nbsp;верстке к&nbsp;каждому из&nbsp;них по&nbsp;отдельности:</p>
<pre><code class="language-python">{% extends "base.html" %}

{% block content %}
&lt;h1&gt;Авторизация&lt;/h1&gt;
&lt;form action="" method="post" novalidate&gt;
    {{ form.hidden_tag() }}
    &lt;p&gt;
        {{ form.username.label }}&lt;br&gt;
        {{ form.username(class="form-control") }}&lt;br&gt;
        {% for error in form.username.errors %}
    &lt;div class="alert alert-danger" role="alert"&gt;
        {{ error }}
    &lt;/div&gt;
    {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;
        {{ form.password.label }}&lt;br&gt;
        {{ form.password(class="form-control", type="password") }}&lt;br&gt;
        {% for error in form.password.errors %}
    &lt;div class="alert alert-danger" role="alert"&gt;
        {{ error }}
    &lt;/div&gt;
    {% endfor %}
    &lt;/p&gt;
    &lt;p&gt;{{ form.remember_me() }} {{ form.remember_me.label }}&lt;/p&gt;
    &lt;p&gt;{{ form.submit(type="submit", class="btn btn-primary") }}&lt;/p&gt;
&lt;/form&gt;
{% endblock %}
</code></pre>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/second-year/web/web-wtf-3.png" width="680" height="auto" /></div>
<p>Как видите, здесь для создания формы мы&nbsp;оперируем уже не&nbsp;разметкой, а&nbsp;атрибутами объекта <var>form</var>. <var>form.hidden_tag</var>&nbsp;&mdash; атрибут, который добавляет в&nbsp;форму токен для защиты от&nbsp;атаки, о&nbsp;которой мы&nbsp;говорили раньше. Из&nbsp;интересного в&nbsp;шаблоне есть еще циклы, которые добавляют вывод ошибок заполнения полей. В&nbsp;нашем случае валидатор только один, но&nbsp;в&nbsp;общем случае их&nbsp;может быть несколько, поэтому ошибки лучше выводить именно таким образом.</p>
<p>Если мы&nbsp;хотим добавить к&nbsp;компонентам какой-нибудь стиль, класс или указать какой-то другой атрибут, то&nbsp;их&nbsp;можно просто передать как параметры к&nbsp;вызову нужной части формы.</p>
<p>Проверьте, как все работает.</p>
<p>Обратите внимание: проверка правильности значений полей в&nbsp;нашем случае ведется на&nbsp;сервере. Поэтому важно поставить у&nbsp;нашей формы в&nbsp;шаблоне параметр <var>novalidate</var>, иначе Bootstrap будет проверять поля прямо в&nbsp;браузере и&nbsp;до&nbsp;сервера информация не&nbsp;дойдет. Вообще значения полей лучше проверять и&nbsp;там, и&nbsp;там:</p>
<ul>
<li>На&nbsp;клиенте для удобства пользователя (ему не&nbsp;надо ждать обновления страницы, чтобы получить ошибку)</li>
<li>На&nbsp;сервере для безопасности, чтобы злоумышленники не&nbsp;смогли изменить информацию, которую вы&nbsp;проверили на&nbsp;клиенте. В&nbsp;конце концов, никто не&nbsp;запретит желающему сделать POST значений формы по&nbsp;нужному адресу не&nbsp;с&nbsp;HTML-страницы, а&nbsp;с&nbsp;помощью библиотеки <var>requests</var></li>
</ul>
<p>Может возникнуть ситуация, когда данные формы были проверены на&nbsp;клиенте, а&nbsp;затем они были изменены уже после отправки формы (например, добавлен вредоносный код в&nbsp;текст поля). Если на&nbsp;сервере не&nbsp;проверить данные еще раз, то&nbsp;ваше веб-приложение может утратить работоспособность и&nbsp;потерять все данные.</p>
<p>С&nbsp;загрузкой файлов в&nbsp;flask-wtf тоже есть свои небольшие особенности. Для загрузки файла достаточно создать поле типа <var>FileField</var>, а&nbsp;в&nbsp;обработке отправленной информации для получения содержимого файла добавить:</p>
<pre><code class="language-python">f = form.&lt;название поля с&nbsp;файлом&gt;.data
</code></pre>
<p>В&nbsp;библиотеке flask-wtf есть поля для всех самых распространенных типов полей ввода, которые мы&nbsp;рассматривали на&nbsp;прошлом уроке, различные валидаторы.</p>
<p>Уверены, что для вас не&nbsp;является секретом факт, что большинство веб-приложений используют в&nbsp;качестве источника информации базы данных, с&nbsp;которыми мы&nbsp;познакомились, когда создавали приложение c&nbsp;графическим пользовательским интерфейсом с&nbsp;использованием компонентов PyQt. На&nbsp;следующих нескольких уроках мы&nbsp;продолжим с&nbsp;ними работать. И&nbsp;рассмотрим очень мощный инструмент, который упростит разработку именно в&nbsp;части общения с&nbsp;базами данных.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>