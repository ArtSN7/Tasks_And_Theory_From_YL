<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Работа с популярными форматами файлов </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок WEB: json, zip</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Работа с&nbsp;файловой системой и&nbsp;популярными форматами файлов: zip-архивами и&nbsp;json-файлами</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Введение</a></li>
<li><a class="material__link" href="#2">Манипуляции с&nbsp;файлами и&nbsp;папками</a></li>
<li><a class="material__link" href="#3">Модули os&nbsp;и&nbsp;os.path</a></li>
<li><a class="material__link" href="#4">Модуль shutil (shell utilities)</a></li>
<li><a class="material__link" href="#5">Zip-архивы</a></li>
<li><a class="material__link" href="#6">Формат JSON</a></li>
<li><a class="material__link" href="#7">Библиотека для работы с&nbsp;JSON</a></li>
<li><a class="material__link" href="#8">В заключении</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке рассказывается об&nbsp;основных средствах манипуляции с&nbsp;файлами и&nbsp;папками в&nbsp;Python, а&nbsp;также о&nbsp;работе с&nbsp;файлами специализированных форматов: zip-архивах и&nbsp;JSON.</p>
</section>
<section class="material__chapter">
<h2 id="1">Введение</h2>
<p>Мы&nbsp;уже научились создавать программы с&nbsp;графическим пользовательским интерфейсом с&nbsp;использованием виджетов PyQt, работать с&nbsp;базами данных, а&nbsp;также создавать игровые приложения с&nbsp;применением библиотеки PyGame. В&nbsp;этом полугодии мы&nbsp;будем рассматривать еще одну сложную и&nbsp;многообразную тему&nbsp;&mdash; работу с&nbsp;сетью Интернет. Периодически мы&nbsp;будем немного отвлекаться непосредственно от&nbsp;самого Интернета и&nbsp;говорить о&nbsp;смежных темах, которые сильно облегчат нам жизнь в&nbsp;дальнейшем.</p>
</section>
<section class="material__chapter">
<h2 id="2">Манипуляции с&nbsp;файлами и&nbsp;папками</h2>
<p>Когда мы&nbsp;создавали PyQt-приложения, мы&nbsp;говорили о&nbsp;том, что такое файл, какими они бывают и&nbsp;как с&nbsp;каждым типом файлов работать с&nbsp;помощью языка программирования Python. Давайте копнем немного глубже в&nbsp;этом направлении.</p>
<p>Уверены, что ни&nbsp;для кого не&nbsp;является сюрпризом, что файлы в&nbsp;современных операционных системах (ОС) не&nbsp;валяются в&nbsp;одной куче, а&nbsp;организованы особым образом. Почти все&nbsp;ОС поддерживают технологию иерархической, или древовидной, организации файловых систем. Кроме понятия <strong>файл</strong> существует также и&nbsp;понятие <strong>папка</strong> (или каталог). Папка&nbsp;&mdash; это контейнер, содержащий файлы, причем папка может быть вложена в&nbsp;другую папку, а&nbsp;та&nbsp;&mdash; в&nbsp;другую папку и&nbsp;т.&nbsp;д. Файловая система представляет собой своеобразное дерево с&nbsp;вершинами-папками и&nbsp;листьями-файлами. В&nbsp;UNIX-подобных операционных системах благодаря концепции &laquo;все есть файл&raquo; папка является также специальным файлом.</p>
<p>Действия с&nbsp;файлами и&nbsp;папками могут быть специфичными для операционной системы, поэтому нужно внимательно изучать документацию к&nbsp;той или иной библиотеке языка. Однако большинство обычных операций с&nbsp;файловой системой для большинства современных операционных систем универсальны.</p>
<p>Помимо работы с&nbsp;содержимым файла, в&nbsp;Python есть средства для работы с&nbsp;файловой системой в&nbsp;целом, а&nbsp;именно:</p>
<ul>
<li>Управление местоположением файла (копирование и&nbsp;перемещение)</li>
<li>Создание и&nbsp;удаление файла</li>
<li>Обход файловой системы</li>
<li>Получение метаданных файлов и&nbsp;т.&nbsp;д.</li>
</ul>
<p>Мы&nbsp;начнем обзор возможностей с&nbsp;модуля&nbsp;os, потом рассмотрим модуль os.path и&nbsp;модуль shutil.</p>
</section>
<section class="material__chapter">
<h2 id="3">Модули os&nbsp;и&nbsp;os.path</h2>
<p>Модуль os&nbsp;содержит в&nbsp;себе некоторые уникальные функции, зависящие от&nbsp;конкретной операционной системы. Посмотрим, что&nbsp;же в&nbsp;нем находится. Нам поможет функция <var>dir()</var>.</p>
<pre><code class="language-python">import os

print(dir(os))
</code></pre>
<pre><samp>['DirEntry', 'F_OK', 'MutableMapping', 'O_APPEND', 'O_BINARY', 'O_CREAT',
 'O_EXCL', 'O_NOINHERIT', 'O_RANDOM', 'O_RDONLY', 'O_RDWR', 'O_SEQUENTIAL',
 'O_SHORT_LIVED', 'O_TEMPORARY', 'O_TEXT', 'O_TRUNC', 'O_WRONLY',
 'P_DETACH', 'P_NOWAIT', 'P_NOWAITO', 'P_OVERLAY', 'P_WAIT', 'PathLike',
 'R_OK', 'SEEK_CUR', 'SEEK_END', 'SEEK_SET', 'TMP_MAX', 'W_OK', 'X_OK',
 '_Environ', '__all__', '__builtins__', '__cached__', '__doc__',
 '__file__', '__loader__', '__name__', '__package__', '__spec__',
 '_execvpe', '_exists', '_exit', '_fspath', '_get_exports_list', '_putenv',
 '_unsetenv', '_wrap_close', 'abc', 'abort', 'access', 'altsep', 'chdir',
 'chmod', 'close', 'closerange', 'cpu_count', 'curdir', 'defpath',
 'device_encoding', 'devnull', 'dup', 'dup2', 'environ', 'error', 'execl',
 'execle', 'execlp', 'execlpe', 'execv', 'execve', 'execvp', 'execvpe',
 'extsep', 'fdopen', 'fsdecode', 'fsencode', 'fspath', 'fstat', 'fsync',
 'ftruncate', 'get_exec_path', 'get_handle_inheritable', 'get_inheritable',
 'get_terminal_size', 'getcwd', 'getcwdb', 'getenv', 'getlogin', 'getpid',
 'getppid', 'isatty', 'kill', 'linesep', 'link', 'listdir', 'lseek', 'lstat',
 'makedirs', 'mkdir', 'name', 'open', 'pardir', 'path', 'pathsep', 'pipe',
 'popen', 'putenv', 'read', 'readlink', 'remove', 'removedirs', 'rename',
 'renames', 'replace', 'rmdir', 'scandir', 'sep', 'set_handle_inheritable',
 'set_inheritable', 'spawnl', 'spawnle', 'spawnv', 'spawnve', 'st',
 'startfile', 'stat', 'stat_result', 'statvfs_result', 'strerror',
 'supports_bytes_environ', 'supports_dir_fd', 'supports_effective_ids',
 'supports_fd', 'supports_follow_symlinks', 'symlink', 'sys', 'system',
 'terminal_size', 'times', 'times_result', 'truncate', 'umask', 'uname_result',
 'unlink', 'urandom', 'utime', 'waitpid', 'walk', 'write']</samp></pre>
<p>Рассмотрим некоторые полезные функции из&nbsp;этого модуля, относящиеся к&nbsp;файлам и&nbsp;папкам. Остальные возможности вы&nbsp;можете почерпнуть из&nbsp;<a class="material__link" href="https://docs.python.org/3/library/os.html" target="_blank" rel="noopener noreferrer">документации</a> самостоятельно.</p>
<p>Аттрибут <var>os.name</var> содержит строковое значение с&nbsp;типом операционной системы, в&nbsp;которой выполняется наша программа. Допустимые значения:</p>
<ul>
<li><var>posix</var>&nbsp;&mdash; для linux и&nbsp;macOS</li>
<li><var>nt</var>&nbsp;&mdash; для операционных систем семейства Windows</li>
<li><var>java</var>&nbsp;&mdash; для систем, работающих в&nbsp;виртуальной Java-машине (например, Android)</li>
</ul>
<pre><code class="language-python">import os

print(os.name)
</code></pre>
<pre><samp>posix</samp></pre>
<p>Чтобы узнать имя текущего каталога, надо вызвать функцию <code>os.getcwd()</code>:</p>
<pre><code class="language-python">import os

print(os.getcwd())
</code></pre>
<pre><samp>/SomeUser/some folder</samp></pre>
<p>Если текущий каталог не&nbsp;был изменен (об&nbsp;этом ниже), то&nbsp;функция <code>os.getcwd()</code> вернет адрес каталога, в&nbsp;котором лежит ваша программа.</p>
<p>Для смены текущего каталога используется функция <code>os.chdir()</code>:</p>
<pre><code class="language-python">import os

os.chdir('files')
print(os.getcwd())
</code></pre>
<pre><samp>/SomeUser/some folder/files</samp></pre>
<p>Для чего это может быть нужно? Давайте, например, представим, что у&nbsp;нас идет обработка большого количества файлов, которые лежат в&nbsp;папке с&nbsp;нашей программой, в&nbsp;директории files. Тогда из&nbsp;программы необходимо будет обращаться к&nbsp;этим файлам с&nbsp;указанием относительного пути: files/file1, files/file2 и&nbsp;т.&nbsp;д. Это не&nbsp;всегда удобно. Иногда значительно проще поменять текущий каталог на&nbsp;/files и&nbsp;обращаться к&nbsp;файлам непосредственно по&nbsp;имени: file1, file2 и&nbsp;т.&nbsp;д.</p>
<p>Для того чтобы перейти из&nbsp;текущего каталога в&nbsp;родительский, необходимо вызвать функцию <code>os.chdir()</code> с&nbsp;аргументом <code>'..'</code></p>
<pre><code class="language-python">import os

os.chdir('..')
print(os.getcwd())
</code></pre>
<pre><samp>/SomeUser/</samp></pre>
<p>Можно использовать не&nbsp;только относительные пути, но&nbsp;и&nbsp;абсолютные, например: C:\Program files.</p>
<p>Проверить, существует&nbsp;ли файл, доступен&nbsp;ли файл для чтения или записи, можно с&nbsp;помощью функции <code>os.access()</code>:</p>
<pre><code class="language-python">os.access("1.txt", os.F_OK)
</code></pre>
<pre><samp>True</samp></pre>
<pre><code class="language-python">os.access("1.txt", os.R_OK)
</code></pre>
<pre><samp>True</samp></pre>
<pre><code class="language-python">os.access("такого файла нет.txt", os.F_OK)
</code></pre>
<pre><samp>False</samp></pre>
<p>Флаги <var>W_OK</var>, <var>R_OK</var>, <var>F_OK</var> отвечают соответственно за&nbsp;возможность записи, чтения, а&nbsp;также за&nbsp;факт существования файла.</p>
<p>Для получения списка файлов и&nbsp;вложенных каталогов используется функция <code>os.listdir()</code>:</p>
<pre><code class="language-python">import os

print(os.listdir())
</code></pre>
<pre><samp>['1', '2', '3', '1.txt', 'Icon\r']</samp></pre>
<p>В&nbsp;качестве параметра в&nbsp;<code>os.listdir()</code> можно передать относительный или абсолютный адрес каталога. Если ничего не&nbsp;передать, то&nbsp;напечатается список файлов и&nbsp;директорий в&nbsp;текущей папке.</p>
<p>Очень полезной может быть функция рекурсивного прохода по&nbsp;всем папкам в&nbsp;заданной папке (примерно такой&nbsp;же функциональности можно добиться самостоятельно, написав рекурсивный алгоритм, с&nbsp;использованием функции <code>os.listdir()</code> и&nbsp;<code>os.chdir()</code>).</p>
<p>Для примера рассмотрим следующую файловую структуру, начиная с&nbsp;каталога files:</p>
<pre><code>│ 1.txt
├───1
├───2
└───3
    │ Описание.txt
    │
    └───files
            └───csvs
                  └───данные.сsv
</code></pre>
<pre><code class="language-python">for currentdir, dirs, files in os.walk('files'):
    print(currentdir, dirs, files)
</code></pre>
<pre><samp>files ['1', '2', '3'] ['1.txt', 'Icon\r']
files/1 [] ['Icon\r']
files/2 [] ['Icon\r']
files/3 ['files'] ['Icon\r', 'Описание.txt']
files/3/files ['csvs'] []
files/3/files/csvs [] ['Icon\r', 'данные.csv']</samp></pre>
<p>Видим, что функция <code>os.walk()</code> возвращает кортеж из&nbsp;трех элементов: текущий каталог, список вложенных каталогов, список файлов текущей директории.</p>
<p>Рекурсивно перебирая папки, мы&nbsp;всегда имеем полное имя текущего каталога (относительно того, откуда стартовали), список папок данного каталога и&nbsp;список его файлов.</p>
<p>Например, когда оказались в&nbsp;папке&nbsp;3, то&nbsp;текущий каталог&nbsp;&mdash; это files/3, список папок&nbsp;&mdash; это <code>['files']</code>, а список файлов&nbsp;&mdash; <code>['Icon\r', 'Описание.txt']</code>.</p>
<p>Посмотрим теперь, какие функции нам предлагает модуль <var>os.path</var>:</p>
<pre><code class="language-python">print(dir(os.path))
</code></pre>
<pre><samp>['__all__', '__builtins__', '__cached__', '__doc__', '__file__',
 '__loader__', '__name__', '__package__', '__spec__', '_get_sep',
 '_joinrealpath', '_varprog', '_varprogb', 'abspath', 'altsep',
 'basename', 'commonpath', 'commonprefix', 'curdir', 'defpath',
 'devnull', 'dirname', 'exists', 'expanduser', 'expandvars',
 'extsep', 'genericpath', 'getatime', 'getctime', 'getmtime',
 'getsize', 'isabs', 'isdir', 'isfile', 'islink', 'ismount', 'join',
 'lexists', 'normcase', 'normpath', 'os', 'pardir', 'pathsep',
 'realpath', 'relpath', 'samefile', 'sameopenfile', 'samestat',
 'sep', 'split', 'splitdrive', 'splitext', 'stat',
 'supports_unicode_filenames', 'sys']</samp></pre>
<p>С&nbsp;помощью функции <code>os.path.exists()</code> можно проверить, существует&nbsp;ли файл, а&nbsp;с&nbsp;помощью функций <code>os.path.isfile()</code> и&nbsp;<code>os.path.isdir()</code> определить, какого он&nbsp;типа: &laquo;настоящий&raquo; или папка (здесь работает идеология UNIX).</p>
<p>Как видите, одну и&nbsp;ту&nbsp;же задачу можно выполнить по-разному, используя функциональность различных библиотек.</p>
<pre><code class="language-python">os.path.exists('files/3')
</code></pre>
<pre><samp>True</samp></pre>
<pre><code class="language-python">os.path.isfile('files/3')
</code></pre>
<pre><samp>False</samp></pre>
<pre><code class="language-python">os.path.isdir('files/2')
</code></pre>
<pre><samp>True</samp></pre>
<p>Функция <code>os.path.abspath()</code> вернет абсолютный путь по&nbsp;относительному:</p>
<pre><code class="language-python">os.path.abspath('1.txt')
</code></pre>
<pre><samp>'/SomeUser/some folder/1.txt'</samp></pre>
<p>А&nbsp;функция <code>os.path.dirname()</code> &mdash; полное имя каталога, в&nbsp;котором находится файл.</p>
<pre><code class="language-python">os.path.dirname('1.txt')
</code></pre>
<pre><samp>''</samp></pre>
<pre><code class="language-python">os.path.dirname('3/files/csvs/данные.csv')
</code></pre>
<pre><samp>'3/files/csvs'</samp></pre>
</section>
<section class="material__chapter">
<h2 id="4">Модуль shutil (shell utilities)</h2>
<p>Еще один полезный модуль&nbsp;&mdash; shutil (правда веселое название?). В&nbsp;нем содержатся несколько высокоуровневых функций для манипуляции с&nbsp;файлами: копирование, перемещение, удаление и&nbsp;другие. Все&nbsp;то, что обычно делается через файловые менеджеры&nbsp;ОС, например, через проводник.</p>
<p>Чтобы скопировать файл, надо использовать функцию <code>shutil.copy()</code>. В&nbsp;ней необходимо указать два <strong>обязательных</strong> параметра:</p>
<ul>
<li>Источник (что копируем)</li>
<li>Приемник (куда копируем)</li>
</ul>
<p>Оба параметра&nbsp;&mdash; строки.</p>
<pre><code class="language-python">import shutil

shutil.copy('files/3/Описание.txt', 'files/Копия.txt')
</code></pre>
<pre><samp>'files/Копия.txt'</samp></pre>
<p>Заметьте, что если файл-приемник уже существовал, то&nbsp;он&nbsp;будет <strong>перезаписан</strong>. Кроме того, файл-источник и&nbsp;файл-приемник не&nbsp;могут совпадать, то&nbsp;есть файл <strong>нельзя</strong> скопировать в&nbsp;себя&nbsp;же.</p>
<p>Удаление папки со&nbsp;всем ее&nbsp;содержимым выполняется функцией <code>shutil.rmtree()</code> (от&nbsp;английского remove tree). В&nbsp;качестве параметра передается полный путь до&nbsp;папки.</p>
<pre><code class="language-python">shutil.rmtree('Путь до папки')
</code></pre>
<p>Перенос папки (со&nbsp;всем ее&nbsp;содержимым) в&nbsp;новое место осуществляется функцией <code>shutil.move()</code>, которая по&nbsp;своему виду похожа на&nbsp;<code>shutil.copy()</code>, только после копирования она &laquo;заметает свои следы&raquo;.</p>
<pre><code class="language-python">shutil.move(старое_место, новое_место)
</code></pre>
<p>Также функции модуля shutil дают возможность работать с&nbsp;некоторыми типами зарегистрированных в&nbsp;системе архивов, создавая их&nbsp;или распаковывая:</p>
<pre><code class="language-python">shutil.get_archive_formats()
</code></pre>
<pre><samp>[('bztar', "bzip2'ed tar-file"),
 ('gztar', "gzip'ed tar-file"),
 ('tar', 'uncompressed tar file'),
 ('xztar', "xz'ed tar-file"),
 ('zip', 'ZIP file')]</samp></pre>
<pre><code class="language-python">shutil.make_archive('archive', 'zip', root_dir='files')
</code></pre>
<pre><samp>'/SomeUser/some folder/archive.zip'</samp></pre>
<p>В&nbsp;последнем примере мы&nbsp;создали архив с&nbsp;именем archive типа zip, положив него все содержимое каталога files. Сам архив при этом будет размещен в&nbsp;текущем каталоге.</p>
</section>
<section class="material__chapter">
<h2 id="5">Zip-архивы</h2>
<p>Раз уж&nbsp;мы&nbsp;заговорили об&nbsp;архивах, задержимся на&nbsp;них немного подольше.</p>
<p>Работе с&nbsp;архивами посвящена соответствующая <a class="material__link" href="https://docs.python.org/3/library/archiving.html" target="_blank" rel="noopener noreferrer">глава документации</a>. В&nbsp;современном мире применяется большое количество архиваторов: zip, 7z, rar и&nbsp;т.&nbsp;д. Мы&nbsp;пока остановимся только на&nbsp;zip-архивах по&nbsp;двум причинам:</p>
<ul>
<li>Это самый распространенный и&nbsp;свободный формат архива. (Под термином <strong>свободный</strong> мы&nbsp;понимаем&nbsp;то, что алгоритм опубликован и&nbsp;свободен в&nbsp;том числе от&nbsp;коммерческих отчислений автору)</li>
<li>Несколько типов файлов (даже среди тех форматов, с&nbsp;которыми мы&nbsp;уже работали), например, docx, pptx, jar являются по&nbsp;сути форматами на&nbsp;основе zip-архивов. Сделано это было потому, что удобнее все ресурсы документа хранить как единое целое, нежели как набор файлов. Кроме того, архивация позволяет существенно уменьшить объем документа</li>
</ul>
<p>Архивы, помимо сжатия данных (а&nbsp;мы&nbsp;говорим только про сжатие <strong>без потерь</strong> и&nbsp;не&nbsp;касаемся, например, сжатия видео-информации), могут пригодиться для удобной упаковки разнородной информации в&nbsp;одном файле.</p>
<p>В&nbsp;Python с&nbsp;архивами можно работать разными способами:</p>
<ul>
<li>Как и&nbsp;в&nbsp;большинстве языков программирования, нам доступен запуск сторонних программ, и&nbsp;в&nbsp;этом случае мы&nbsp;можем просто вызвать стороннюю программу-архиватор</li>
<li>Стандартный модуль shutil (это мы&nbsp;уже немного попробовали)</li>
<li>Стандартный модуль gzip</li>
<li>Стандартный модуль zipfile</li>
</ul>
<p>Мы&nbsp;остановимся на&nbsp;модуле zipfile, как наиболее функциональном и&nbsp;удобном.</p>
<p>Основное преимущество данной библиотеки заключается в&nbsp;том, что она позволяет работать с&nbsp;архивом (а&nbsp;в&nbsp;архив может быть помещена целая структура каталогов), как с&nbsp;обычной папкой, содержащей файлы и&nbsp;другие каталоги.</p>
<p>Напишем программу, которая выведет на&nbsp;экран содержание архива, который мы&nbsp;создали ранее, используя арсенал библиотеки shutil:</p>
<pre><code class="language-python">from zipfile import ZipFile

with ZipFile('archive.zip') as myzip:
    myzip.printdir()
</code></pre>
<pre><samp>File Name                              Modified             Size
1/                                2017-09-18 16:02:12         0
2/                                2017-09-18 16:02:14         0
3/                                2017-09-18 16:02:44         0
1.txt                             2017-09-18 15:59:30        35
                                  2017-09-18 14:28:20         0
Копия.txt                         2017-09-18 16:26:52         0
                                  2017-09-18 16:02:12         0
                                  2017-09-18 16:02:14         0
3/files/                          2017-09-18 16:02:30         0
                                  2017-09-18 16:02:16         0
3/Описание.txt                    2017-09-18 16:02:40         0
3/files/csvs/                     2017-09-18 16:02:58         0
                                  2017-09-18 16:02:36         0
3/files/csvs/данные.csv           2017-09-18 16:02:52         0</samp></pre>
<p>В&nbsp;начале работы мы&nbsp;создаем объект типа <var>ZipFile</var>, передавая ему имя архива. Можно указать и&nbsp;необязательный параметр <var>mode</var> (режим работы), который принимает в&nbsp;себя значения&nbsp;<var>r</var>, <var>w</var>&nbsp;или&nbsp;<var>a</var> (все по&nbsp;аналогии с&nbsp;&laquo;чистыми&raquo; файлами). Но&nbsp;по&nbsp;умолчанию считается, что архив открывается для чтения, поэтому мы&nbsp;не&nbsp;будем его указывать.</p>
<p>Кроме печати, можно получать информацию о&nbsp;файлах в&nbsp;архиве в&nbsp;виде списка:</p>
<pre><code class="language-python">with ZipFile('archive.zip') as myzip:
    info = myzip.infolist()
print(info[0].orig_filename)
</code></pre>
<pre><samp>1/</samp></pre>
<p>А&nbsp;также имена файлов в&nbsp;архиве, тоже в&nbsp;виде списка:</p>
<pre><code class="language-python">with ZipFile('archive.zip') as myzip:
    print(myzip.namelist())
</code></pre>
<pre><samp>['1/', '2/', '3/', '1.txt', 'Icon\r', 'Копия.txt', '1/Icon\r',
 '2/Icon\r', '3/files/', '3/Icon\r', '3/Описание.txt',
 '3/files/csvs/', '3/files/csvs/Icon\r', '3/files/csvs/данные.csv']</samp></pre>
<p>Согласитесь, такой способ очень похож на&nbsp;классический вариант работы с&nbsp;файлами, который мы&nbsp;рассматривали ранее.</p>
<p>Структуру архива мы&nbsp;получили, &laquo;вытащим&raquo; теперь и&nbsp;конкретный файл:</p>
<pre><code class="language-python">with ZipFile('archive.zip') as myzip:
    with myzip.open('1.txt', 'r') as file:
        print(file.read())
</code></pre>
<pre><samp>b'\xd0\x9f\xd1\x80\xd0\xbe\xd0\xb8\xd0\xb7\xd0\xb2\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\xb9\xd1\x82\xd0\xb5\xd0\xba\xd1\x81\xd1\x82'</samp></pre>
<p>Что&nbsp;же у&nbsp;нас получилось? Обратите внимание на&nbsp;символ <var>b</var>&nbsp;перед выводом. Это бинарная последовательность. Но&nbsp;мы-то знаем, что перед нами&nbsp;&mdash; текстовый файл, поэтому мы&nbsp;можем быстро преобразовать (декодировать) эту строку. Надо только помнить, в&nbsp;какой кодировке записан файл.</p>
<pre><code class="language-python">with ZipFile('archive.zip') as myzip:
    with myzip.open('1.txt', 'r') as file:
        print(file.read().decode('utf-8'))
</code></pre>
<pre><samp>Произвольный текст</samp></pre>
<p>По&nbsp;аналогии с&nbsp;чтением файлов из&nbsp;архива их&nbsp;можно туда и&nbsp;записывать.</p>
<pre><code class="language-python">with ZipFile('archive.zip', 'w') as myzip:
    myzip.write('test.txt')
    print(myzip.namelist())
</code></pre>
<pre><samp>['test.txt']</samp></pre>
<p>Сейчас мы&nbsp;создали новый архив, а&nbsp;предыдущий уничтожили, поэтому для добавления файла в&nbsp;уже существующий архив будем работать с&nbsp;ним с&nbsp;ключом&nbsp;<var>a</var>:</p>
<pre><code class="language-python">with ZipFile('archive.zip', 'a') as myzip:
    myzip.write('test.txt')
    print(myzip.namelist())
</code></pre>
<pre><samp>['1/', '2/', '3/', '1.txt', 'Icon\r', 'Копия.txt', '1/Icon\r',
 '2/Icon\r', '3/files/', '3/Icon\r', '3/Описание.txt',
 '3/files/csvs/', '3/files/csvs/Icon\r', '3/files/csvs/данные.csv',
 'test.txt']</samp></pre>
<p>Вот! Теперь другое дело!</p>
<p>Кроме того, у&nbsp;<var>ZipFile</var> есть метод <var>extractall()</var>, который вытаскивает из&nbsp;архива все содержимое в&nbsp;указанную папку. Интересный момент: если папку не&nbsp;указывать, то&nbsp;данные сложатся в&nbsp;&laquo;текущую папку&raquo;, то&nbsp;есть в&nbsp;данном случае туда, где находится файл с&nbsp;программой. Структура каталогов при этом сохраняется.</p>
<pre><code class="language-python">ZipFile.extractall(path=None, members=None, pwd=None)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="6">Формат JSON</h2>
<p>Вот мы&nbsp;и&nbsp;добрались&nbsp;до, пожалуй, самого популярного формата файлов в&nbsp;Интернете&nbsp;&mdash; JSON. Некоторые из&nbsp;вас могут удивиться этому утверждению, так как услышат про этот формат впервые. На&nbsp;самом деле все из&nbsp;вас пользовались данным форматом, пусть и&nbsp;неявно. Именно JSON обмениваются большинство приложений в&nbsp;Интернете.</p>
<p>JSON (англ. JavaScript Object Notation)&nbsp;&mdash; один из&nbsp;самых популярных типов структурированных файлов, поддерживающих произвольную вложенность. Это формат объекта в&nbsp;языке JavaScript, содержащий в&nbsp;себе сочетание словарей и&nbsp;списков (в&nbsp;терминах Python). Оказывается, что вместо того, чтобы передавать или хранить файлы в&nbsp;каких-то форматах, потом при помощи библиотек обрабатывая&nbsp;их, удобней передавать сами объекты языка. Ведь в&nbsp;этом случае не&nbsp;надо ничего дополнительно обрабатывать. Перед нами&nbsp;&mdash; уже готовый объект. Так как в&nbsp;последнее время очень распространились веб-приложения на&nbsp;JavaScript, JSON стал одним из&nbsp;самых популярных форматов, в&nbsp;том числе и&nbsp;в&nbsp;других языках.</p>
<p>Чтобы лучше понять JSON, давайте сначала посмотрим на&nbsp;модуль pickle. Он&nbsp;служит для того, чтобы превращать любой объект Python в&nbsp;байтовую структуру и&nbsp;обратно:</p>
<pre><code class="language-python">from pickle import loads, dumps
s = {'Иван': 24, 'Сергей': 11}
d = dumps(s)
print(d)
</code></pre>
<pre><samp>b'\x80\x03}q\x00(X\x08\x00\x00\x00\xd0\x98\xd0\xb2\xd0\xb0\xd0\xbdq\x01K\x18X\x0c\x00\x00\x00\xd0\xa1\xd0\xb5\xd1\x80\xd0\xb3\xd0\xb5\xd0\xb9q\x02K\x0bu.'</samp></pre>
<pre><code class="language-python">loads(d)
</code></pre>
<pre><samp>{'Иван': 24, 'Сергей': 11}</samp></pre>
<p>Объект, представленный в&nbsp;виде массива байт, легко хранить на&nbsp;жестком диске, в&nbsp;базах данных, передавать по&nbsp;сети между двумя приложениями или от&nbsp;одного приложения другому в&nbsp;рамках одного компьютера&nbsp;и&nbsp;т.&nbsp;д.</p>
<p>Теперь посмотрим, что&nbsp;же такое JSON.</p>
<p>Запросим по&nbsp;<a class="material__link" href="https://geocode-maps.yandex.ru/1.x/?apikey=40d1649f-0493-4b70-98ba-98533de7710b&amp;geocode=аэропорт%20Внуково&amp;format=json" target="_blank" rel="noopener noreferrer">ссылке</a> у&nbsp;Яндекс.Карт информацию о&nbsp;московском аэропорте Внуково.</p>
<p>Пройдите по&nbsp;этой ссылке и&nbsp;убедитесь, что ответ действительно приходит.</p>
<p>Нам вернется вот такой ответ:</p>
<pre><samp>{
	"response": {
		"GeoObjectCollection": {
			"metaDataProperty": {
				"GeocoderResponseMetaData": {
					"request": "аэропорт Внуково",
					"found": "2",
					"results": "10"
				}
			},
			"featureMember": [{
				"GeoObject": {
					"metaDataProperty": {
						"GeocoderMetaData": {
							"kind": "airport",
							"text": "Россия, Москва, аэропорт Внуково",
							"precision": "other",
							"Address": {
								"country_code": "RU",
								"formatted": "Москва, аэропорт Внуково",
								"Components": [{
									"kind": "country",
									"name": "Россия"
								},
								{
									"kind": "province",
									"name": "Центральный федеральный округ"
								},
								{
									"kind": "province",
									"name": "Москва"
								},
								{
									"kind": "airport",
									"name": "аэропорт Внуково"
								}]
							},
							"AddressDetails": {
								"Country": {
									"AddressLine": "Москва, аэропорт Внуково",
									"CountryNameCode": "RU",
									"CountryName": "Россия",
									"AdministrativeArea": {
										"AdministrativeAreaName": "Москва",
										"Locality": {
											"DependentLocality": {
												"DependentLocalityName": "аэропорт Внуково"
											}
										}
									}
								}
							}
						}
					},
					"description": "Москва, Россия",
					"name": "аэропорт Внуково",
					"boundedBy": {
						"Envelope": {
							"lowerCorner": "37.229833 55.583169",
							"upperCorner": "37.303809 55.61598"
						}
					},
					"Point": {
						"pos": "37.286292 55.605058"
					}
				}
			},
			{
				"GeoObject": {
					"metaDataProperty": {
						"GeocoderMetaData": {
							"kind": "railway",
							"text": "Россия, Киевское направление Московской железной дороги, платформа Аэропорт Внуково",
							"precision": "other",
							"Address": {
								"country_code": "RU",
								"formatted": "Киевское направление Московской железной дороги, платформа Аэропорт Внуково",
								"Components": [{
									"kind": "country",
									"name": "Россия"
								},
								{
									"kind": "province",
									"name": "Центральный федеральный округ"
								},
								{
									"kind": "route",
									"name": "Киевское направление Московской железной дороги"
								},
								{
									"kind": "railway",
									"name": "платформа Аэропорт Внуково"
								}]
							},
							"AddressDetails": {
								"Country": {
									"AddressLine": "Киевское направление Московской железной дороги, платформа Аэропорт Внуково",
									"CountryNameCode": "RU",
									"CountryName": "Россия",
									"Country": {
										"Locality": ""
									}
								}
							}
						}
					},
					"description": "Киевское направление Московской железной дороги, Россия",
					"name": "платформа Аэропорт Внуково",
					"boundedBy": {
						"Envelope": {
							"lowerCorner": "37.279914 55.601106",
							"upperCorner": "37.296371 55.610423"
						}
					},
					"Point": {
						"pos": "37.288142 55.605765"
					}
				}
			}]
		}
	}
}</samp></pre>
<p>Как видно из&nbsp;этого примера, JSON очень похож по&nbsp;синтаксису на&nbsp;формат словаря в&nbsp;Python. Поэтому любая работа с&nbsp;JSON в&nbsp;Python происходит по&nbsp;алгоритму:</p>
<ol>
<li>Получение словаря с&nbsp;данными</li>
<li>Преобразование словаря в&nbsp;JSON-объект</li>
<li>Передача данных</li>
</ol>
<p>Или в&nbsp;обратную сторону:</p>
<ol>
<li>Получение файла или строки с&nbsp;JSON-содержимым</li>
<li>Преобразование данных в&nbsp;словарь Python</li>
<li>Работа с&nbsp;данными</li>
</ol>
</section>
<section class="material__chapter">
<h2 id="7">Библиотека для работы с&nbsp;JSON</h2>
<p>Для работы с&nbsp;JSON есть стандартный модуль json.</p>
<p>Поработаем с&nbsp;ним. Этот модуль содержит аналогичный <var>pickle</var> интерфейс, то&nbsp;есть нам доступны функции <code>loads()</code> (загрузка из&nbsp;строки JSON-объекта и&nbsp;преобразование его в&nbsp;Python-объект) и&nbsp;<code>dumps()</code> (обратное преобразование).</p>
<p><strong>Чтение json.</strong></p>
<p>Откроем в&nbsp;IDE файл <a class="material__link" href="https://yastatic.net/s3/lyceum/content/resources/web/cats_json.json" target="_blank" rel="noopener noreferrer">cats_json.json</a>. Мы&nbsp;видим, что там в&nbsp;виде словаря записана некоторая информация о&nbsp;питомце:</p>
<pre><code class="language-python">{
  "name": "Barsik",
  "age": 7,
  "meals": [
    "Wiskas",
    "Royal Canin",
    "Purina",
    "Hills",
    "Brit Care"
  ]
}
</code></pre>
<p>Обратите внимание: в&nbsp;формате JSON используются только двойные кавычки.</p>
<p>Для чтения данных в&nbsp;модуле <var>json</var> есть два метода:</p>
<ol>
<li><code>json.load()</code>&nbsp;&mdash; считывает целиком файл в&nbsp;формате JSON и&nbsp;возвращает объекты Python</li>
<li><code>json.loads()</code>&nbsp;&mdash; считывает строку в&nbsp;формате JSON и&nbsp;возвращает объекты Python</li>
</ol>
<p>Напишем код, читающий файл и&nbsp;выводящий содержимое полученного словаря:</p>
<pre><code class="language-python">import json

with open('cats_json.json') as cat_file:
    data = json.load(cat_file)
for key, value in data.items():
    if type(value) == list:
        print(f'{key}: {", ".join(value)}')
    else:
        print(f'{key}: {value}')
</code></pre>
<pre><samp>name: Barsik
age: 7
meals: Wiskas, Royal Canin, Purina, Hills, Brit Care
</samp></pre>
<p>В&nbsp;отличие от&nbsp;метода <code>json.load(filename)</code>, метод <code>json.loads(string)</code> считывает строку и&nbsp;возвращает объект json, если его возможно получить из&nbsp;переданной строки.</p>
<p>В&nbsp;случае, если строка или файловый объект содержат некорректный JSON, будет выброшено исключение типа json.decoder.JSONDecodeError.</p>
<pre><code class="language-python">import json

s = 'Не Json'
json.loads(s)
</code></pre>
<pre><samp>json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
</samp></pre>
<p>Создайте в&nbsp;IDE новый файл cats_2.json, в&nbsp;который кроме Барсика добавьте еще одного кота по&nbsp;вашему усмотрению. Поскольку теперь в&nbsp;файле у&nbsp;нас уже два словаря, их&nbsp;надо объединить в&nbsp;одну структуру, пусть это будет список. Получим что-то вроде такого содержимого:</p>
<pre><code class="language-python">[
  {
    "name": "Barsik",
    "age": 7,
    "meals": [
      "Wiskas",
      "Royal Canin",
      "Purina",
      "Hills",
      "Brit Care"
    ]
  },
  {
    "name": "Mursik",
    "age": 3,
    "meals": [
      "Purina",
      "Hills",
      "Brit Care"
    ]
  }
]
</code></pre>
<p>Чтобы воспользоваться методом <code>loads()</code>, нужно сначала считать весь файл в&nbsp;строку, а&nbsp;затем передать ее&nbsp;методу для преобразования в&nbsp;json-объект.</p>
<pre><code class="language-python">import json

with open('cats_2.json') as cat_file:
    f = cat_file.read()
    data = json.loads(f)
    for item in data:
        for key, value in item.items():
            if type(value) == list:
                print(f'{key}: {", ".join(value)}')
            else:
                print(f'{key}: {value}')
        print()
</code></pre>
<p>И&nbsp;в&nbsp;том, и&nbsp;в&nbsp;другом случае мы&nbsp;получили объект языка Python, словарь или список, с&nbsp;которым можно сразу работать средствами языка.</p>
<p>В&nbsp;таблице представлено соответствие между данными в&nbsp;Python и&nbsp;в&nbsp;JSON:</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse; width: 100%;" border="1" cellpadding="5px">
<thead>
<tr>
<th>Python</th>
<th>JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td>dict</td>
<td>object</td>
</tr>
<tr>
<td>list, tuple</td>
<td>array</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>int, float</td>
<td>number</td>
</tr>
<tr>
<td>True</td>
<td>true</td>
</tr>
<tr>
<td>False</td>
<td>false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
</tbody>
</table>
</div>
<p>При обратном преобразовании массив <var>array</var> преобразуется в&nbsp;список.</p>
<p><strong>Запись в файл.</strong></p>
<p>Для записи информации в&nbsp;файл в&nbsp;<var>json</var> также есть два метода:</p>
<ol>
<li><code>json.dump()</code>&nbsp;&mdash; метод записывает объект Python в&nbsp;файл в&nbsp;формате JSON</li>
<li><code>json.dumps()</code>&nbsp;&mdash; метод преобразует объект Python в&nbsp;строку в&nbsp;формате JSON</li>
</ol>
<p>Давайте создадим словарь, в&nbsp;котором коту добавим хозяев, а&nbsp;затем полученную информацию сохраним в&nbsp;файле:</p>
<pre><code class="language-python">import json

cats_dict = {
    'name': 'Pushin',
    'age': 1,
    'meals': [
        'Purina', 'Cat Chow', 'Hills'
    ],
    'owners': [
        {
            'first_name': 'Bill',
            'last_name': 'Gates'
        },
        {
            'first_name': 'Melinda',
            'last_name': 'Gates'
        }
    ]
}

with open('cats_3.json', 'w') as cat_file:
    json.dump(cats_dict, cat_file)
</code></pre>
<p>Если сейчас открыть в&nbsp;IDE PyCharm файл cats_3.json, который был создан нашей программой, мы&nbsp;увидим, что json выведен в&nbsp;одну строку без форматирования. Для представления json в&nbsp;удобном для чтения виде в&nbsp;PyCharm можно использовать горячую клавишу Ctrl-Alt-L.</p>
<p>Метод <code>dumps()</code> используется, когда надо просто преобразовать объект в&nbsp;json-формат, необязательно для записи в&nbsp;файл. Это нужно, например, при передаче информации в&nbsp;веб-приложении.</p>
<p>Посмотрим на&nbsp;примере:</p>
<pre><code class="language-python">import json

weekdays = {i: day
            for i, day in enumerate(['Sunday', 
                                     'Monday',
                                     'Tuesday', 
                                     'Wednesday',
                                     'Thursday', 
                                     'Friday',
                                     'Saturday'
                                     ])}
data = json.dumps(weekdays)
print(data)
print(type(data))
</code></pre>
<p>Получим строку в&nbsp;формате json:</p>
<pre><samp>{"0": "Sunday", "1": "Monday", "2": "Tuesday", "3": "Wednesday", "4": "Thursday", "5": "Friday", "6": "Saturday"}
&lt;class 'str'&gt;</samp></pre>
<p><strong>Дополнительные параметры методов записи.</strong></p>
<p>Методы записи имеют несколько необязательных параметров, которые можно менять для более удобного чтения человеком. Рассмотрим некоторые из&nbsp;них.</p>
<p><strong>ensure_ascii</strong>. В&nbsp;случае, если <code>ensure_ascii=True</code> (по&nbsp;умолчанию), все не-ASCII символы в&nbsp;выводе будут экранированы последовательностями \uXXXX. Если <code>ensure_ascii=False</code>, эти символы будут записаны как есть. Это важно, если в&nbsp;содержимом есть русские буквы.</p>
<p>Запишем в&nbsp;файл cats.json содержимое списка без флага:</p>
<pre><code class="language-python">with open('cats.json', 'w') as file:
    json.dump(data, file)
</code></pre>
<p>В файле:</p>
<pre><samp>[
    {
        "name": "\u0411\u0430\u0440\u0441\u0438\u043a",
        "age": 7,
        "toys": [
            "\u041c\u044b\u0448\u043a\u0430",
            "\u041f\u0440\u0443\u0442\u0438\u043a",
            "\u0411\u0430\u043d\u0442\u0438\u043a",
            "\u0421\u0432\u043e\u0439 \u0445\u0432\u043e\u0441\u0442"
        ]
    },
    {
        "name": "\u041c\u0443\u0440\u0437\u0438\u043a",
        "age": 3,
        "toys": [
            "\u0420\u0443\u043a\u0430 \u0445\u043e\u0437\u044f\u0439\u043a\u0438",
            "\u0428\u043d\u0443\u0440 \u043e\u0442 \u0442\u0435\u043b\u0435\u0432\u0438\u0437\u043e\u0440\u0430",
            "\u041e\u0431\u043e\u0438 \u043d\u0430 \u0441\u0442\u0435\u043d\u0435"
        ]
    }
]</samp></pre>
<p>А&nbsp;теперь&nbsp;&mdash; с&nbsp;флагом:</p>
<pre><code class="language-python">with open('cats.json', 'w') as file:
    json.dump(data, file, ensure_ascii=False)
</code></pre>
<p>В файле:</p>
<pre><samp>[
    {
        "name": "Барсик",
        "age": 7,
        "toys": [
            "Мышка",
            "Прутик",
            "Бантик",
            "Свой хвост"
        ]
    },
    {
        "name": "Мурзик",
        "age": 3,
        "toys": [
            "Рука хозяйки",
            "Шнур от телевизора",
            "Обои на стене"
        ]
    }
]</samp></pre>
<p><strong>indent</strong>. Отступ <var>indent</var> нужен для удобного для чтения человеком представления информации в&nbsp;объекте JSON. По&nbsp;умолчанию имеет значение None для более компактного представления, то&nbsp;есть без отступов. Также отступов не&nbsp;будет, если значение <var>indent</var> равно&nbsp;0, отрицательному числу или пустой строке. Если <var>indent</var>&nbsp;&mdash; строка (например, <code>\t</code>), эта строка используется в&nbsp;качестве отступа.</p>
<p>Пример со&nbsp;значением <code>indent=2</code>:</p>
<pre><code class="language-python">with open('cats.json', 'w') as file:
    json.dump(data, file, ensure_ascii=False, indent=2)
</code></pre>
<p>Результат:</p>
<pre><samp>[
  {
    "name": "Барсик",
    "age": 7,
    "toys": [
      "Мышка",
      "Прутик",
      "Бантик",
      "Свой хвост"
    ]
  },
  {
    "name": "Мурзик",
    "age": 3,
    "toys": [
      "Рука хозяйки",
      "Шнур от телевизора",
      "Обои на стене"
    ]
  }
]</samp></pre>
<p><strong>sort_keys</strong>. Если <code>sort_keys=True</code> (по&nbsp;умолчанию False), ключи выводимого словаря будут отсортированы. Это удобно, если ключей много.</p>
<p>Пример со&nbsp;значением <code>sort_keys=True</code>:</p>
<pre><code class="language-python">with open('cats.json', 'w') as file:
    json.dump(data, file, ensure_ascii=False,
              indent=2, sort_keys=True)
</code></pre>
<p>Результат:</p>
<pre><samp>[
  {
    "age": 7,
    "name": "Барсик",
    "toys": [
      "Мышка",
      "Прутик",
      "Бантик",
      "Свой хвост"
    ]
  },
  {
    "age": 3,
    "name": "Мурзик",
    "toys": [
      "Рука хозяйки",
      "Шнур от телевизора",
      "Обои на стене"
    ]
  }
]</samp></pre>
</section>
<section class="material__chapter">
<h2 id="8">В заключении</h2>
<section class="material__note">
<p class="material__note-heading"><strong>Сериализация и десериализация</strong></p>
<p>Мы&nbsp;производили преобразования между объектами языка Python и&nbsp;json-объектами. Такие преобразования называются <strong>сериализацией</strong> (кодирование в&nbsp;json-формат, то&nbsp;есть в&nbsp;поток байт) и&nbsp;<strong>десериализацией</strong> (декодирование в&nbsp;объект языка).</p>
</section>
<p>Есть еще несколько моментов при работе с&nbsp;JSON, о&nbsp;которых стоит помнить:</p>
<ol>
<li>Чтобы не&nbsp;возникали проблемы с&nbsp;кодировкой, если в&nbsp;файл передаются данные с&nbsp;русскими буквами, как и&nbsp;во&nbsp;всех других случаяx работы с&nbsp;файлом, при открытии нужно принудительно устанавливать кодировку (особенно актуально для&nbsp;OS семейства Windows):
<pre><code class="language-python">with open('cats_3.json', 'w', encoding='utf8') as cat_file:
    cat_file.write(json.dumps(cats_dict))
</code></pre>
</li>
<li>При создании json-файла &laquo;вручную&raquo; нужно помнить, что в&nbsp;нем нельзя использовать одинарные кавычки. При создании программными средствами нужные кавычки ставятся автоматически.</li>
<li>Ключами словаря в&nbsp;json не&nbsp;могут быть кортежи и&nbsp;числа. Но&nbsp;ключ-число не&nbsp;вызовет ошибку при сериализации, он&nbsp;будет просто преобразован в&nbsp;строку.</li>
<li>Помните, что при преобразовании данные будут не&nbsp;всегда того&nbsp;же типа, что были в&nbsp;Python, то&nbsp;есть:</li>
</ol>
<pre><code class="language-python">print(json.loads(json.dumps(weekdays)) == weekdays)  # False
</code></pre>
<p>Более подробную информацию по&nbsp;работе с&nbsp;модулем <var>json</var> можно найти по&nbsp;<a class="material__link" href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener noreferrer">ссылке</a>.</p>
<p>О&nbsp;работе непосредственно с&nbsp;API мы&nbsp;поговорим уже на&nbsp;следующем уроке.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>