<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Практика по работе с графикой и tkinter </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок tkinter</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Практика по&nbsp;работе с&nbsp;графикой и&nbsp;tkinter</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Программирование в&nbsp;графическом интерфейсе</a></li>
<li><a class="material__link" href="#2">Учимся рисовать</a></li>
<li><a class="material__link" href="#3">Взаимодействие с&nbsp;пользователем</a></li>
<li><a class="material__link" href="#4">Движение объектов</a></li>
<li><a class="material__link" href="#5">Приступаем к&nbsp;игре</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке мы&nbsp;научимся писать небольшие программы, которые работают не&nbsp;с&nbsp;консолью, а&nbsp;с&nbsp;окном приложения (графическим пользовательским интерфейсом, GUI). Для этого нам понадобится дополнительная функциональность&nbsp;&mdash; библиотека tkinter. То, чем мы&nbsp;будем заниматься&nbsp;&mdash; только самое начало программирования GUI, поэтому не&nbsp;стоит ожидать того, что мы&nbsp;создадим Photoshop. Но&nbsp;все впереди, и&nbsp;когда-нибудь мы&nbsp;сделаем и&nbsp;это.</p>
</section>
<section class="material__chapter">
<h2 id="1">Программирование в&nbsp;графическом интерфейсе</h2>
<p>Согласитесь, что скучно все время видеть перед собой черный экран, который мы&nbsp;называем консолью. На&nbsp;нем нельзя рисовать, пользоваться &laquo;мышкой&raquo; или джойстиком, организовывать привычный нам оконный интерфейс. Сегодня и&nbsp;на&nbsp;нескольких следующих занятиях мы&nbsp;познакомимся с&nbsp;функциональностью языка Python, которая позволит нам все&nbsp;же немного поработать в&nbsp;графическом режиме.</p>
<p>Как вы&nbsp;уже догадываетесь, не&nbsp;вся функциональность языка Python включена&nbsp;в, что называется, стандартную поставку. Какие-то вещи надо добавлять к&nbsp;этому коробочному решению. Эти &laquo;добавки&raquo; называются библиотеками. Скоро вы&nbsp;узнаете о&nbsp;них подробнее, а&nbsp;пока мы&nbsp;подключим лишь одну из&nbsp;них, которая называется tkinter, и&nbsp;которая поможет нам поработать с&nbsp;графикой.</p>
<p>Попробуйте написать и&nbsp;выполнить следующий код:</p>
<pre><code class="language-python">import tkinter

master = tkinter.Tk()
master.mainloop()
</code></pre>
<p>У&nbsp;вас должно открыться пустое окошко, как на&nbsp;рисунке:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/image/tkinter/tkinter-1.png" width="200" height="auto" /></div>
<p>Если при запуске Python ответит <code>ImportError: No&nbsp;module named 'tkinter'</code>, то&nbsp;это означает, что библиотека tkinter на&nbsp;вашем компьютере отсутствует и&nbsp;нужно ее&nbsp;установить.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Установка tkinter</strong></p>
<p>Установить стандартный пакет библиотек в&nbsp;Python очень просто, для этого есть специальный менеджер пакетов&nbsp;&mdash; pip. Чтобы воспользоваться&nbsp;им, запустите терминал (в&nbsp;Windows для этого нужно нажать Пуск, набрать cmd и&nbsp;нажать Enter). В&nbsp;терминале наберите:</p>
<pre><code>pip install tkinter
</code></pre>
<p>И&nbsp;следуйте указаниям. Обычно надо со&nbsp;всем согласиться.</p>
</section>
<p>Но&nbsp;вернемся к&nbsp;нашему коду и&nbsp;поймем, что&nbsp;же делают написанные в&nbsp;нем строки.</p>
<p><code>import tkinter</code>&nbsp;&mdash; просто подключение пакета, с&nbsp;такими строчками мы&nbsp;уже встречались.</p>
<p>Вторая строчка&nbsp;&mdash; <code>master = tkinter.Tk()</code> &mdash; создает основное окно и&nbsp;дает ему имя master. Дальше мы&nbsp;будем наполнять его содержимым.</p>
<p>Третья строчка&nbsp;&mdash; <code>master.mainloop()</code> &mdash; самая необычная. Дело в&nbsp;том, что приложение с&nbsp;графическим интерфейсом работает не&nbsp;так, как консольные приложения, которые мы&nbsp;писали раньше. В&nbsp;консольных приложениях компьютер исполнял наши инструкции одну за&nbsp;другой. В&nbsp;программе с&nbsp;графическим интерфейсом такой подход работать не&nbsp;будет, потому что компьютер должен реагировать на&nbsp;действия пользователя. Поэтому вместо того, чтобы выполнять команды, он&nbsp;ждет сигналов от&nbsp;пользователя, которые нужно как-то обрабатывать.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Основной цикл</strong></p>
<p>Команда <code>master.mainloop()</code> запускает для нашего окна <strong>основной цикл</strong>. Он&nbsp;получает информацию о&nbsp;важных событиях (нажатии клавиш, движениях мышки и&nbsp;пр.), обрабатывает эти события и&nbsp;перерисовывает окно.</p>
</section>
<p>Так работают все приложения с&nbsp;графическим интерфейсом. Если вы&nbsp;пользуетесь ОС&nbsp;Windows, то&nbsp;наверняка встречали сообщение, что какая-то программа не&nbsp;отвечает. Обычно это означает, что внутри основного цикла что-то пошло не&nbsp;так (например, программа вошла в&nbsp;бесконечный цикл или зависла). Система продолжает посылать программе сообщения о&nbsp;событиях, но&nbsp;та&nbsp;перестала их&nbsp;принимать, потому что занята чем-то другим.</p>
<p>Обратите внимание, что выполнение программы как&nbsp;бы приостанавливается, когда она доходит до&nbsp;команды <code>master.mainloop()</code>, и&nbsp;продолжается только после закрытия окна. Попробуйте предсказать, что произойдет со&nbsp;следующей программой (а&nbsp;потом проверьте свое предположение):</p>
<pre><code class="language-python">import tkinter

master = tkinter.Tk()
master.mainloop()
x = input()
print(x)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="2">Учимся рисовать</h2>
<p>Прежде чем писать программу, по-настоящему взаимодействующую с&nbsp;пользователем, мы&nbsp;научимся рисовать.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Создание холста</strong></p>
<p>Для начала нужно создать холст (canvas), на&nbsp;котором потом будут располагаться картинки. Это действие делает строка:</p>
<pre><code class="language-python">canvas = tkinter.Canvas(master, bg='blue', height=300, width=600)
</code></pre>
</section>
<pre><code class="language-python">import tkinter

master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='blue', height=300, width=600)
canvas.pack()
master.mainloop()
</code></pre>
<p>Попробуйте поменять параметры&nbsp;<var>bg</var> (сокращение для background), <var>height</var> и&nbsp;<var>width</var>. Цвет может быть либо фиксированным названием цвета (white, black, red, green, blue, cyan, yellow, magenta) либо строкой вида &laquo;#RRGGBB&raquo;. RR, GG&nbsp;и&nbsp;BB&nbsp;&mdash; значения красной, синей и&nbsp;зеленой компоненты в&nbsp;диапазоне от&nbsp;0&nbsp;до&nbsp;255, записанные в&nbsp;шестнадцатеричной системе счисления.</p>
<p>Поэкспериментируйте с&nbsp;этим.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Добавление холста в&nbsp;окно</strong></p>
<p>Команда <code>сanvas.pack()</code> добавляет в&nbsp;окно <var>master</var> созданный нами холст&nbsp;&mdash; <var>canvas</var>. То&nbsp;же самое можно сделать командой <code>canvas.grid()</code>, но&nbsp;работают они немного по-разному:</p>
<ul>
<li><code>grid()</code> располагает объекты в&nbsp;ячейках виртуальной сетки, которую мы&nbsp;накладываем на&nbsp;наше окно</li>
<li><code>pack()</code>&nbsp;же пытается их&nbsp;разместить (упаковать) самостоятельно</li>
</ul>
</section>
<p>Посмотрите, что меняется, если заменить <code>canvas.pack()</code> на&nbsp;<code>canvas.grid()</code>.</p>
<p><strong>Тренировочная:</strong> напишите функцию, которая принимает на&nbsp;вход три числа (красную, зеленую и&nbsp;синюю компоненту) и&nbsp;выдает цвет в&nbsp;описанном выше формате.</p>
<p>Ну&nbsp;давайте уже наконец что-то нарисуем:</p>
<pre><code class="language-python">import tkinter

master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='white', height=600, width=600)
canvas.create_line((0, 0), (600, 600), fill='red')
canvas.pack()
master.mainloop()
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Рисование линии</strong></p>
<p>Мы&nbsp;нарисовали линию на&nbsp;холсте, передав команде <var>create_line</var> сначала две&nbsp;пары&nbsp;&mdash; координаты точек, а&nbsp;затем параметр <var>fill</var>&nbsp;&mdash; цвет линии:</p>
<pre><code class="language-python">canvas.create_line((0, 0), (600, 600), fill='red')
</code></pre>
</section>
<p>Команде <var>create_line</var> можно передать больше точек&nbsp;&mdash; тогда получится ломаная:</p>
<pre><code class="language-python">import tkinter

master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='white', height=600, width=600)
canvas.create_line((0, 0), (300, 200), (600, 600),
                   (200, 300), (0, 0), fill='red')
canvas.pack()
master.mainloop()
</code></pre>
<p>Теперь научимся рисовать круг или эллипс:</p>
<pre><code class="language-python">import tkinter

master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='white', height=600, width=600)
canvas.create_oval((0, 0), (100, 100), fill='red')
canvas.create_oval((200, 200), (300, 400), fill='green')
canvas.pack()
master.mainloop()
</code></pre>
<p>Если нужно нарисовать много эллипсов, можно использовать цикл:</p>
<pre><code class="language-python">import tkinter

master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='white', height=600, width=600)
for x in range(0, 600, 20):
    canvas.create_oval((x, x), (x + 20, x + 20), fill='red')
canvas.pack()
master.mainloop()
</code></pre>
<p>В&nbsp;качестве практики найдите в&nbsp;интернете, какие еще команды рисования есть у&nbsp;холста (tkinter.Canvas) и&nbsp;поэкспериментируйте с&nbsp;ними.</p>
</section>
<section class="material__chapter">
<h2 id="3">Взаимодействие с&nbsp;пользователем</h2>
<p>Теперь пришло время научить нашу программу взаимодействовать с&nbsp;пользователем. Для этого нужно связать каждое его действие с&nbsp;функцией, которая будет реагировать на&nbsp;действия. Это делается с&nbsp;помощью команды <var>bind</var>.</p>
<p>Эта команда получает в&nbsp;качестве входных данных название произошедшего события и&nbsp;функцию, которую нужно выполнить, когда событие происходит:</p>
<pre><code class="language-python">import tkinter


def draw(event):
    canvas.create_oval((100, 100), (300, 300), fill='red')


master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='blue', height=600, width=600)
canvas.pack()
master.bind("&lt;KeyPress&gt;", draw)
master.mainloop()
</code></pre>
<p>В&nbsp;приведенном примере мы&nbsp;обрабатываем событие KeyPress&nbsp;&mdash; нажатие любой клавиши. Tkinter знает много разных событий, вы&nbsp;можете самостоятельно прочитать про них в&nbsp;документации. Пока&nbsp;же прочие события нам не&nbsp;понадобятся.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Команда <code>master.bind("", draw)</code> означает, что каждый раз, когда пользователь нажимает клавишу, вызывается функция <var>draw</var>. В&nbsp;качестве аргумента этой функции передается переменная <var>event</var>, в&nbsp;которой содержится описание события.</p>
</section>
<p><em>(Вредный совет: теперь вы&nbsp;тоже можете сделать так, чтобы ваша программа зависла и&nbsp;не&nbsp;отвечала. Для этого нужно добавить в&nbsp;обработку события бесконечный цикл.)</em></p>
<p>Обратите внимание, что функция получает на&nbsp;вход <strong>один</strong> аргумент&nbsp;&mdash; <strong>описание события</strong>, которое ее&nbsp;вызывает. В&nbsp;этой переменной хранится вся возможная информация о&nbsp;событии.</p>
<p>В&nbsp;частности, можно узнать, какая клавиша была нажата, и&nbsp;в&nbsp;зависимости от&nbsp;этого закрашивать круг нужным цветом:</p>
<pre><code class="language-python">import tkinter


def draw(event):
    if event.char == 'r':
        canvas.create_oval((100, 100), (300, 300), fill='red')
    if event.char == 'g':
        canvas.create_oval((100, 100), (300, 300), fill='green')
    if event.char == 'b':
        canvas.create_oval((100, 100), (300, 300), fill='blue')


master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='blue', height=600, width=600)
canvas.pack()
master.bind("&lt;KeyPress&gt;", draw)
master.mainloop()
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Нажатие клавиши</strong></p>
<p>На&nbsp;самом деле, информация о&nbsp;том, какая клавиша нажата, хранится сразу в&nbsp;нескольких полях (&laquo;составляющих&raquo; переменной <var>event</var>):</p>
<ul>
<li><var>char</var>&nbsp;&mdash; символ, который появляется при нажатии клавиши. Однако это поле определено не&nbsp;всегда: например, когда вы&nbsp;нажимаете Shift, никакого символа не&nbsp;появляется</li>
<li><var>keysym</var>&nbsp;&mdash; символическое описание нажатой клавиши (например, Return, Shift_L (левый шифт), Alt_R и&nbsp;т.п.)</li>
<li><var>keysym_num</var>&nbsp;&mdash; число, соответствующее этому описанию</li>
<li><var>keycode</var>&nbsp;&mdash; код нажатой клавиши. Клавиши могут иметь одинаковый код, но&nbsp;разный keysym, мы&nbsp;встретимся с&nbsp;таким случаем чуть дальше</li>
</ul>
</section>
<p>Как узнать keysym нужной вам клавиши? Можно посмотреть в&nbsp;интернете, но&nbsp;интереснее написать программу, которая их&nbsp;выводит.</p>
<p>Для этого нам понадобится новый инструмент&nbsp;&mdash; <strong>поле с&nbsp;текстом</strong>. Этот инструмент называется <var>Label</var>:</p>
<pre><code class="language-python">import tkinter

master = tkinter.Tk()
label = tkinter.Label(master, text="Hello world!")
label.pack()
master.mainloop()
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Label</strong></p>
<p>Для того чтобы поменять текст на&nbsp;уже существующем <var>Label</var>, надо воспользоваться функцией <var>config</var>, передав ей&nbsp;параметр <var>text</var>:</p>
<pre><code class="language-python">label.config(text="Новый текст")
</code></pre>
</section>
<p>Давайте напишем программу, которая выводит значение keysym для нажатой клавиши:</p>
<pre><code class="language-python">import tkinter


def show_key(event):
    label.config(text=event.keysym)


master = tkinter.Tk()
label = tkinter.Label(master, text="Hello world!")
label.pack()
master.bind("&lt;KeyPress&gt;", show_key)
master.mainloop()
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Виджеты</strong></p>
<p>Label&nbsp;&mdash; еще один инструмент отображения данных в&nbsp;tkinter. В&nbsp;общем такие инструменты принято называть <strong>виджетами</strong> (widgets). Их&nbsp;можно комбинировать в&nbsp;одном окне.</p>
</section>
<pre><code class="language-python">import tkinter


def key_pressed(event):
    label.config(text=event.keysym)
    canvas.create_oval((100, 100), (300, 300), fill='green')


master = tkinter.Tk()
label = tkinter.Label(master, text="Hello world!")
label.pack()
canvas = tkinter.Canvas(master, bg='blue', height=600, width=600)
canvas.pack()
master.bind("&lt;KeyPress&gt;", key_pressed)
master.mainloop()
</code></pre>
</section>
<section class="material__chapter">
<h2 id="4">Движение объектов</h2>
<p>Теперь напишем простую игру. Для начала давайте научимся <strong>двигать</strong> объекты.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Важная особенность холста (Canvas) в&nbsp;tkinter заключается в&nbsp;том, что нарисованный объект всегда остается монолитным&nbsp;&mdash; с&nbsp;ним можно выполнять разные операции, не&nbsp;затрагивая при этом другие объекты.</p>
<p>Все функции вида<code> canvas.create_[что угодно]</code> возвращают целое число&nbsp;&mdash; <strong>идентификатор</strong> объекта на&nbsp;холсте. Зная это число, можно, например, двигать объект.</p>
</section>
<p>В&nbsp;следующем примере при нажатии на&nbsp;любую клавишу кружочек сдвинет вправо и&nbsp;вниз на&nbsp;10&nbsp;позиций&nbsp;&mdash; пикселей.</p>
<pre><code class="language-python">import tkinter


def key_pressed(event):
    canvas.move(oval, 10, 10)


master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='blue', height=600, width=600)
oval = canvas.create_oval((300, 300), (310, 310), fill='red')
canvas.pack()
master.bind("&lt;KeyPress&gt;", key_pressed)
master.mainloop()
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Движение объекта</strong></p>
<p>Чтобы передвинуть объект, нужно передать функции <code>canvas.move</code> идентификатор объекта и&nbsp;два числа: изменение координаты x&nbsp;и&nbsp;изменение координаты&nbsp;y.</p>
<p>Обратите внимание на&nbsp;особенность координатной сетки экрана монитора: начало координат располагается в&nbsp;верхнем левом углу экрана. Ось Х&nbsp;направлена слева направо, ось Y&nbsp;&mdash; сверху вниз.</p>
</section>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/tkinter/tkinter-1.svg" width="680" height="auto" /></div>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Объекты можно не&nbsp;только двигать, но&nbsp;и&nbsp;произвольно менять их&nbsp;положения и&nbsp;свойства. Для этого нам помогут следующие функции:</p>
<ul>
<li><code>canvas.coords(object)</code>&nbsp;&mdash; узнать координаты объекта (для овала это будет четверка координат, для линии&nbsp;&mdash; все координаты, с&nbsp;которыми она создавалась)</li>
<li><code>canvas.coords(object, new_coordinates)</code>&nbsp;&mdash; задать объекту новые координаты</li>
<li><code>canvas.itemconfig(object, ...)</code>&nbsp;&mdash; задать любые свойства объекта. Например, canvas.itemconfig(object, fill='red') &mdash; изменить цвет объекта на&nbsp;красный</li>
</ul>
</section>
<p>Например:</p>
<pre><code class="language-python">import tkinter


def key_pressed(event):
    if event.keysym == 'space':
        canvas.coords(oval, (300, 300, 310, 310))
    if event.keysym == 'Up':
        canvas.move(oval, 0, -10)
    if canvas.coords(oval)[1] &lt; 50:
        canvas.itemconfig(oval, fill='red')


master = tkinter.Tk()
canvas = tkinter.Canvas(master, bg='blue', height=600, width=600)
oval = canvas.create_oval((300, 300), (310, 310), fill='green')
canvas.pack()
master.bind("&lt;KeyPress&gt;", key_pressed)
master.mainloop()
</code></pre>
</section>
<section class="material__chapter">
<h2 id="5">Приступаем к&nbsp;игре</h2>
<p>Теперь приступим к&nbsp;игре. Игрок в&nbsp;ней ходит по&nbsp;сетке размером N_X&nbsp;на N_Y с&nbsp;шагом step. Ему нужно добраться до&nbsp;выхода, причем начальное положение игрока и&nbsp;выхода определяется случайно.</p>
<p>Шаблон программы у&nbsp;нас уже есть:</p>
<pre><code class="language-python">import tkinter
import random


def move_wrap(obj, move):
    canvas.move(obj, move[0], move[1])
    # Здесь нужно сделать так, чтобы ушедший
    # "за экран" игрок выходил с другой стороны


def check_move():
    if canvas.coords(player) == canvas.coords(exit):
        label.config(text="Победа!")


def key_pressed(event):
    if event.keysym == 'Up':
        move_wrap(player, (0, -step))
    # Здесь нужно дописать то, что нужно,
    # чтобы все остальные клавиши работали
    check_move()


master = tkinter.Tk()

step = 60
N_X = 10
N_Y = 10
canvas = tkinter.Canvas(master, bg='blue',
                        width=step * N_X, height=step * N_Y)

player_pos = (random.randint(0, N_X - 1) * step,
              random.randint(0, N_Y - 1) * step)
exit_pos = (random.randint(0, N_X - 1) * step,
            random.randint(0, N_Y - 1) * step)

player = canvas.create_oval((player_pos[0], player_pos[1]),
                            (player_pos[0] + step, player_pos[1] + step), 
                            fill='green')
exit = canvas.create_oval((exit_pos[0], exit_pos[1]),
                          (exit_pos[0] + step, exit_pos[1] + step), 
                          fill='yellow')

label = tkinter.Label(master, text="Найди выход")
label.pack()
canvas.pack()
master.bind("&lt;KeyPress&gt;", key_pressed)
master.mainloop()
</code></pre>
<p>Пока есть одна проблема: когда игрок находит выход, ничего не&nbsp;происходит. Он&nbsp;может гулять и&nbsp;дальше. Чтобы исправить это, можно связать с&nbsp;событием какую-нибудь другую функцию. Пусть эта функция ничего не&nbsp;делает. Определим ее&nbsp;и&nbsp;добавим в&nbsp;функцию <var>check_move</var> одну строчку:</p>
<pre><code class="language-python">def do_nothing(x):
    pass


def check_move():
    if canvas.coords(player) == canvas.coords(exit):
        label.config(text="Победа!")
        master.bind("&lt;KeyPress&gt;", do_nothing)
</code></pre>
<p>Обратите внимание, что функция <var>do_nothing</var> принимает на&nbsp;вход один аргумент. Функции, которые используются в&nbsp;команде <var>bind</var>, тоже всегда получают на&nbsp;вход один аргумент&nbsp;&mdash; описание события. Если&nbsp;бы мы&nbsp;определили функцию <code>do_nothing()</code> без параметров, то&nbsp;в&nbsp;процессе выполнения программы получили&nbsp;бы ошибку.</p>
<p>Теперь, попадая к&nbsp;выходу, игрок <strong>теряет управление</strong>, и&nbsp;нам остается только закрыть окно. Наверное, стоит добавить кнопку, которая позволит ему начать сначала.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Создание кнопки</strong></p>
<p>Кнопка создается командой <code>tkinter.Button(...)</code></p>
<p>В&nbsp;качестве параметров ей&nbsp;нужно передать <strong>окно</strong>, в&nbsp;котором будет создаваться кнопка; <strong>текст</strong>, который будет написан на&nbsp;кнопке и&nbsp;<strong>функцию</strong>, которая вызывается при ее&nbsp;нажатии.</p>
</section>
<p>Например так:</p>
<pre><code class="language-python">restart = tkinter.Button(master, text="Начать заново",
                         command=prepare_and_start)
restart.pack()
</code></pre>
<p>Теперь стоит перенести в&nbsp;отдельную функцию код, подготавливающий игровое поле:</p>
<pre><code class="language-python">def prepare_and_start():
    global player, exit
    player_pos = (random.randint(1, N_X - 1) * step,
                  random.randint(1, N_Y - 1) * step)
    exit_pos = (random.randint(1, N_X - 1) * step,
                random.randint(1, N_Y - 1) * step)
    player = canvas.create_oval(
        (player_pos[0], player_pos[1]), 
        (player_pos[0] + step, player_pos[1] + step), 
        fill='green')
    exit = canvas.create_oval(
        (exit_pos[0], exit_pos[1]), 
        (exit_pos[0] + step, exit_pos[1] + step), 
        fill='yellow')
    label.config(text="Найди выход!")
    master.bind("&lt;KeyPress&gt;", key_pressed)
</code></pre>
<p>Обратите внимание на&nbsp;строчку <code>global...</code>. Скоро мы&nbsp;узнаем, что это&nbsp;&mdash; глобальные переменные. Мы&nbsp;столкнемся с&nbsp;ними и&nbsp;поговорим о&nbsp;том, что использовать их&nbsp;надо <em>c&nbsp;умом</em>.</p>
<p>Однако в&nbsp;нашем случае без глобальных переменных трудно обойтись: информацию об&nbsp;игроке, выходе, холсте и&nbsp;т.д. пришлось&nbsp;бы передавать во&nbsp;все функции в&nbsp;качестве параметров. Это неудобно, а&nbsp;иногда и&nbsp;вовсе невозможно.</p>
<p>Например, команда <var>bind</var> работает с&nbsp;функциями, получающими ровно один аргумент&nbsp;&mdash; событие.</p>
<p>Поскольку наша программа невелика, мы&nbsp;решим эту проблему за&nbsp;счет глобальных переменных.</p>
<p>В&nbsp;реальных (больших) программах для этого используют классы, с&nbsp;которыми вы&nbsp;познакомитесь немного позже.</p>
<p>Основной код нашей программы теперь выглядит так:</p>
<pre><code class="language-python">step = 60  # Размер клетки
N_X = 10
N_Y = 10   # Размер сетки
master = tkinter.Tk()
label = tkinter.Label(master, text="Найди выход")
label.pack()
canvas = tkinter.Canvas(master, bg='blue', 
                        height=N_X * step, width=N_Y * step)
canvas.pack()
restart = tkinter.Button(master, text="Начать заново",
                         command=prepare_and_start)
restart.pack()
prepare_and_start()
master.mainloop()
</code></pre>
<p>При попытке запустить новую программу вы&nbsp;сразу столкнетесь с&nbsp;новой проблемой: после нажатия <strong>Начать заново</strong> игрок и&nbsp;&laquo;выход&raquo; не&nbsp;исчезают. Нужно добавить в&nbsp;функцию <var>prepare_and_start</var> удаление всех старых объектов. К&nbsp;счастью, это можно сделать одной командой: <code>canvas.delete("all")</code>. Добавьте ее&nbsp;в&nbsp;вашу программу.</p>
<p>В&nbsp;нашу игру уже можно играть, но&nbsp;игроку чересчур легко живется: он&nbsp;даже проиграть не&nbsp;может! Давайте добавим препятствия: например, огонь, в&nbsp;который нельзя наступать.</p>
<p>Для этого придется переписать функцию <var>prepare_and_start</var>:</p>
<pre><code class="language-python">def prepare_and_start():
    global player, exit, fires
    canvas.delete("all")    
    player_pos = (random.randint(1, N_X - 1) * step,
                  random.randint(1, N_Y - 1) * step)
    exit_pos = (random.randint(1, N_X - 1) * step,
                random.randint(1, N_Y) * step)
    player = canvas.create_oval(
        (player_pos[0], player_pos[1]), 
        (player_pos[0] + step, player_pos[1] + step), 
        fill='green')
    exit = canvas.create_oval(
        (exit_pos[0], exit_pos[1]), 
        (exit_pos[0] + step, exit_pos[1] + step), 
        fill='yellow')
    N_FIRES = 6  # Число клеток, заполненных огнем
    fires = []
    for i in range(N_FIRES):
        fire_pos = (random.randint(1, N_X - 1) * step,
                    random.randint(1, N_Y - 1) * step)
        fire = canvas.create_oval(
            (fire_pos[0], fire_pos[1]), 
            (fire_pos[0] + step, fire_pos[1] + step), 
            fill='red')
        fires.append(fire)
    label.config(text="Найди выход!")
    master.bind("&lt;KeyPress&gt;", key_pressed)
</code></pre>
<p>И&nbsp;функцию, проверяющую результат хода:</p>
<pre><code class="language-python">def check_move():
    if canvas.coords(player) == canvas.coords(exit):
        label.config(text="Победа!")
        master.bind("&lt;KeyPress&gt;", do_nothing)
    for f in fires:
        if canvas.coords(player) == canvas.coords(f):
            label.config(text="Ты проиграл!")
            master.bind("&lt;KeyPress&gt;", do_nothing)
</code></pre>
<p>Игра уже почти как настоящая. Осталось два штриха:</p>
<ol>
<li>Улучшить графику и</li>
<li>Добавить еще врагов</li>
</ol>
<section class="material__note">
<p class="material__note-heading"><strong>Добавление графики</strong></p>
<p>На&nbsp;холст (Canvas) можно добавить любую картинку. В&nbsp;зависимости от&nbsp;типа изображения код будет немного варьироваться, мы&nbsp;будем рассматривать работу с&nbsp;изображениями в&nbsp;формате gif. Сначала картинку нужно загрузить с&nbsp;помощью функции <code>tkinter.PhotoImage</code>, а&nbsp;затем создать на&nbsp;холсте:</p>
<pre><code class="language-python">player_pic = tkinter.PhotoImage(file="doctor.gif")
player = canvas.create_image((player_pos[0], player_pos[1]), 
                             image=player_pic, anchor='nw')
</code></pre>
<p>Параметр <code>anchor='nw'</code> означает, что в&nbsp;указанную первым параметром координату помещается левый верхний (буквально&nbsp;&mdash; северо-западный, по-английски&nbsp;&mdash; north-west) угол картинки. Если этот параметр не&nbsp;указать, то&nbsp;картинка будет центрирована по&nbsp;заданной координате. Можно добавить картинки для всех объектов в&nbsp;основную часть кода и&nbsp;в&nbsp;функцию <code>prepare_and_start()</code>.</p>
</section>
<p>В&nbsp;основную часть кода:</p>
<pre><code class="language-python">player_pic = tkinter.PhotoImage(file="images/doctor.gif")
exit_pic = tkinter.PhotoImage(file="images/tardis.gif")
fire_pic = tkinter.PhotoImage(file="images/fire.gif")
enemy_pic = tkinter.PhotoImage(file="images/dalek.gif")
</code></pre>
<p>И&nbsp;в&nbsp;функцию <var>prepare_and_start</var>:</p>
<pre><code class="language-python">def prepare_and_start():
    global player, exit, fires
    canvas.delete("all")
    player_pos = (random.randint(1, N_X - 1) * step,
                  random.randint(1, N_Y - 1) * step)
    player = canvas.create_image(
        (player_pos[0], player_pos[1]), image=player_pic, anchor='nw')
    exit_pos = (random.randint(1, N_X - 1) * step,
                random.randint(1, N_Y - 1) * step)
    exit = canvas.create_image(
        (exit_pos[0], exit_pos[1]), image=exit_pic, anchor='nw')
    N_FIRES = 6  # Число клеток, заполненных огнем
    fires = []
    for i in range(N_FIRES):
        fire_pos = (random.randint(1, N_X - 1) * step,
                    random.randint(1, N_Y - 1) * step)
        # fire = canvas.create_oval((fire_pos[0],fire_pos[1]), 
        # (fire_pos[0] + step, fire_pos[1] + step), fill='red')
        fire = canvas.create_image(
            (fire_pos[0], fire_pos[1]), image=fire_pic, anchor='nw')
        fires.append(fire)
    label.config(text="Найди выход!")
    master.bind("&lt;KeyPress&gt;", key_pressed)
</code></pre>
<p>Картинки можно выбрать свои&nbsp;&mdash; они должны быть в&nbsp;формате gif и&nbsp;иметь размер step*step пикселей. Желательно так&nbsp;же делать их&nbsp;на&nbsp;прозрачном фоне.</p>
<p>Ну&nbsp;и&nbsp;последний штрих. Добавим настоящих врагов, которые тоже могут двигаться. Создадим их&nbsp;в&nbsp;функции <code>prepare_and_start()</code>, немного модифицировав последнюю:</p>
<pre><code class="language-python">def prepare_and_start():
    global player, exit, fires, enemies
    canvas.delete("all")
    player_pos = (random.randint(0, N_X - 1) * step,
                  random.randint(0, N_Y - 1) * step)
    player = canvas.create_image(player_pos, image=player_pic, anchor='nw')
    exit_pos = (random.randint(0, N_X - 1) * step, 
                random.randint(0, N_Y - 1) * step)
    exit = canvas.create_image(exit_pos, image=exit_pic, anchor='nw')
    N_FIRES = 6 #Число клеток, заполненных огнем
    fires = []
    for i in range(N_FIRES):
        fire_pos = (random.randint(0, N_X - 1) * step, 
                    random.randint(0, N_Y - 1) * step)
        fire = canvas.create_image(fire_pos, image=fire_pic, anchor='nw')
        fires.append(fire)
    N_ENEMIES = 4 #Число врагов
    enemies = []
    for i in range(N_ENEMIES):
        enemy_pos = (random.randint(0, N_X - 1) * step, 
                     random.randint(0, N_Y - 1) * step)
        enemy = canvas.create_image(enemy_pos, image=enemy_pic, anchor='nw')
        enemies.append((enemy, random.choice([always_right, random_move])))
    label.config(text="Найди выход!")
    master.bind("&lt;KeyPress&gt;", key_pressed)
</code></pre>
<p>Каждый враг в&nbsp;нашей программе будет представлен парой (объект на&nbsp;Canvas + функция движения). Определим для начала две таких функции:</p>
<pre><code class="language-python">def always_right():
    return (step, 0)


def random_move():
    return random.choice([(step, 0), (-step, 0), (0, step), (0, -step)])
</code></pre>
<p>Модифицируем функцию <var>key_pressed</var>: ее&nbsp;нужно дополнить перемещением врагов&nbsp;&mdash; вот таким фрагментом кода:</p>
<pre><code class="language-python">for enemy in enemies:
    direction = enemy[1]() # вызвать функцию перемещения у "врага"
    move_wrap(enemy[0], direction) # произвести  перемещение
</code></pre>
<p>Кроме того, нужно переписать функцию <var>check_move</var>:</p>
<pre><code class="language-python">def check_move():
    if canvas.coords(player) == canvas.coords(exit):
        label.config(text="Победа!")
        master.bind("&lt;KeyPress&gt;", do_nothing)
    for f in fires:
        if canvas.coords(player) == canvas.coords(f):
            label.config(text="Ты проиграл!")
            master.bind("&lt;KeyPress&gt;", do_nothing)
    for e in enemies:
        if canvas.coords(player) == canvas.coords(e[0]):
            label.config(text="Ты проиграл!")
            master.bind("&lt;KeyPress&gt;", do_nothing)
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>