<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Функции как объект. Лямбда-функции </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Лямбда-функции</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Функции как объект. Лямбда-функции</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Функция как объект</a></li>
<li><a class="material__link" href="#2">Функции высшего порядка. Функция filter</a></li>
<li><a class="material__link" href="#3">Лямбда-функции</a></li>
<li><a class="material__link" href="#4">Функция map</a></li>
<li><a class="material__link" href="#5">Еще немного о&nbsp;списочных выражениях</a></li>
<li><a class="material__link" href="#6">Комбинирование функций</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;языке Python все является объектом. Даже функция. Вы&nbsp;узнаете, как получить и&nbsp;использовать соответствующий объект. Кроме того, вы&nbsp;научитесь создавать и&nbsp;использовать крошечные, буквально в&nbsp;полстроки функции и&nbsp;передавать их&nbsp;в&nbsp;качестве аргумента другой функции. Вы&nbsp;узнаете о&nbsp;двух важных функциях: <var>filter</var> и&nbsp;<var>map</var>, которые позволяют проводить множество преобразований над коллекциями и&nbsp;другими наборами объектов. Заодно мы&nbsp;вспомним списочные выражения и&nbsp;расширим знания о&nbsp;них.</p>
</section>
<section class="material__chapter">
<h2 id="1">Функция как объект</h2>
<p>До&nbsp;сих пор мы&nbsp;рассматривали функции как совершенно отдельный элемент языка со&nbsp;своим синтаксисом и&nbsp;механизмами работы. Но, оказывается, функция&nbsp;&mdash; что-то вроде особого типа объектов. Бывают числа, бывают строки, бывают списки. А&nbsp;бывают&nbsp;&mdash; функции. У&nbsp;каждого из&nbsp;этих типов есть свои операции, свой синтаксис, но&nbsp;все они являются объектами. Например, есть объект, который умеет печатать текст на&nbsp;экране. У&nbsp;него есть имя <var>print</var>. Можно считать, что <var>print</var>&nbsp;&mdash; это что-то вроде имени переменной, которая хранит объект функции. Давайте посмотрим, насколько далеко идет эта аналогия.</p>
<p>Первым делом, давайте получим объект функции. Для этого достаточно написать имя функции без скобок. Это аналогично тому, что происходит со&nbsp;списками или строками: если вы&nbsp;пишете после имени списка квадратные скобки c&nbsp;индексом&nbsp;&mdash; выполняется операция взятия элемента, не&nbsp;пишете скобки&nbsp;&mdash; получаете сам список. Пишете после функции круглые скобки с&nbsp;аргументами&nbsp;&mdash; она вызывается, не&nbsp;пишете&nbsp;&mdash; получаете саму функцию как объект.</p>
<p><var>input</var>&nbsp;&mdash; объект функции чтения из&nbsp;стандартного ввода. Давайте мы&nbsp;этот объект напечатаем:</p>
<pre><code class="language-python">print(input)
</code></pre>
<p>Python выдает нам текстовое представление этой функции: строку <code>built-in function input</code>, которая поясняет, что <var>input</var>&nbsp;&mdash; встроенная функция языка.</p>
<p><strong>Вопросы для самопроверки:</strong></p>
<ul>
<li>Что сделает <code>print(input())</code> и&nbsp;почему это отличается от&nbsp;<code>print(input)</code>?</li>
<li>Как вывести на&nbsp;экран функцию печати?</li>
</ul>
<p>Раз мы&nbsp;можем получить какой-то объект, мы&nbsp;его можем записать в&nbsp;переменную. Давайте попробуем!</p>
<pre><code class="language-python">vyvod = print
</code></pre>
<p>Это сработало. Теперь у&nbsp;функции <var>print</var> есть псевдоним на&nbsp;транслите. Эту новую переменную можно вызвать, как и&nbsp;обычную функцию, посредством круглых скобок:</p>
<pre><code class="language-python">vyvod('Privet mir!')
</code></pre>
<p>Возможность записать функцию в&nbsp;переменную позволяет нам гибко управлять тем, какую функциональность мы&nbsp;хотим использовать. В&nbsp;одну и&nbsp;ту&nbsp;же переменную мы&nbsp;можем записать разные варианты поведения и&nbsp;менять их&nbsp;при необходимости. При этом нам не&nbsp;только не&nbsp;нужно будет менять код по&nbsp;всей программе, но&nbsp;не&nbsp;придется даже изменять код функций. Достаточно переменной присвоить вместо одной функции&nbsp;&mdash; другую.</p>
<p>Напишем программу, которая печатает списки либо просто через запятую, либо в&nbsp;&laquo;коробочках&raquo;, в&nbsp;зависимости от&nbsp;значения переменной <var>formatting</var>.</p>
<pre><code class="language-python">def print_boxed(arr):
    arr_stringified = [str(element) for element in arr]
    mid = ' | '.join(arr_stringified)
    bar = '-' * (2 + len(mid))
    print(' ' + bar + ' ')
    print('| ' + mid + ' |')
    print(' ' + bar + ' ')


def print_simple(arr):
    arr_stringified = [str(element) for element in arr]
    print(', '.join(arr_stringified))


formatting = 'boxed'
if formatting == 'boxed':
    print_formatted = print_boxed
else:
    print_formatted = print_simple

# Дальше в программе можно использовать print_formatted повсюду
print_formatted([1,1,2,3,5,8,13,21])
print_formatted([1,2,4,8,16,32,64,128])
print_formatted(['abc', 'def', 'ghi'])
</code></pre>
<p>Вывод программы:</p>
<pre><samp>--------------------------------- 
| 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 |
 --------------------------------- 
 ------------------------------------ 
| 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 |
 ------------------------------------ 
 ----------------- 
| abc | def | ghi |
 -----------------</samp></pre>
<p>Мы&nbsp;один раз проверили условие и&nbsp;указали, как должна вести себя функция <var>print_formatted</var> во&nbsp;всей программе.</p>
</section>
<section class="material__chapter">
<h2 id="2">Функции высшего порядка. Функция filter</h2>
<section class="material__note">
<p class="material__note-heading"><strong>Функции высшего порядка</strong></p>
<p>Объект функции можно не&nbsp;только записать в&nbsp;переменную, но&nbsp;и&nbsp;передать в&nbsp;качестве аргумента в&nbsp;другую функцию и&nbsp;даже вернуть из&nbsp;функции.</p>
<p>Функции, которые принимают или возвращают другие функции, называются <strong>функциями высшего порядка</strong>.</p>
</section>
<p>Часто функции высшего порядка используются для обработки наборов данных. Например, из&nbsp;раза в&nbsp;раз встречается такая задача: взять список элементов и&nbsp;оставить среди них только небольшую часть, согласно какому-то критерию.</p>
<p>Эту задачу можно встретить в&nbsp;самых разных формах. В&nbsp;списке товаров найти только дешевые. Отобрать все слова, в&nbsp;которых ровно три слога, для генератора рифм. Найти среди кораблей в&nbsp;игре &laquo;Морской бой&raquo; все подбитые.</p>
<p>Это разные списки и&nbsp;разные критерии, а&nbsp;задача одна и&nbsp;та&nbsp;же&nbsp;&mdash; отфильтровать элементы списка. В&nbsp;языке Python для этой цели есть встроенная функция <var>filter</var>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функция filter</strong></p>
<p>Функция <var>filter</var> принимает критерий отбора элементов, а&nbsp;затем сам список элементов. Возвращает она список из&nbsp;элементов, удовлетворяющих критерию.</p>
</section>
<p>Чтобы этой функцией воспользоваться, нужно сообщить функции <var>filter</var> критерий, который говорит, брать элемент в&nbsp;результирующий список или нет. Давайте напишем простую функцию, которая проверяет, что слово длиннее шести букв, и&nbsp;затем отберем с&nbsp;ее&nbsp;помощью длинные слова.</p>
<pre><code class="language-python">def is_word_long(word):
    return len(word) &gt; 6


words = ['В', 'новом', 'списке', 'останутся', 'только', 'длинные', 'слова']
for word in filter(is_word_long, words):
    print(word)
# =&gt; останутся
# =&gt; длинные
</code></pre>
<p>С&nbsp;методом <var>filter</var> вам не&nbsp;нужно вручную создавать и&nbsp;заполнять список, достаточно указать условие отбора.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Итераторы</strong></p>
<p>Если вы&nbsp;попробуете распечатать результат функции <var>filter</var> при помощи функции <var>print</var> (а&nbsp;не&nbsp;перебирая элементы по&nbsp;одному в&nbsp;цикле <var>for</var>), удивитесь: будет выведен не&nbsp;список, а&nbsp;специальный объект <code>"&lt;filter object at 0x...&gt;"</code>.</p>
<p>Он&nbsp;похож на&nbsp;список тем, что его можно перебирать циклом <var>for</var>, т.&nbsp;е. итерировать. Такие объекты называют <strong>итераторами</strong>.</p>
</section>
<p>Чтобы получить из&nbsp;итератора список, можно воспользоваться функцией <var>list</var>:</p>
<pre><code class="language-python">long_words = list(filter(isWordLong, words))
</code></pre>
<p>Описанный способ отфильтровать список пока далек от&nbsp;удобного, поскольку нам приходится заводить функцию для каждой проверки, что занимает две лишних строки кода. Для каждой такой маленькой функции приходится придумывать имя (и&nbsp;загромождать пространство имен).</p>
<p>Для того чтобы создавать такие короткие функции, &laquo;на&nbsp;один раз&raquo;, в&nbsp;языке Python есть специальный синтаксис.</p>
</section>
<section class="material__chapter">
<h2 id="3">Лямбда-функции</h2>
<p>Часто в&nbsp;качестве аргумента для функций высшего порядка мы&nbsp;хотим использовать совсем простую функцию. Причем нередко такая функция нужна в&nbsp;программе только в&nbsp;одном месте, поэтому ей&nbsp;необязательно даже иметь имя.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Лямбда-функции</strong></p>
<p>Такие короткие безымянные (анонимные) функции можно создавать инструкцией <code>lambda &lt;аргументы&gt;: &lt;выражение&gt;</code>.</p>
<p>Такая инструкция создаст функцию, принимающую указанный список аргументов и&nbsp;возвращающую результат вычисления выражения.</p>
<p>В&nbsp;языке Python тело лямбда-функции имеет ровно одно выражение. Инструкция <var>return</var> подразумевается, писать ее&nbsp;не&nbsp;требуется, да&nbsp;и&nbsp;нельзя. Скобки вокруг аргументов не&nbsp;пишутся, аргументы от&nbsp;выражения отделяет двоеточие.</p>
</section>
<p>Теперь мы&nbsp;можем записать функцию, проверяющую длину слова, следующим образом:</p>
<pre><code class="language-python">lambda word: len(word) &gt; 6
</code></pre>
<p>И&nbsp;список длинных слов теперь извлечь очень просто:</p>
<pre><code class="language-python">long_words = list(filter(lambda word: len(word) &gt; 6, words))
</code></pre>
<p>Лямбда-функция&nbsp;&mdash; полноценная функция. Ее&nbsp;можно использовать в&nbsp;составе любых конструкций. Например, если вы&nbsp;хотите использовать ее&nbsp;несколько раз, но&nbsp;не&nbsp;хотите определять функцию с&nbsp;помощью <var>def</var>, вы&nbsp;можете присвоить созданную лямбда-функцию какой-либо переменной.</p>
<pre><code class="language-python">add = lambda x, y: x + y
add(3, 5) # =&gt; 8
add(1, add(2, 3)) # =&gt; 6
</code></pre>
<p>А&nbsp;теперь рассмотрим вариант, что вам нужно взять все элементы списка, но&nbsp;в&nbsp;программе уже стоит <var>filter</var> и&nbsp;вам не&nbsp;хочется его удалять. В&nbsp;этой ситуации вам поможет функция с&nbsp;особенно простым выражением:</p>
<pre><code class="language-python">lambda x: True
</code></pre>
<p>Покажем:</p>
<pre><code class="language-python">def print_some_primes(criterion):
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    for number in filter(criterion, primes):
        print(number)


print_some_primes(lambda x: True)
# =&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Лямбда-функция принимает аргумент, хотя и&nbsp;не&nbsp;использует его. Функция <var>filter</var> всегда передает в&nbsp;критерий элемент, который проверяет. Если&nbsp;бы мы&nbsp;написали лямбда-функцию без аргументов <code>lambda: True</code>, функция <var>filter</var> вызвала&nbsp;бы ошибку, потому что передала&nbsp;бы аргумент в&nbsp;функцию, которая аргументов не&nbsp;принимает.</p>
</section>
<p>Чтобы функция <var>filter</var> не&nbsp;казалась магической, напишем свой упрощенный аналог. Наша функция <var>simple_filter</var> будет принимать критерий и&nbsp;список и&nbsp;возвращать новый список.</p>
<pre><code class="language-python">def simple_filter(criterion, arr):
    result = []
    for element in arr:
        if criterion(element):
            result.append(element)
    return result
</code></pre>
<p>Мы&nbsp;передали критерий как функцию, а&nbsp;потому можем его вызвать, что мы&nbsp;и&nbsp;сделали в&nbsp;условном операторе. Так как для перечисления элементов мы&nbsp;использовали конструкцию <var>for</var>, мы&nbsp;можем вместо списка в&nbsp;функцию передать любой итерируемый объект. Например, строку (элементами будут отдельные символы) или интервал <var>range</var>.</p>
<p>Например, найдем все числа от&nbsp;1&nbsp;до&nbsp;99, которые при делении на&nbsp;12&nbsp;дают 7&nbsp;в остатке.</p>
<pre><code class="language-python">simple_filter(lambda x: x % 12 == 7, range(1, 100))
# =&gt; [7, 19, 31, 43, 55, 67, 79, 91]
</code></pre>
</section>
<section class="material__chapter">
<h2 id="4">Функция map</h2>
<p>Другая популярная функция высшего порядка называется <var>map</var>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функция map</strong></p>
<p>Функция <var>map</var> преобразует каждый элемент списка по&nbsp;некоторому общему правилу и&nbsp;в&nbsp;результате создает список (вернее, как и&nbsp;<var>filter</var>, специальный итерируемый объект, похожий на&nbsp;список) из&nbsp;преобразованных значений.</p>
</section>
<p>Функция, которую <var>map</var> принимает,&nbsp;&mdash; преобразование одного элемента. Зная, как преобразуется один элемент, <var>map</var> выполняет превращение целых списков.</p>
<p>Например, возьмем набор из&nbsp;чисел от&nbsp;1&nbsp;до&nbsp;10&nbsp;и&nbsp;применим к&nbsp;ним функцию возведения в&nbsp;квадрат.</p>
<pre><code class="language-python">list(map(lambda x: x ** 2, range(1, 10)))
# =&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
</section>
<section class="material__chapter">
<h2 id="5">Еще немного о&nbsp;списочных выражениях</h2>
<p>В&nbsp;уроке, посвященном списочным выражениям, вы&nbsp;разбирали конструкции, которые очень похожи на&nbsp;действие функции <var>map</var>. Например, список квадратов цифр можно посчитать так:</p>
<pre><code class="language-python">[x ** 2 for x in range(10)]
# =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Оказывается, для фильтрации списка тоже есть специальный вид списочного выражения: достаточно приписать&nbsp;<code>if &lt;условие&gt;</code> в&nbsp;конце выражения. Такая конструкция отберет только те&nbsp;элементы, которые удовлетворяют условию.</p>
</section>
<p>Например, сгенерируем список четных цифр, не&nbsp;делящихся на&nbsp;3:</p>
<pre><code class="language-python">[x for x in range(10) if x % 2 == 0 and x % 3 != 0]
# =&gt; [2, 4, 8]
</code></pre>
<p>Списочное выражение можно рассматривать как комбинацию фильтрации и&nbsp;трансформации: сначала выполняется фильтрация, затем&nbsp;&mdash; трансформирование. Давайте, например, возьмем список слов, оставим только длинные слова и&nbsp;преобразуем их&nbsp;в&nbsp;слова, написанные большими буквами:</p>
<pre><code class="language-python">words = ['В', 'новом', 'списке', 'останутся', 'только', 'длинные', 'слова']
long_words = list(map(lambda word: word.upper(),
                      filter(lambda word: len(word) &gt; 6, words)))
# =&gt; ['ОСТАНУТСЯ', 'ДЛИННЫЕ']
# или
long_words = [word.upper() for word in words if len(word) &gt; 6]
# =&gt; ['ОСТАНУТСЯ', 'ДЛИННЫЕ']
</code></pre>
<p>Как видите, оба способа позволяют добиться результата, но&nbsp;списочные выражения выглядят немного проще. В&nbsp;зависимости от&nbsp;ситуации, бывает удобно использовать либо одну форму, либо другую.</p>
</section>
<section class="material__chapter">
<h2 id="6">Комбинирование функций</h2>
<p>Посмотрим, как функции высшего порядка комбинируются для решения более сложных задач. Разберем, как можно было&nbsp;бы при помощи этих функций решить задачу &laquo;Длинношеее&raquo; из&nbsp;дополнительных задач к&nbsp;уроку по&nbsp;теме &laquo;Функции&raquo;.</p>
<p>Напомним, что нам нужно найти слова, имеющие четыре слога и&nbsp;более. Мы&nbsp;можем разбить эту задачу на&nbsp;такие этапы: выделить список слов, посчитать число гласных букв и&nbsp;в&nbsp;зависимости от&nbsp;их&nbsp;числа взять слово или отбросить. Перед тем как выделять слова мы&nbsp;еще дополнительно отбросим пунктуацию. Каждый этап обернем в&nbsp;одну небольшую функцию.</p>
<pre><code class="language-python">ENGLISH_ALPHABET = set([chr(c) for c in range(ord('a'), ord('z') + 1)])
RUSSIAN_ALPHABET = set([chr(c) for c in range(ord('а'), ord('я') + 1)] 
                       + ['ё'])
ALPHABET = ENGLISH_ALPHABET ^ RUSSIAN_ALPHABET

ENGLISH_VOWELS = {'a', 'e', 'i', 'o', 'u', 'y'}
RUSSIAN_VOWELS = {'а', 'о', 'э', 'и', 'у', 'ы', 'е', 'ё', 'ю', 'я'}
VOWELS = ENGLISH_VOWELS ^ RUSSIAN_VOWELS


def remove_punctuation(text):
    return ''.join(filter(lambda c: c in ALPHABET ^ {' '}, text))


def get_words(text):
    return remove_punctuation(text).split()


def number_of_vowels(word):
    return len(list(filter(lambda c: c in VOWELS, word)))


def long_words(text):
    return filter(lambda word: number_of_vowels(word) &gt;= 4, get_words(text))


def print_long_words(text):
    for word in long_words(text):
        print(word.lower())
</code></pre>
<p>Функцию <var>filter</var> мы&nbsp;используем трижды:</p>
<ul>
<li>Чтобы оставить только буквы и&nbsp;пробелы</li>
<li>Чтобы выделить в&nbsp;строке только гласные</li>
<li>Чтобы из&nbsp;всех слов отобрать только нужные</li>
</ul>
<p>Функции получились не&nbsp;очень сложные&nbsp;и (что важно) их&nbsp;легко комбинировать друг с&nbsp;другом.</p>
<p>Обратите внимание: не&nbsp;всегда требуется создавать лямбда-функцию при вызове, поскольку иногда нужная функция уже существует. Например, если мы&nbsp;хотим преобразовать список слов в&nbsp;список длин слов, мы&nbsp;можем использовать любой из&nbsp;двух вариантов (но, конечно, удобнее использовать более короткий):</p>
<pre><code class="language-python">words = 'the quick brown fox jumps over the lazy dog'.split()
list(map(lambda word: len(word), words))
# =&gt; [3, 5, 5, 3, 5, 4, 3, 4, 3]
list(map(len, words))
# =&gt; [3, 5, 5, 3, 5, 4, 3, 4, 3]
</code></pre>
<p>Еще один пример&nbsp;&mdash; считывание списка чисел с&nbsp;клавиатуры:</p>
<pre><code class="language-python">numbers = list(map(float, input().split()))
</code></pre>
<p>Аналогично можно использовать в&nbsp;качестве передаваемой функции методы объектов. Но&nbsp;при этом нужно указать не&nbsp;только название метода, но&nbsp;и&nbsp;название типа объекта, к&nbsp;которому эта функция относится. То&nbsp;есть для метода строк это будет <var>str</var>, для списков&nbsp;&mdash; <var>list</var> и&nbsp;т.&nbsp;д. Про методы и&nbsp;типы вы&nbsp;еще будете много говорить на&nbsp;будущих уроках, пока что только простой пример&nbsp;&mdash; преобразовать каждое слово в&nbsp;списке к&nbsp;верхнему регистру:</p>
<pre><code class="language-python">words = ['list', 'of', 'several', 'words']
list(map(lambda word: word.upper(), words))
# =&gt; ['LIST', 'OF', 'SEVERAL', 'WORDS']
list(map(str.upper, words))
# =&gt; ['LIST', 'OF', 'SEVERAL', 'WORDS']
</code></pre>
<p>Существует еще множество полезных функций, которые принимают функцию в&nbsp;качестве аргумента. Оказывается, что даже давно известные вам функции <var>min</var>, <var>max</var>, <var>sort</var> могут принимать функцию одним из&nbsp;аргументов, что изменяет их&nbsp;поведение.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>