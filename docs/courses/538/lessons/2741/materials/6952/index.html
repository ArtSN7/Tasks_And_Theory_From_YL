<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | True и False, break и continue </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок True и False</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>True и&nbsp;false, break и&nbsp;continue</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Логический тип данных</a></li>
<li><a class="material__link" href="#2">Использование флагов</a></li>
<li><a class="material__link" href="#3">Операторы break и&nbsp;continue. Бесконечные циклы</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Этот урок посвящен условиям выхода из&nbsp;циклов. Рассматривается булев тип, даются задачи на&nbsp;использование флагов. Затем рассматриваются операторы <var>break</var> и&nbsp;<var>continue</var>, позволяющие в&nbsp;некоторых случаях избавиться от&nbsp;флагов.</p>
</section>
<section class="material__chapter">
<h2 id="1">Логический тип данных</h2>
<p>Если <var>a</var>&nbsp;и&nbsp;<var>b</var>&nbsp;&mdash; числа (допустим, действительные), то&nbsp;у&nbsp;выражения <code>a + b</code>&nbsp;есть какое-то значение (зависящее от&nbsp;значений <var>a</var>&nbsp;и&nbsp;<var>b</var>) и&nbsp;тип&nbsp;&mdash; тоже действительное число. Как вы&nbsp;думаете, можно&nbsp;ли сказать, что у&nbsp;выражения <code>a == b</code>&nbsp;есть значение и&nbsp;тип? Или это просто конструкция, которая всегда должна стоять в&nbsp;условии <var>if</var>&nbsp;или <var>while</var>?</p>
<section class="material__note">
<p class="material__note-heading"><strong>Логический тип</strong></p>
<p>На&nbsp;самом деле такое выражение имеет и&nbsp;тип под названием <strong>bool</strong>, и&nbsp;значение: <var>True</var> (истина) или <var>False</var> (ложь). По-русски bool&nbsp;&mdash; это булев тип, или булево значение (в&nbsp;честь математика Джорджа Буля), иногда его еще называют логический тип.</p>
</section>
<p>Логический тип может иметь только два значения, а&nbsp;над переменными логического типа можно выполнять логические операции <var>not</var>, <var>and</var>, <var>or</var>.</p>
<p>Также для приведения к&nbsp;логическому типу можно использовать функцию <var>bool</var>, которая для ненулевого значения вернет истину.</p>
<pre><code class="language-python">k = True
print(k) # выведет True
print(not k) # выведет False
k = 5 &gt; 2
print(k) # выведет True
k = bool(0)
print(k) # выведет False
k = bool("")
print(k) # выведет False
k = bool(13)
print(k) # выведет True, т.к. число не 0
k = bool("q")
print(k) # выведет True, т.к. строка не пустая
k = bool("False")
print(k) # выведет True, т.к. строка не пустая
</code></pre>
<p>Или вот еще пример:</p>
<pre><code class="language-python">if True:
    print('Эта строка будет выведена на экран.')
else:
    print('Эта строка никогда не будет выведена на экран.')
print(2 * 2 == 4)  # выведет True
a = input()
b = input()
# Теперь переменная equal равна True, если строки a и b равны, 
# и False в противном случае
equal = (a == b)
if equal and len(a) &lt; 6:
    print('Вы ввели два коротких одинаковых слова.')
</code></pre>
</section>
<section class="material__chapter">
<h2 id="2">Использование флагов</h2>
<p>Обычно переменные с&nbsp;булевым значением используются в&nbsp;качестве флагов.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Флаг</strong></p>
<p>Изначально флаг устанавливается в&nbsp;False, потом программа как-то работает, а&nbsp;при наступлении определенного события флаг устанавливается в&nbsp;True. После идет проверка, поднят&nbsp;ли флаг. В&nbsp;зависимости от&nbsp;ее&nbsp;результата выполняется то&nbsp;или иное действие. Иными словами, флаг&nbsp;&mdash; это переменная с&nbsp;булевым значением, которая показывает, наступило&nbsp;ли некое событие.</p>
</section>
<p>В&nbsp;примере ниже (эта программа&nbsp;&mdash; терапевтический тренажер для избавления физиков-экспериментаторов от&nbsp;синхрофазотронозависимости) имеется флаг <var>said_forbidden_word</var>, который означает &laquo;сказал&nbsp;ли пользователь запретное слово &bdquo;синхрофазотрон&ldquo;&raquo;. Флаг равен True, если сказал, и&nbsp;False, если нет.</p>
<p>В&nbsp;самом начале пользователь еще ничего не&nbsp;успел сказать, поэтому флаг установлен в&nbsp;False. Далее на&nbsp;каждой итерации цикла, если пользователь сказал запретное слово, флаг устанавливается в&nbsp;True и&nbsp;остается в&nbsp;таком состоянии (при необходимости флаг можно и&nbsp;&laquo;опустить&raquo;). Как только флаг оказывается равен True, поведение программы меняется: перед каждым вводом выдается предупреждение, а&nbsp;в&nbsp;конце выдается другое сообщение.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Переменным-флагам особенно важно давать осмысленные имена (обычно&nbsp;&mdash; утверждения вроде <var>said_forbidden_word</var>, <var>found_value</var>, <var>mission_accomplished</var>, <var>mission_failed</var>), ведь флагов в&nbsp;программе бывает много.</p>
</section>
<pre><code class="language-python">forbidden_word = 'синхрофазотрон'
# можно было использовать и sep='', чтобы кавычки не отклеились от слова
print('Введите десять слов, но постарайтесь случайно не ввести слово "' + 
      forbidden_word + '"!')
said_forbidden_word = False
for i in range(10):
    if said_forbidden_word:
        print('Напоминаем, будьте осторожнее, не введите снова слово "' + 
              forbidden_word + '"!')
    word = input()
    if word == forbidden_word:
        said_forbidden_word = True
    # вместо предыдущих двух строк также можно написать:
    # said_forbidden_word = (said_forbidden_word or word == forbidden_word)
if said_forbidden_word:
    print('Вы нарушили инструкции.')
else:
    print('Спасибо, что ни разу не упомянули', forbidden_word)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Операторы break и&nbsp;continue. Бесконечные циклы</h2>
<p>Если нужно прекратить работу цикла, как только случится некое событие, то,&nbsp;кроме флага, есть и&nbsp;другой способ&nbsp;&mdash; оператор разрыва цикла <strong>break</strong> (он&nbsp;работает и&nbsp;для цикла <var>for</var>). Это не&nbsp;функция и&nbsp;не&nbsp;заголовок блока, а&nbsp;оператор, который состоит из&nbsp;одного слова. Он&nbsp;немедленно прерывает выполнение цикла <var>for</var> или <var>while</var>.</p>
<pre><code class="language-python">for i in range(10):
    print('Итерация номер', i, 'начинается...')
    if i == 3:
        print('Ха! Внезапный выход из цикла!')
        break
    print('Итерация номер', i, 'успешно завершена.')
print('Цикл завершён.')
</code></pre>
<p>В&nbsp;частности, нередко встречается такая конструкция: цикл, выход из&nbsp;которого происходит не&nbsp;по&nbsp;записанному в&nbsp;заголовке цикла условию (это условие делается всегда истинным&nbsp;&mdash; как правило, просто True), а&nbsp;по&nbsp;оператору <var>break</var>, который уже заключен в&nbsp;какой-то условный оператор:</p>
<pre><code class="language-python">while True:
    word = input()
    if word == 'стоп':
        break
    print('Вы ввели:', word)
print('Конец.')
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Впрочем злоупотреблять этой конструкцией и&nbsp;вообще оператором <var>break</var> не&nbsp;стоит. Когда программист читает ваш код, он&nbsp;обычно предполагает, что после окончания цикла <var>while</var> условие в&nbsp;заголовке этого цикла ложно. Если&nbsp;же из&nbsp;цикла можно выйти по&nbsp;команде <var>break</var>, то&nbsp;это уже не&nbsp;так. Логика кода становится менее ясной.</p>
</section>
<p>Оператор <strong>continue</strong> немедленно завершает текущую итерацию цикла и&nbsp;переходит к&nbsp;следующей.</p>
<pre><code class="language-python">for i in range(10):
    print('Итерация номер', i, 'начинается...')
    if i == 3:
        print('...но её окончание таинственно пропадает.')
        continue
    print('Итерация номер', i, 'успешно завершена.')
print('Цикл завершён.')
</code></pre>
<p>Рассмотрим еще один пример:</p>
<pre><code class="language-python">count = 1
while count &lt; 100:
    if count % 5 == 0:
        continue
    print(count)
    count += 1
</code></pre>
<p>Что будет напечатано в&nbsp;процессе выполнения программы?</p>
<p>Предполагается, что программа выведет все числа от&nbsp;1&nbsp;до&nbsp;100, не&nbsp;кратные 5. Но&nbsp;на&nbsp;самом деле, если вы&nbsp;запустите программу в&nbsp;режиме трассировки, на&nbsp;экран выведется 1 2 3&nbsp;4, а&nbsp;потом программа уйдет в&nbsp;бесконечный цикл. Почему это происходит?</p>
<p>Когда переменная <var>count</var> станет равна&nbsp;5, записанное в&nbsp;операторе <var>if</var>&nbsp;условие станет истинным и&nbsp;выполнится оператор <var>continue</var>. Т.&nbsp;е.&nbsp;мы&nbsp;немедленно перейдем к&nbsp;следующей итерации цикла, пропуская вывод числа и&nbsp;увеличение счетчика <var>count</var>.</p>
<p>Переменная <var>count</var> так и&nbsp;не&nbsp;увеличится и&nbsp;по-прежнему останется со&nbsp;значением 5. Значит, условие в&nbsp;<var>if</var>&nbsp;будет все так же равно True, и&nbsp;цикл станет бесконечным.</p>
<p>Иными словами, часто использовать <var>break</var> и&nbsp;<var>continue</var> не&nbsp;рекомендуют, поскольку они приводят к&nbsp;произвольному перемещению точки выполнения программы по&nbsp;всему коду, что усложняет понимание и&nbsp;следование логике. Тем не&nbsp;менее разумное использование этих операторов может улучшить читабельность циклов в&nbsp;программе, уменьшив при этом количество вложенных блоков и&nbsp;необходимость в&nbsp;сложной логике выполнения цикла.</p>
<p>Например, рассмотрим следующую программу:</p>
<pre><code class="language-python">count = 0
exitLoop = False
while not exitLoop:
    print("Введите 'e' для выхода и любую другую клавишу для продолжения:")
    sm = input() 
    if sm == 'e':
        exitLoop = True
    else:
        count += 1
        print("Вы зашли в цикл ", count, " раз(а)")
</code></pre>
<p>А&nbsp;теперь ту&nbsp;же самую программу напишем с&nbsp;использованием оператора <var>break</var>:</p>
<pre><code class="language-python">count = 0
exitLoop = False
while not exitLoop:
    print("Введите 'e' для выхода и любую другую клавишу для продолжения: ")
    sm = input()
    if sm == 'e':
        break
    count += 1
    print("Вы зашли в цикл ", count, " раз(а)")
</code></pre>
<p>И&nbsp;создадим бесконечный цикл, отказавшись от переменной <var>exitLoop</var>:</p>
<pre><code class="language-python">count = 0
while True:
    print("Введите 'e' для выхода и любую другую клавишу для продолжения: ")
    sm = input()
    if sm == 'e':
        break
    count += 1
    print("Вы зашли в цикл ", count, " раз(а)")
</code></pre>
<p>Чего нам удалось добиться? Во-первых, мы&nbsp;избежали использования как логической переменной, так и&nbsp;оператора <var>else</var>. Уменьшение количества используемых переменных и&nbsp;вложенных блоков улучшают читабельность и&nbsp;понимание кода больше, чем <var>break</var> или <var>continue</var> могут нанести вред.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>