<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Переопределение функций и декораторы </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Декораторы</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Переопределение функций и&nbsp;декораторы</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Переопределение функций</a></li>
<li><a class="material__link" href="#2">Инструкция pass. Согласованность аргументов</a></li>
<li><a class="material__link" href="#3">Инструкция def</a></li>
<li><a class="material__link" href="#4">Предосторожности при переопределении функций</a></li>
<li><a class="material__link" href="#5">Функция внутри функции</a></li>
<li><a class="material__link" href="#6">Декораторы</a></li>
<li><a class="material__link" href="#7">Нелокальные переменные</a></li>
<li><a class="material__link" href="#8">Небольшие, но&nbsp;типичные детали реализации декоратора</a></li>
<li><a class="material__link" href="#9">Захват значения из&nbsp;аргумента</a></li>
<li><a class="material__link" href="#10">Немного о&nbsp;терминологии</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Этот урок содержит дополнительный материал для самостоятельного изучения.</p>
</section>
<section class="material__chapter">
<h2 id="1">Переопределение функций</h2>
<p>Как вы&nbsp;уже знаете, функцию можно записать в&nbsp;переменную. Оказывается, помимо этого, с&nbsp;именем функции можно работать как с&nbsp;самой обыкновенной переменной. И&nbsp;значение, на&nbsp;которое <strong>указывает</strong> переменная с&nbsp;именем функции, можно изменить.</p>
<p>Рассмотрим пример. У&nbsp;нас есть функция <code>input()</code>, которая читает данные из&nbsp;стандартного потока ввода. Давайте сделаем так, чтобы она не&nbsp;беспокоила пользователя и&nbsp;всегда давала один и&nbsp;тот&nbsp;же ввод. Для начала создадим свою функцию, которая будет работать вместо <code>input()</code>, а&nbsp;затем подменим значение <var>input</var> этой функцией.</p>
<pre><code class="language-python">def main_answer_in_the_universe():
    return 42


input = main_answer_in_the_universe
x = input()
print(x) # 42
</code></pre>
</section>
<section class="material__chapter">
<h2 id="2">Инструкция pass. Согласованность аргументов</h2>
<p>Теперь, чтобы совсем не&nbsp;отвлекать пользователя работой программы, давайте подменим еще и&nbsp;функцию <code>print()</code> так, чтобы она ничего не&nbsp;печатала на&nbsp;экран. На&nbsp;одном из&nbsp;прошлых занятий мы&nbsp;писали функцию <code>nop()</code>, которая не&nbsp;делала ничего, но&nbsp;принимала в&nbsp;себя любой набор аргументов. К&nbsp;ней&nbsp;и&nbsp;обратимся.</p>
<pre><code class="language-python">def nop(*rest, **kwargs):
    pass


print = nop
print("(шепотом) Потише, пожалуйста!", end='')
</code></pre>
<p>Теперь функция <code>print()</code> связана с&nbsp;объектом функции, которая при вызове не&nbsp;делает ничего. Привычная команда <code>print()</code> изменила поведение.</p>
<p>Снова обращаем ваше внимание на&nbsp;то, что в&nbsp;аргументах функции <code>nop()</code> указано произвольное число аргументов (и&nbsp;произвольное число именованных аргументов). Благодаря этому мы&nbsp;можем передавать ей&nbsp;разное число аргументов, как и&nbsp;в&nbsp;старую функцию <code>print()</code>, и&nbsp;разные наборы опций, описываемые именованными аргументами (<var>sep</var>, <var>end</var> и&nbsp;т.&nbsp;п.). На&nbsp;самом деле теперь не&nbsp;вызывают ошибки даже те&nbsp;наборы аргументов, которые не&nbsp;работают со&nbsp;встроенной функцией <code>print()</code>: функция <code>print()</code> принимает не&nbsp;любые именованные параметры, а&nbsp;только небольшой список, а&nbsp;функция <code>nop()</code> (а&nbsp;значит, и&nbsp;переопределенный <code>print()</code>) &mdash; абсолютно любые.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Подменяя функцию, мы&nbsp;заботимся о&nbsp;том, чтобы ее&nbsp;аргументы соответствовали аргументам исходной функции. Иначе придется переписывать не&nbsp;только функцию, но&nbsp;и&nbsp;ее&nbsp;вызовы, а&nbsp;в&nbsp;таком случае гораздо лучше просто завести новую функцию.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="3">Инструкция def</h2>
<p>Есть и&nbsp;более простой, но&nbsp;чуть менее гибкий способ заменить существующую функцию на&nbsp;другую. Для этого достаточно определить функцию с&nbsp;тем&nbsp;же именем&nbsp;&mdash; и&nbsp;она заменит существующую:</p>
<pre><code class="language-python">def input():
    return 42


x = input()
print(x) # 42
</code></pre>
<p>Интересно, что инструкцию <var>def</var> можно использовать в&nbsp;разных сложных конструкциях, словно это абсолютно обычная команда вроде присваивания или вызова функции.</p>
<p>Например, можно определять функцию по-разному в&nbsp;зависимости от&nbsp;некоторого условия:</p>
<pre><code class="language-python">language = 'fr'
if language == 'ru':
    def hello(name):
        print('Привет, ', name)
else:
    def hello(name):
        print('Hi, ', name)

hello('Joe') # =&gt; Hi, Joe
</code></pre>
<p>Дальше мы&nbsp;будем использовать более многословный способ.</p>
</section>
<section class="material__chapter">
<h2 id="4">Предосторожности при переопределении функций</h2>
<p>Теперь, когда вы&nbsp;научились использовать такой сильный инструмент, как переопределение функций, давайте обсудим правила, которые надо соблюдать.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Стоит понимать, что <strong>изменять существующие функции очень опасно</strong>.</p>
<p>Почти всегда есть способ обойтись без этого, и&nbsp;его стоит предпочесть. Переопределение функций делает программу плохо предсказуемой.</p>
</section>
<p>Когда вы&nbsp;пишете функцию, часто бывает, что ее&nbsp;поведение зависит от&nbsp;поведения других функций. И, если в&nbsp;дальнейшем вы&nbsp;поменяете поведение какой-то из&nbsp;этих функций, сломаются многие из&nbsp;них, которые опирались на&nbsp;измененную.</p>
<p>Еще хуже&nbsp;&mdash; почти <strong>недопустимо&nbsp;&mdash; изменять встроенные функции</strong>, как мы&nbsp;недавно делали.</p>
<p>Во-первых, в&nbsp;программе они используются настолько часто, что очень тяжело отследить все места, на&nbsp;которые они влияют. Например, представьте, что вы&nbsp;изменили функцию вычисления квадратного корня так, чтобы она не&nbsp;только считала его значение, но&nbsp;еще и&nbsp;печатала результат. Теперь, если вы&nbsp;попробуете вызвать функцию, решающую квадратные уравнения, вам не&nbsp;избежать вывода на&nbsp;экран корня из&nbsp;дискриминанта, даже если вы&nbsp;этого не&nbsp;хотели.</p>
<p>Во-вторых, встроенные функции и&nbsp;функции стандартной библиотеки вполне могут зависеть друг от&nbsp;друга, а&nbsp;вы&nbsp;об&nbsp;этом даже не&nbsp;знаете. Вам будем казаться, что изменилось поведение одной функции, когда на&nbsp;самом деле это далеко не&nbsp;так.</p>
<p>Теперь после предупреждения о&nbsp;том, что подменять функции опасно, мы&nbsp;рассмотрим, когда и&nbsp;как это можно делать с&nbsp;пользой (и&nbsp;как при этом ничего не&nbsp;испортить).</p>
</section>
<section class="material__chapter">
<h2 id="5">Функция внутри функции</h2>
<p>Аналогия функций с&nbsp;переменными имеет продолжение. Бывают функции, которые определены глобально, а&nbsp;бывают&nbsp;&mdash; определенные локально. Если внутри функции переопределить <code>print()</code>, это будет локальная функция <code>print()</code>, а&nbsp;глобальная не&nbsp;изменится. Когда мы&nbsp;выйдем из&nbsp;области видимости, в&nbsp;которой был объявлен локальный <code>print()</code>, слово <var>print</var> вновь будет ссылаться на&nbsp;функцию в&nbsp;глобальной области видимости и&nbsp;будет работать как прежде.</p>
<p>Модификатор видимости <var>global</var>, кстати, с&nbsp;именами функций тоже работает (и&nbsp;им&nbsp;точно так&nbsp;же&nbsp;не&nbsp;рекомендуется пользоваться).</p>
<p>Подменять существующую функцию локально, в&nbsp;пределах другой функции, обычно безопасно.</p>
<p>Давайте сделаем функцию, которая разыгрывает короткий диалог с&nbsp;пользователем, но, чтобы программа казалась умнее, пока настоящий искусственный интеллект только разрабатывается, мы&nbsp;подменим функцию <code>answer()</code>, которая дает ответы на&nbsp;вопросы.</p>
<pre><code class="language-python">def answer(question):
    return 'В разработке'


def dialog():
    def answer(question):
        if question.lower().startswith('когда') :
            return 'Никогда!'
        else:
            return 'Разоблачили.'
            
    question = input()
    while question != '':
        print(answer(question))
        question = input()


dialog()

# &lt;= Когда станет тепло?
# =&gt; Никогда!
# &lt;= Когда смогу найти богатство?
# =&gt; Никогда!
# &lt;= Какие в Чили существуют города?
# =&gt; Разоблачили
</code></pre>
<p>Этот пример служит исключительно иллюстрацией, ни&nbsp;в&nbsp;коем случае не&nbsp;рекомендацией. Ведь мы&nbsp;могли не&nbsp;переименовывать функцию, а&nbsp;просто определить новую функцию.</p>
<p><strong>Задача.</strong> Подмените функцию <code>print()</code> так, чтобы она ПЕЧАТАЛА ВЕСЬ ТЕКСТ В&nbsp;ВЕРХНЕМ РЕГИСТРЕ. Реализовывать работу с&nbsp;именованными аргументами (<var>sep</var>, <var>end</var>, ...) не&nbsp;нужно.</p>
</section>
<section class="material__chapter">
<h2 id="6">Декораторы</h2>
<p>Вы&nbsp;научились переопределять функцию так, чтобы новая функция использовала старую. Такой процесс называется декорированием функции. Но&nbsp;мы&nbsp;это сделали не&nbsp;слишком удачно: у&nbsp;нас появилась лишняя переменная и&nbsp;функция <code>old_print()</code>. Чтобы не&nbsp;вводить лишнюю переменную в&nbsp;глобальной области видимости, мы&nbsp;определим функцию в&nbsp;локальной области видимости, т.&nbsp;е.&nbsp;внутри другой функции. Внутреннюю функцию мы&nbsp;вернем как результат выполнения внешней функции:</p>
<pre><code class="language-python">def use_uppercased_arguments(old_func):
    def new_func(*args, **kwargs):
        args_upcased = [str(arg).upper() for arg in args]
        old_func(*args_upcased, **kwargs)
        
    return new_func


print = use_uppercased_arguments(print)
</code></pre>
<p>В&nbsp;коде выше произошло следующее: мы&nbsp;определили функцию <code>use_uppercased_arguments()</code>, которая принимает одну функцию как аргумент и&nbsp;возвращает новую функцию, сделанную на&nbsp;основе старой. Функция, которая занимается этими превращениями, называется <strong>декоратором</strong>. Имя <var>new_func</var>, которое мы&nbsp;определили внутри декоратора, локальное. Как только мы&nbsp;выполним <var>return new_func</var>, это будет просто функция без имени.</p>
<p>Этой новой функции мы&nbsp;даем имя, которое было у&nbsp;старой функции.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Декораторы</strong></p>
<p>Такие функции, как <code>use_uppercased_arguments()</code>, называются декораторами потому, что обычно они добавляют какие-то штрихи (декор) к&nbsp;уже существующему поведению, не&nbsp;изменяя ее&nbsp;код.</p>
</section>
<p>Бывает так, что функцию (или, скорее, несколько) сразу пишут в&nbsp;расчете на&nbsp;то, что она будет декорирована определенным образом. Обычно так поступают, когда функции хотят добавить некоторое типичное поведение.</p>
<p>Например:</p>
<ul>
<li>Когда каждый вызов функции нужно залоггировать, т.&nbsp;е.&nbsp;вывести при вызове сообщение о&nbsp;том, как и&nbsp;когда функция была вызвана</li>
<li>Когда результат функции должен быть закеширован (т.&nbsp;е.&nbsp;после вычисления сохранен на&nbsp;будущее, чтобы не&nbsp;считать его повторно)</li>
<li>Чтобы функция использовалась для ответа на&nbsp;запросы к&nbsp;веб-серверу</li>
<li>Чтобы перед запуском проверялось какое-то условие (например, что пользователь имеет право доступа к&nbsp;выполнению функции)</li>
</ul>
<p>Мы&nbsp;напишем функцию, которая будет выводить журнал запусков и&nbsp;результатов декорированной функции. Каждый раз перед вызовом функции мы&nbsp;будем писать номер вызова, аргументы и&nbsp;значение, которое функция вернула. Мы&nbsp;хотим вести такой отчет для функции приготовления бургеров из&nbsp;прошлого занятия и&nbsp;для функции наливания, возвращающей тип напитка.</p>
<pre><code class="language-python">def logged(func):
    count = 0

    def decorated_func(*args, **kwargs):
        nonlocal count
        count += 1
        print(count, '&gt;&gt;', 'Arguments:', args, 'Named arguments:', kwargs)
        result = func(*args, **kwargs)
        print('--', 'Result:', result)
        return result

    return decorated_func


@logged
def make_burger(type_of_meat, with_onion=False, with_tomato=True):
    print('Булочка')
    if with_onion:
        print('Луковые колечки')
    if with_tomato:
        print('Ломтик помидора')
    print('Котлета из', type_of_meat)
    print('Булочка')


@logged
def drinking_type(type):
    return 'У нас есть только чай'
</code></pre>
<p>Сначала посмотрите на&nbsp;определения функций <code>make_burger()</code> и&nbsp;<code>drinking_type()</code>.</p>
<p>Тело функций представляет мало интереса, это очень простые функции.</p>
<p>А&nbsp;вот <code>@logged</code> перед определением функции&nbsp;&mdash; новый для вас объект. Эта строчка говорит, что функция, которая идет дальше, будет задекорирована с&nbsp;помощью декоратора <var>logged</var>. Обратите внимание: задекорированы обе функции одним декоратором. И&nbsp;никаких промежуточных функций и&nbsp;вспомогательных переменных мы&nbsp;не&nbsp;использовали.</p>
</section>
<section class="material__chapter">
<h2 id="7">Нелокальные переменные</h2>
<p>Теперь обратимся к&nbsp;декоратору. В&nbsp;нем есть моменты, которые вы&nbsp;раньше не&nbsp;встречали. По&nbsp;условию, мы&nbsp;должны посчитать каждый вызов функции. На&nbsp;одном из&nbsp;прошлых уроков мы&nbsp;делали функцию <code>ask_again()</code>, которая тоже считала вызовы. В&nbsp;тот раз мы&nbsp;использовали глобальную переменную-счетчик, чтобы хранить, сколько раз мы&nbsp;уже вызывали функцию.</p>
<p>В&nbsp;этот раз мы&nbsp;используем похожую технику и&nbsp;определяем переменную <var>count</var>, но&nbsp;не&nbsp;глобальную, а&nbsp;локальную, для функции-декоратора. Затем мы&nbsp;создаем новую локальную функцию <code>decorated_func()</code>, которую позднее вернем в&nbsp;качестве результата. Эта функция должна иметь доступ к&nbsp;счетчику, который снаружи, но&nbsp;все-таки не&nbsp;в&nbsp;глобальной области видимости.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Нелокальные переменные</strong></p>
<p>Эта промежуточная область видимости называется <strong>нелокальной</strong>. Внутренняя функция видит переменные в&nbsp;объемлющей функции, но, если она хочет такую переменную изменить, должна объявить ее&nbsp;<var>nonlocal</var>. В&nbsp;область поиска не&nbsp;входят глобальная и&nbsp;встроенная области видимости.</p>
</section>
<p>При поиске переменной или функции с&nbsp;указанными именем приоритет (или, как говорят, правило разрешения имен) следующий:</p>
<ol>
<li>Сначала ищем локальную переменную (функцию).</li>
<li>Если не&nbsp;нашли локальную, ищем нелокальную.</li>
<li>Затем&nbsp;&mdash; глобальную.</li>
<li>И&nbsp;в&nbsp;самом конце&nbsp;&mdash; встроенную в&nbsp;язык.</li>
</ol>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Если вложенность функций больше двух уровней, нелокальная переменная ищет в&nbsp;&laquo;ближайшей&raquo; области видимости, т.&nbsp;е.&nbsp;в&nbsp;функции вложенностью на&nbsp;один меньше. Если не&nbsp;находит, поиск переходит в&nbsp;самую ближнюю из&nbsp;внешних областей видимости, затем в&nbsp;чуть более далекую&nbsp;&mdash; и&nbsp;так далее, пока не&nbsp;найдется нужное имя. Фактически интерпретатор ищет, &laquo;где поближе&raquo;.</p>
</section>
<p>Такая техника позволяет сделать внешнюю для функции переменную, но&nbsp;при этом спрятанную от&nbsp;посторонних глаз, в&nbsp;отличие от&nbsp;глобальной. Такие переменные нужны в&nbsp;первую очередь для того, чтобы хранить какие-то данные, относящиеся к&nbsp;функции, между вызовами функции. Локальные переменные стираются при выходе из&nbsp;функции, глобальные&nbsp;&mdash; сохраняются, но&nbsp;видны всему свету, а&nbsp;нелокальные&nbsp;&mdash; идеальное сочетание закрытости и&nbsp;&laquo;сохраняемости&raquo;.</p>
<p>В&nbsp;некоторых языках программирования принято называть такие переменные <strong>статическими</strong>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Если вы&nbsp;попробуете запустить две получившиеся функции, увидите, что их&nbsp;счетчики независимы. Это совершенно логично, поскольку эти переменные локальны для запусков самого декоратора <var>logged</var>. Когда мы&nbsp;оборачивали одну функцию, был создан один счетчик; когда оборачивали вторую&nbsp;&mdash; другой.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="8">Небольшие, но&nbsp;типичные детали реализации декоратора</h2>
<p>Стоит также обратить внимание на&nbsp;список аргументов функции. Наша декорированная функция, в&nbsp;отличие от&nbsp;исходной, принимает любой набор аргументов, а&nbsp;когда вызывает исходную функцию, передает их&nbsp;в&nbsp;неизменном виде с&nbsp;помощью звездочек, раскрывающих список позиционных параметров и&nbsp;словарь именованных параметров.</p>
<p>Это стандартный паттерн (то&nbsp;есть шаблон) для вызова функции, которую мы&nbsp;решили обернуть. Но&nbsp;не&nbsp;всегда список переданных аргументов бывает корректен, в&nbsp;этом случае обернутая функция просто завершится с&nbsp;ошибкой. Наконец, обратите внимание еще&nbsp;на&nbsp;одну стандартную конструкцию: мы&nbsp;сначала сохранили значение, которое вернула обернутая функция, а&nbsp;затем его&nbsp;же и&nbsp;вернули.</p>
<p>Теперь мы&nbsp;пронумеруем и&nbsp;напечатанную строку с&nbsp;аргументами, и&nbsp;строку с&nbsp;результатом функции одним и&nbsp;тем&nbsp;же номером. Благодаря этому мы&nbsp;можем пронаблюдать дерево вызовов рекурсивной функции, т.&nbsp;е.&nbsp;такой, которая вызывает сама себя. Вы, возможно, помните, что мы&nbsp;делали однажды рекурсивную функцию для вычисления n-го числа Фибоначчи.</p>
<p>Теперь обернем с&nbsp;помощью нашего декоратора ее&nbsp;и&nbsp;вызовем:</p>
<pre><code class="language-python">def logged(func):
    count = 0

    def decorated_func(*args, **kwargs):
        nonlocal count
        count += 1
        current_index = count
        print(current_index, '&gt;&gt;', 'Arguments:', args, 
              'Named arguments:', kwargs)
        result = func(*args, **kwargs)
        print(current_index, '--', 'Result:', result)
        return result

    return decorated_func


@logged
def fib(n):
    if n &lt;= 2:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)


fib(5)
</code></pre>
<p>Почему мы&nbsp;сделали <code>current_index = count</code>, а&nbsp;не&nbsp;использовали сам <var>count</var>, ведь <var>count</var> нигде в&nbsp;этой функции не&nbsp;изменяется? Но&nbsp;это иллюзия. <var>count</var>&nbsp;&mdash; нелокальная переменная, поэтому ее&nbsp;может изменить вызов другой функции, имеющей доступ к&nbsp;этой переменной. У&nbsp;нас как раз такая ситуация: функция вызывает саму себя и&nbsp;в&nbsp;процессе этого вызова переменная <var>count</var> изменяется. Чтобы такого не&nbsp;было, мы&nbsp;заранее сохраняем значение счетчика в&nbsp;отдельную переменную, которую не&nbsp;меняют вызовы других функций. А&nbsp;так как числа неизменяемы, &laquo;изменение&raquo; (присваивание нового значения) значения переменной <var>count</var> никак не&nbsp;повлияет на&nbsp;<var>current_index</var>.</p>
<p><strong>Задача.</strong> Напишите декоратор <var>check_password</var>, который запрашивает пароль, прежде чем вызвать функцию&nbsp;и, если он&nbsp;неверный, возвращает None и&nbsp;печатает &laquo;В&nbsp;доступе отказано&raquo;. Запарольте этим декоратором функцию вычисления числа Фибоначчи.</p>
</section>
<section class="material__chapter">
<h2 id="9">Захват значения из&nbsp;аргумента</h2>
<p>Иногда бывает удобно сделать функцию, которая создает другие функции на&nbsp;основе аргументов. Например, мы&nbsp;хотим создать функции квадрата и&nbsp;куба числа.</p>
<pre><code class="language-python">def power(degree):
    def func(x):
        return x ** degree

    return func


square = power(2)
cube = power(3)

print(square(5))  # --&gt; 25
</code></pre>
<p>Внутренняя функция взяла параметр <var>degree</var> из&nbsp;аргумента функции <code>power()</code>. Этот прием часто используется для того, чтобы зафиксировать какой-то набор параметров и&nbsp;сделать функцию с&nbsp;более коротким списком аргументов. Рассмотрим еще один пример. Пусть у&nbsp;нас есть функция <code>send_invitation(email, name, text, date, city)</code>. Мы&nbsp;хотим использовать&nbsp;ее, не&nbsp;перечисляя всякий раз весь этот внушительный список параметров.</p>
<p>Например, вы&nbsp;знаете, что меняется только текст и&nbsp;адресат (имя и&nbsp;адрес), а&nbsp;город и&nbsp;дата мероприятия зафиксированы. Часть параметров будет браться из&nbsp;аргументов новой функции, часть&nbsp;&mdash; из&nbsp;аргументов старой.</p>
<pre><code class="language-python">def invitation_sender(city, date, text):
    def sender(email, name):
        return send_invitation(email, name, text, date, city)

    return sender


send_mail = invitation_sender('Москва', '1 апреля 2017 г', 
                              'Приглашаем вас на встречу')
send_mail('vasiliy-petrov@yandex.ru', 'Василий Петров')
send_mail('petr-alekseev@yandex.ru', 'Петр Алексеев')
send_mail('vasiliy-vasilyev@yandex.ru', 'Василий Васильев')
</code></pre>
<p>Функция, которая захватила объект из&nbsp;внешнего контекста, удерживает его вечно. Хотя <var>degree</var> в&nbsp;функции <var>power</var> является локальной переменной, эта переменная не&nbsp;исчезнет бесследно после завершения работы функции <var>power</var>. Функция, которая будет возвращена, несет значение этой переменной <var>degree</var> с&nbsp;собой.</p>
</section>
<section class="material__chapter">
<h2 id="10">Немного о&nbsp;терминологии</h2>
<p>Программисты, как и&nbsp;любые другие специалисты, любят давать понятиям названия. Давайте дадим названия тем понятиям, которые вы&nbsp;уже узнали.</p>
<p>Функция, которая использует внешние переменные, не&nbsp;являющиеся ее&nbsp;аргументами, называется <strong>замыканием</strong>. Если использует нелокальные переменные&nbsp;&mdash; она является замыканием (независимо от&nbsp;того, были&nbsp;они определены во&nbsp;внешней функции или пришли из&nbsp;аргументов внешней функции). Если функция использует глобальные переменные, это тоже замыкание. Но&nbsp;чаще всего замыканием называют все-таки функцию, которая использует нелокальные переменные. Такая функция как&nbsp;бы &laquo;таскает за&nbsp;собой&raquo; свои внешние переменные, но&nbsp;никому их&nbsp;не&nbsp;показывает.</p>
<p>Функция, которая принимает функцию в&nbsp;качестве аргумента или&nbsp;же возвращает функцию, называется <strong>функцией высшего порядка</strong>.</p>
<p>Функция, которая принимает функцию и&nbsp;возвращает функцию, называется <strong>декоратором</strong>. Но&nbsp;при этом предполагается, что возвращенная функция должна быть оберткой над переданной функцией.</p>
<p><strong>Задача.</strong> Напишите генератор декораторов <var>check_password</var>, т.&nbsp;е.&nbsp;функцию, которая возвращает декоратор. Генератор декораторов принимает в&nbsp;качестве параметра пароль, и&nbsp;получившийся декоратор должен закрыть функцию этим паролем.</p>
<p>Этот декоратор будет применяться следующим образом:</p>
<pre><code class="language-python">@check_password('password')
def make_burger(typeOfMeat, withOnion=False, withTomato=True):
    # ...
</code></pre>
<p>Т.&nbsp;е.&nbsp;при определении функции сначала вызывается функция <code>check_password()</code> c&nbsp;аргументом <var>'password'</var>, получается декоратор, а&nbsp;затем уже этот получившийся декоратор применяется к&nbsp;функции.</p>
<p><strong>Задача.</strong> Напишите декоратор <var>cached</var>, который будет кешировать результат вызова функции.</p>
<p>Когда задекорированная функция впервые вызывается с&nbsp;некоторым аргументом, необходимо выполнить исходную функцию и&nbsp;сохранить посчитанный результат. При последующих вызовах не&nbsp;надо вызывать исходную функцию, а&nbsp;следует найти сохраненное значение и&nbsp;вернуть его. Этот декоратор будет очень полезен для <strong>чистых вычислений</strong> (т.&nbsp;е.&nbsp;вычислений, зависящих только от&nbsp;переданных аргументов), которые занимают продолжительное время.</p>
<p>Вы&nbsp;уже видели подобное использование функций в&nbsp;уроке про рекурсию. В&nbsp;примере оттуда рекурсивное вычисление числа Фибоначчи при помощи функции <code>fib()</code> занимает очень много времени.</p>
<p>В&nbsp;этот раз задача сложнее: во-первых, задекорированная функция должна самостоятельно осуществлять кеширование. Во-вторых, кеширование должно зависеть от&nbsp;переданных параметров, т.&nbsp;е.&nbsp; вам следует сохранять не&nbsp;один результат, а&nbsp;список посчитанных уже пар значений вида (набор параметров, результат).</p>
<p>Мы&nbsp;предлагаем использовать словарь для решения данной задачи.</p>
<p>Пример того, как можно будет использовать ваш декоратор:</p>
<pre><code class="language-python">@cached
def fib(n):
    if n == 1 or n == 2:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)


print(fib(60))
</code></pre>
<p>Если рекурсивное вычисление числа Фибоначчи не&nbsp;закешировать, вы&nbsp;едва&nbsp;ли дождетесь того, что шестидесятое число последовательности посчитается. Версия&nbsp;же с&nbsp;кешированием сделает это очень быстро.</p>
<p>Есть множество менее искусственных примеров, где такое кеширование может быть полезно: хотя в&nbsp;примере с&nbsp;числами Фибоначчи есть эффективный алгоритм их&nbsp;вычисления, вы&nbsp;не&nbsp;всегда знаете быстрый способ. А&nbsp;даже если знаете, иногда его слишком тяжело реализовать, тогда как сделать кеширование при помощи вашего декоратора займет всего одну строку.</p>
<p>Кроме математических вычислений, бывают и&nbsp;другие долгие операции. Например, так можно сохранять результаты интернет-запросов (интернет-запрос&nbsp;&mdash; очень долгая операция по&nbsp;меркам компьютера).</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>