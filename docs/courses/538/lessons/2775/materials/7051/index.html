<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Библиотеки Python. Numpy </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Numpy</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Библиотеки Python. Numpy</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Вычислительные возможности Python. Numpy</a></li>
<li><a class="material__link" href="#2">Измерение скорости</a></li>
<li><a class="material__link" href="#3">Массивы в&nbsp;Numpy</a></li>
<li><a class="material__link" href="#4">Размерность массива</a></li>
<li><a class="material__link" href="#5">Индексация в&nbsp;массивах</a></li>
<li><a class="material__link" href="#6">Массовые операции</a></li>
<li><a class="material__link" href="#7">Немного о&nbsp;матрицах</a></li>
<li><a class="material__link" href="#8">Сортировки</a></li>
<li><a class="material__link" href="#9">Вспомним PIL</a></li>
<li><a class="material__link" href="#10">Игра &laquo;Жизнь&raquo;</a></li>
</ol>
</nav></section>
<!-- Аннотация -->
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Этот урок посвящен вычислительным мощностям Python и&nbsp;библиотеке Numpy. Кроме того, мы&nbsp;научимся замерять время выполнения программы. Затронем работу с&nbsp;многомерными массивами и&nbsp;изучим (или вспомним) немного линейной алгебры. А&nbsp;еще, возможно, напишем игру.</p>
</section>
<section class="material__chapter">
<h2 id="1">Вычислительные возможности Python. Numpy</h2>
<p>Как мы&nbsp;уже говорили, Python&nbsp;&mdash; язык для быстрой разработки. Однако чистый Python не&nbsp;предназначен для написания быстрых программ. Это интерпретируемый язык, поэтому программы на&nbsp;Python выполняются медленнее аналогов на&nbsp;C, C++&nbsp;или Fortran. С&nbsp;другой стороны, математики, физики, биологи и&nbsp;инженеры часто применяют Python для решения вычислительных задач.</p>
<p>Нет&nbsp;ли тут противоречия? Как интерпретируемый язык может быть эффективен в&nbsp;вычислительной математике?</p>
<p>Оказывается, все дело в&nbsp;библиотеках. Python отлично подходит на&nbsp;роль промежуточной среды, оболочки, &laquo;клея&raquo; между библиотеками, написанными на&nbsp;разных языках.</p>
<p>В&nbsp;этом уроке мы&nbsp;поговорим о&nbsp;наиболее фундаментальной библиотеке для работы с&nbsp;вычислительной математикой&nbsp;&mdash; <strong>Numpy</strong>.</p>
<p>Многие другие пакеты для работы с&nbsp;данными и&nbsp;вычислениями используют базовые объекты этой библиотеки. В&nbsp;числе таких пакетов <strong>OpenCV</strong>&nbsp;&mdash; открытая библиотека для работы с&nbsp;распознаванием образов&nbsp;&mdash; и&nbsp;<strong>Pandas</strong>&nbsp;&mdash; библиотека, ориентированная на&nbsp;анализ данных.</p>
</section>
<section class="material__chapter">
<h2 id="2">Измерение скорости</h2>
<p>Замеры времени (а&nbsp;в&nbsp;более общем случае, профилирование)&nbsp;&mdash; не&nbsp;такая простая процедура, как может показаться. Обычно проще всего замерить астрономическое время между началом и&nbsp;концом выполнения задачи, усредняя результаты нескольких опытов. Однако почти все&nbsp;ОС многозадачны, поэтому процессор (и&nbsp;его вычислительные ядра) редко отдаются одной задаче в&nbsp;единоличное пользование. Как следствие, в&nbsp;измерениях лучше использовать именно процессорное время. Механизмы замера времени сами вмешиваются в&nbsp;процесс и&nbsp;немного влияют на&nbsp;результат&nbsp;&mdash; как и&nbsp;в&nbsp;любом физическом эксперименте.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Библиотека timeit</strong></p>
<p>В&nbsp;Python для замера времени работы кода служит библиотека timeit.</p>
<p>Вы&nbsp;можете познакомиться с&nbsp;возможностями модуля в&nbsp;соответствующем <a class="material__link" href="https://docs.python.org/3/library/timeit.html" target="_blank" rel="noopener noreferrer">разделе документации</a>.</p>
</section>
<p>Например, мы&nbsp;можем замерить три разных способа заполнить список из&nbsp;миллиона квадратных корней.</p>
<pre><code class="language-python">import timeit

print(timeit.timeit("[sqrt(x) for x in range(1000000)]",
                    "from math import sqrt", number=1))

print(timeit.timeit("for i in range(1000000): a.append(sqrt(i))",
                    "from math import sqrt; a=[]", number=1))

print(timeit.timeit("list(map(sqrt, range(1000000)))",
                    "from math import sqrt; a=[]", number=1))
</code></pre>
<pre><samp>0.18135334600083297
0.21764946899929782
0.1530561779945856</samp></pre>
<p>Как видим, в&nbsp;этой версии интерпретатора (3.7) предпочтительно использовать <var>map</var>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Самый медленный способ&nbsp;&mdash; это, конечно&nbsp;же, динамическое расширение существующего списка (append). Причем, чем больше список&nbsp;&mdash; тем медленнее он&nbsp;меняет свой размер. Это вызвано необходимостью иногда переносить данные из&nbsp;одного места списка в&nbsp;другое.</p>
</section>
<p>Несмотря на&nbsp;относительную быстроту (0,15 секунд на&nbsp;извлечение 1&nbsp;000&nbsp;000 квадратных корней), скорость можно увеличить еще примерно в&nbsp;10&nbsp;раз. Давайте посмотрим как.</p>
</section>
<section class="material__chapter">
<h2 id="3">Массивы в&nbsp;Numpy</h2>
<p>Основной объект в&nbsp;Numpy&nbsp;&mdash; многомерный массив.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Массивы</strong></p>
<p>Массивы&nbsp;&mdash; одна из&nbsp;базовых структур данных, которая позволяет моделировать многие объекты, относящиеся как к&nbsp;науке, так и&nbsp;к&nbsp;обычной жизни: список покупок, результаты наблюдения температуры, матрицы и&nbsp;векторы, изображения, видео и&nbsp;т.&nbsp;д.</p>
</section>
<p>Напомним, что в&nbsp;чистом Python нет типа данных с&nbsp;именем массив, и&nbsp;нам приходится моделировать его с&nbsp;помощью списков.</p>
<p>Другое дело&nbsp;&mdash; Numpy. За&nbsp;тип массива здесь отвечает объект <var>array</var>.</p>
<p>Как&nbsp;же создать массив?</p>
<p>Во-первых, массив можно сделать из&nbsp;обычного списка:</p>
<pre><code class="language-python">import numpy as np

np.array([1, 4, 10, 34])
</code></pre>
<pre><samp>array([ 1, 4, 10, 34])</samp></pre>
<p>Или из&nbsp;диапазона:</p>
<pre><code class="language-python">np.array(range(10)) 
</code></pre>
<pre><samp>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</samp></pre>
<p>А&nbsp;можно сделать и&nbsp;из&nbsp;итератора с&nbsp;помощью функции <code>fromiter()</code>:</p>
<pre><code class="language-python">np.fromiter(map(int, ["1", "2", "3", "4"]), dtype=np.int8) 
</code></pre>
<pre><samp>array([1, 2, 3, 4], dtype=int8)</samp></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>В&nbsp;Numpy элементы одного массива должны быть <strong>однородны</strong> (одного типа). Это самое важное идеологическое отличие массивов от&nbsp;списков, в&nbsp;которых можно хранить объекты разной природы.</p>
</section>
<pre><code class="language-python">np.array([11, 234.5, "hello"])
</code></pre>
<pre><samp>array(['11', '234.5', 'hello'], dtype='&lt;U32')</samp></pre>
<p>Numpy создаст массив из&nbsp;юникод-строк длиной 32. За&nbsp;тип элементов в&nbsp;большинстве случаев отвечает параметр <code>dtype(data type)</code>. Обратите внимание на&nbsp;тип данных элементов массива. Посмотрите так&nbsp;же на&nbsp;использование параметра <var>dtype</var>:</p>
<pre><code class="language-python">a = np.array([1, 3, 8])
a # =&gt; array([1, 3, 8])

a.dtype
# =&gt; dtype('int64')

type(a[0])
# =&gt; numpy.int64

a = np.array([1, 3, 8], dtype=np.float64)
type(a[0])
# =&gt; numpy.float64
</code></pre>
<p>Указание типов и&nbsp;работа с&nbsp;ними нужны, поскольку языки, на&nbsp;которых написана эта библиотека, строго типизованы. Вдобавок это увеличивает скорость обработки данных.</p>
</section>
<section class="material__chapter">
<h2 id="4">Размерность массива</h2>
<section class="material__note">
<p class="material__note-heading"><strong>Размерность массива</strong></p>
<p>Размерность массива можно в&nbsp;любой момент изменить операцией <code>reshape()</code>.</p>
<p>Узнать размерность можно атрибутом <var>shape</var>.</p>
</section>
<p>Вообще говоря, размерность&nbsp;&mdash; всего лишь &laquo;синтаксический сахар&raquo;. В&nbsp;памяти все может храниться как одномерный массив с&nbsp;пересчетом координат элемента. Таким образом, операция <code>reshape()</code> &mdash; просто изменение коэффициентов в&nbsp;алгоритме, а&nbsp;не&nbsp;перераспределение и&nbsp;копирование данных.</p>
<pre><code class="language-python">a = np.arange(100)
a.shape
</code></pre>
<pre><samp>(100,)</samp></pre>
<pre><code class="language-python">a.reshape(10, 10) 
</code></pre>
<pre><samp>array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
           [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
           [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
           [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
           [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
           [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
           [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
           [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
           [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])</samp></pre>
<pre><code class="language-python">a.reshape(5, 20) 
</code></pre>
<pre><samp>array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19],
           [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
            37, 38, 39],
           [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
            57, 58, 59],
           [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
            77, 78, 79],
           [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
            97, 98, 99]])</samp></pre>
<pre><code class="language-python">a.reshape(5, 5, 4) 
</code></pre>
<pre><samp>array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11],
            [12, 13, 14, 15],
            [16, 17, 18, 19]],
    
           [[20, 21, 22, 23],
            [24, 25, 26, 27],
            [28, 29, 30, 31],
            [32, 33, 34, 35],
            [36, 37, 38, 39]],
    
           [[40, 41, 42, 43],
            [44, 45, 46, 47],
            [48, 49, 50, 51],
            [52, 53, 54, 55],
            [56, 57, 58, 59]],
    
           [[60, 61, 62, 63],
            [64, 65, 66, 67],
            [68, 69, 70, 71],
            [72, 73, 74, 75],
            [76, 77, 78, 79]],
    
           [[80, 81, 82, 83],
            [84, 85, 86, 87],
            [88, 89, 90, 91],
            [92, 93, 94, 95],
            [96, 97, 98, 99]]])</samp></pre>
<p>Например, фильм можно представить в&nbsp;виде 4-мерного массива кадров. Кадр&nbsp;&mdash; картинка, то&nbsp;есть трехмерный массив. Его можно представить и как двумерный массив пикселей, где каждый пиксель&nbsp;&mdash; одномерный массив из&nbsp;трех элементов: R, G, B.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Самое главное&nbsp;&mdash; при использовании функции <code>reshape()</code> произведение ее&nbsp;параметров должно быть равно количеству элементов в&nbsp;массиве.</p>
<p>Иначе мы&nbsp;получим ошибку:</p>
<pre><code class="language-python">a.reshape(2, 3, 4)
</code></pre>
<pre><samp>    ValueError                 Traceback (most recent call last)

    &lt;ipython-input-31-a907d0800243&gt; in &lt;module&gt;()
    ----&gt; 1 a.reshape(2, 3, 4)
    

    ValueError: cannot reshape array of size 100 into shape (2, 3, 4)</samp></pre>
</section>
</section>
<section class="material__chapter">
<h2 id="5">Индексация в&nbsp;массивах</h2>
<p>Давайте рассмотрим массив 10&times;10, созданный ранее.</p>
<pre><code class="language-python">a = a.reshape(10,10)
</code></pre>
<pre><samp>array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
       [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
       [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
       [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
       [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
       [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
       [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])</samp></pre>
<p>В&nbsp;нем работает привычная индексация.</p>
<pre><code class="language-python">a[1][2] # =&gt; 12
       
a[2][1] # =&gt; 21 

a[5] # =&gt; array([50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
</code></pre>
<p>По&nbsp;аналогии со&nbsp;списками мы&nbsp;можем применять срезы:</p>
<pre><code class="language-python">a[3:5, 1:6]
# =&gt; array([[31, 32, 33, 34, 35], [41, 42, 43, 44, 45]])

a[:, 2:4]

# =&gt; array([[ 2,  3],
#           [12, 13],
#           [22, 23],
#           [32, 33],
#           [42, 43],
#           [52, 53],
#           [62, 63],
#           [72, 73],
#           [82, 83],
#           [92, 93]])
</code></pre>
<p>Кроме того, доступ можно организовать через списки с&nbsp;индексами:</p>
<pre><code class="language-python">a[[1], [4, 4, 7, 8]] # =&gt; array([14, 14, 17, 18])
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Но&nbsp;самой удобной альтернативой обычному способу является тот, в&nbsp;котором в&nbsp;качестве &laquo;адреса&raquo; элемента используется кортеж координат:</p>
<pre><code class="language-python">a[(7, 9)] # =&gt;  79
</code></pre>
</section>
<p>Скобки, конечно&nbsp;же, можно опустить:</p>
<pre><code class="language-python">a[7, 9] # =&gt; 79
</code></pre>
</section>
<section class="material__chapter">
<h2 id="6">Массовые операции</h2>
<p>Инициализация:</p>
<pre><code class="language-python"># заполняем единицами
np.ones(10)
</code></pre>
<pre><samp>array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])</samp></pre>
<pre><code class="language-python"># заполняем единицами целого типа
np.ones(10, dtype=np.int32) 
</code></pre>
<pre><samp>array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</samp></pre>
<pre><code class="language-python"># заполняем нулями и сразу указываем форму
np.zeros(30).reshape(5, 6) 
</code></pre>
<pre><samp>array([[ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.]])</samp></pre>
<pre><code class="language-python"># заполняем случайными целыми из диапазона [1..10)
# и сразу указываем форму
np.random.randint(1, 10, (5, 5)) 
</code></pre>
<pre><samp>array([[3, 1, 1, 5, 4],
       [5, 4, 8, 6, 3],
       [6, 9, 9, 3, 4],
       [7, 4, 2, 1, 9],
       [3, 5, 4, 2, 2]])</samp></pre>
<pre><code class="language-python"># заполняем случайными вещественными числами из диапазона [0..1)
np.random.random(10) 
</code></pre>
<pre><samp>array([ 0.96373978,  0.73252097,  0.32213768,  0.81560531,  0.31843467,
        0.51289493,  0.99791928,  0.5999641 ,  0.15257882,  0.16074567])</samp></pre>
<pre><code class="language-python"># формируем массив из строки чисел, указывая разделитель
np.fromstring("1, 3, 4, 5, 120", sep=",") 
</code></pre>
<pre><samp>array([   1.,    3.,    4.,    5.,  120.])</samp></pre>
<pre><code class="language-python"># каждый элемент массива вычисляется по функции
np.fromfunction(lambda x, y: x * 5 + y, (3, 5), dtype=np.int8)
</code></pre>
<pre><samp>array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]], dtype=int8)</samp></pre>
<p>Работают основные операции арифметики, сравнения, причем на&nbsp;всем массиве целиком. И&nbsp;это здорово!</p>
<pre><code class="language-python">a = np.random.randint(1, 5, 10)
b = np.random.randint(1, 5, 10)
print(a)
print(b)
</code></pre>
<pre><samp>[1 3 1 1 3 4 2 3 3 3]
[4 1 1 3 1 4 4 4 1 1]</samp></pre>
<pre><code class="language-python">print(a &gt; b)  # =&gt; [False True False False True False False False True True]
print(a + b)  # =&gt; [5 4 2 4 4 8 6 7 4 4]
print(a * b)  # =&gt; [ 4  3  1  3  3 16  8 12  3  3]
print(a ** 2)  # =&gt; [ 1  9  1  1  9 16  4  9  9  9]
print(a[a &gt; b])  # =&gt; [3 3 3 3]
print(a.sum())  # =&gt; 24
</code></pre>
<p>Тригонометрические операции тоже работают, только надо использовать их&nbsp;версии из&nbsp;библиотеки <var>numpy</var>, а&nbsp;не&nbsp;из&nbsp;<var>math</var>:</p>
<pre><code class="language-python">print(np.sin(a))
</code></pre>
<pre><samp>[ 0.84147098  0.14112001  0.84147098  0.84147098  0.14112001 -0.7568025
  0.90929743  0.14112001  0.14112001  0.14112001]</samp></pre>
<p>Вспомним начало этого урока, когда мы&nbsp;говорили о&nbsp;скорости работы.</p>
<p>Решим ту&nbsp;же задачу по&nbsp;вычислению 1&nbsp;000&nbsp;000&nbsp; корней с&nbsp;помощью Numpy и&nbsp;посмотрим, какого ускорения мы&nbsp;добились:</p>
<pre><code class="language-python">timeit.timeit("np.sqrt(np.arange(1000000))", "import numpy as np", number=1)
</code></pre>
<pre><samp>0.014551434993336443</samp></pre>
</section>
<section class="material__chapter">
<h2 id="7">Немного о&nbsp;матрицах</h2>
<p>Numpy позволяет очень эффективно работать с&nbsp;двумерными и&nbsp;вообще n-мерными массивами.</p>
<pre><code class="language-python"># Заполним матрицу "последовательно" по строкам
a = np.arange(1, 21).reshape(4, 5)
</code></pre>
<pre><samp>array([[ 1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10],
       [11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20]])</samp></pre>
<pre><code class="language-python"># Транспонируем матрицу (строки станут столбцами, а столбцы&nbsp;&mdash; строками)
b = a.transpose()
</code></pre>
<pre><samp>array([[ 1,  6, 11, 16],
       [ 2,  7, 12, 17],
       [ 3,  8, 13, 18],
       [ 4,  9, 14, 19],
       [ 5, 10, 15, 20]])</samp></pre>
<pre><code class="language-python"># Повернем матрицу вправо и влево
b = np.rot90(a)
c = np.rot90(a, -1)
print(b)
print(c)
</code></pre>
<pre><samp>[[ 5 10 15 20]
 [ 4  9 14 19]
 [ 3  8 13 18]
 [ 2  7 12 17]
 [ 1  6 11 16]]
[[16 11  6  1]
 [17 12  7  2]
 [18 13  8  3]
 [19 14  9  4]
 [20 15 10  5]]</samp></pre>
</section>
<section class="material__chapter">
<h2 id="8">Сортировки</h2>
<p>Библиотека Numpy предлагает свои функции по&nbsp;сортировке. Давайте посмотрим, как они работают:</p>
<pre><code class="language-python"># заполним матрицу случайными целыми числами
a = np.random.randint(20, size=(5, 4))
</code></pre>
<pre><samp>array([[ 2, 12,  0,  7],
       [12,  1, 11, 18],
       [ 6,  1,  4, 10],
       [ 0,  9,  5,  3],
       [18, 12, 12,  5]])</samp></pre>
<pre><code class="language-python"># отсортируем матрицу по умолчанию
print(np.sort(a))
</code></pre>
<pre><samp>[[ 0  2  7 12]
 [ 1 11 12 18]
 [ 1  4  6 10]
 [ 0  3  5  9]
 [ 5 12 12 18]]</samp></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>В&nbsp;этом случае сортировка происходит по&nbsp;<strong>последнему</strong> измерению. Обходя матрицу, мы&nbsp;сначала выбираем строку, а&nbsp;потом идем по&nbsp;этой строке, поэтому последнее измерение в&nbsp;данном случае&nbsp;&mdash; это строка. В&nbsp;результате мы&nbsp;отсортировали независимо каждую строку.</p>
</section>
<pre><code class="language-python"># а теперь укажем конкретное измерение
print(np.sort(a, axis=0))
</code></pre>
<pre><samp>[[ 0  1  0  3]
 [ 2  1  4  5]
 [ 6  9  5  7]
 [12 12 11 10]
 [18 12 12 18]]</samp></pre>
<p>Матрица отсортирована по&nbsp;столбцам.</p>
<p>Но&nbsp;самое интересное в&nbsp;том, что если в&nbsp;качестве значения параметра <var>axis</var> указать <var>None</var>, то&nbsp;матрица перед сортировкой будет линеаризована, то&nbsp;есть превращена в&nbsp;одномерный массив.</p>
<pre><code class="language-python">print(np.sort(a, axis=None))
</code></pre>
<pre><samp>[ 0  0  1  1  2  3  4  5  5  6  7  9 10 11 12 12 12 12 18 18]</samp></pre>
<p>Обратите внимание: подобное поведение характерно не&nbsp;только для функции <code>sort()</code>, но&nbsp;и&nbsp;для многих других функций: <code>min()</code>, <code>sum()</code> и&nbsp;т.&nbsp;д.</p>
<p>Но&nbsp;об&nbsp;этом вы&nbsp;можете почитать самостоятельно на&nbsp;странице с&nbsp;<a class="material__link" href="https://docs.scipy.org/doc/numpy/genindex.html" target="_blank" rel="noopener noreferrer">документацией</a>.</p>
</section>
<section class="material__chapter">
<h2 id="9">Вспомним PIL</h2>
<p>Работая с&nbsp;библиотекой PIL, тоже можно использовать средства Numpy.</p>
<p>Например, если мы&nbsp;хотим сделать изображение темнее оригинала, можем просто поделить его составляющие, например, на&nbsp;10:</p>
<pre><code class="language-python">from PIL import Image
import numpy as np

# получим массив numpy из картинки, которую откроем из файла.
image = np.asarray(Image.open('images/Риана.jpg'))
# поделим все элементы массива на 10, приведем к типу uint8 (один байт без знака)
# преобразуем в изображение и сохраним в файл
Image.fromarray(np.uint8(image // 10)).save('r2.jpg')
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/riana-numpy.jpeg" width="680" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="10">Игра &laquo;Жизнь&raquo;</h2>
<p>Несколько десятилетий назад Джон Конуэй придумал один из&nbsp;самых известных клеточных автоматов, который назвал игрой &laquo;Жизнь&raquo;. Простота правил сочетается в&nbsp;ней с&nbsp;богатством результатов. Многие компьютерные инженеры хоть раз обращались к&nbsp;программированию и&nbsp;исследованию этой игры, которая послужила интересной моделью для многих отраслей науки.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Клеточный автомат</strong></p>
<p>Клеточный автомат&nbsp;&mdash; модель однородного пространства с&nbsp;некоторыми клетками. Каждая клетка может находиться в&nbsp;одном из&nbsp;нескольких состояний и&nbsp;иметь некоторое количество соседей. Задаются правила перехода из&nbsp;одного состояния в&nbsp;другое в&nbsp;зависимости от&nbsp;текущего состояния клетки и&nbsp;ее&nbsp;соседей.</p>
<p>Пространство &laquo;Жизни&raquo;&nbsp;&mdash; бесконечное поле клеток.</p>
</section>
<p>Каждая клетка имеет 8&nbsp;соседей (сверху, снизу, справа, слева и&nbsp;по&nbsp;диагонали). Клетка может иметь два состояния&nbsp;&mdash; живое (на&nbsp;клетке стоит фишка) и&nbsp;мертвое (фишки нет).</p>
<p>Правила изменения следующие:</p>
<ul>
<li>Если клетка была живой, она выживет, если у&nbsp;нее 2&nbsp;или 3&nbsp;соседа. Если соседей 4, 5, 6, 7&nbsp;или&nbsp;8, она умирает от&nbsp;перенаселенности, а&nbsp;если 0&nbsp;или 1&nbsp;&mdash; от&nbsp;одиночества</li>
<li>Новая клетка рождается в&nbsp;поле, у&nbsp;которого есть ровно 3&nbsp;соседа</li>
</ul>
<p>Время в&nbsp;этой игре дискретно и&nbsp;считается поколениями. Все начинается с&nbsp;начальной расстановки фишек (0&nbsp;поколение), в&nbsp;дальнейшем рассматривается эволюция клеточного пространства в&nbsp;1, 2, 3&nbsp;и&nbsp;т.&nbsp;д. поколении. Процессы смерти и&nbsp;рождения происходят одновременно, после чего строится следующее поколение.</p>
<p>Давайте попробуем написать игру &laquo;Жизнь&raquo;, используя библиотеку Numpy. Пусть у&nbsp;нас будет поле 10&times;10, в&nbsp;центр которого поместим конструкцию, известную как глайдер. Мы&nbsp;скоро выясним, почему она так называется.</p>
<pre><code class="language-python">import numpy as np

population = np.array(
    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=np.uint8)
</code></pre>
<p>Поле имеет тип <var>uint8</var>, чтобы оно занимало меньше памяти. Каждый его элемент занимает ровно 1&nbsp;байт (8&nbsp;бит) и&nbsp;является целым беззнаковым (unsigned) числом в&nbsp;диапазоне от&nbsp;0&nbsp;до&nbsp;255.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Живые клетки обозначаются единицей, а&nbsp;мертвые&nbsp;&mdash; нулем. Нужно решить, что делать на&nbsp;границах поля. Мы&nbsp;не&nbsp;можем обеспечить бесконечность в&nbsp;обоих направлениях, поэтому замкнем поле само на&nbsp;себя. Если выйти за&nbsp;нижнюю границу, окажемся наверху, а&nbsp;если за&nbsp;правую&nbsp;&mdash; появимся слева, и&nbsp;наоборот. Получается что-то вроде бублика. Такая фигура называется тор.</p>
</section>
<p>Для начала познакомимся с&nbsp;операцией <var>roll</var>, доступной для массивов. Она сдвигает исходный массив вдоль одного из&nbsp;измерений (в&nbsp;данном случае&nbsp;&mdash; строки или столбца).</p>
<pre><code class="language-python">population
</code></pre>
<pre><samp>    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</samp></pre>
<pre><code class="language-python">np.roll(population, 2, 0)
</code></pre>
<pre><samp>    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</samp></pre>
<pre><code class="language-python">np.roll(population, 2, 1)
</code></pre>
<pre><samp>    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
           [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</samp></pre>
<p>Мы&nbsp;можем посчитать количество соседей у&nbsp;каждой клетки, просто сделав 8&nbsp;копий со&nbsp;сдвигом массива и&nbsp;просуммировав&nbsp;их.</p>
<pre><code class="language-python">neighbors = sum([
    np.roll(np.roll(population, -1, 1), 1, 0),
    np.roll(np.roll(population, 1, 1), -1, 0),
    np.roll(np.roll(population, 1, 1), 1, 0),
    np.roll(np.roll(population, -1, 1), -1, 0),
    np.roll(population, 1, 1),
    np.roll(population, -1, 1),
    np.roll(population, 1, 0),
    np.roll(population, -1, 0)
])
</code></pre>
<p>Таки образом, матрица количества соседей выглядит так:</p>
<pre><samp>    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
           [0, 0, 0, 1, 1, 2, 1, 0, 0, 0],
           [0, 0, 1, 3, 5, 3, 2, 0, 0, 0],
           [0, 0, 1, 1, 3, 2, 2, 0, 0, 0],
           [0, 0, 1, 2, 3, 2, 1, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</samp></pre>
<p>Теперь нужно получить новую популяцию.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Выполним на&nbsp;матрице следующую операцию: &laquo;если у&nbsp;клетки 3&nbsp;соседа, то&nbsp;в&nbsp;следующем поколении на&nbsp;этом месте будет клетка; а&nbsp;если 2&nbsp;&mdash; клетка будет при условии, что она была &bdquo;жива&ldquo; в&nbsp;текущем поколении&raquo;.</p>
<p>Для этого воспользуемся операторами&nbsp;<var>|</var> (или) и&nbsp;<var>&amp;</var> (и).</p>
</section>
<pre><code class="language-python"># выделим клетки, у которых ровно три соседа
neighbors == 3
</code></pre>
<pre><samp>    array([[False, False, False, False, False, False, False, False, False,
            False],
           [False, False, False, False, False, False, False, False, False,
            False],
           [False, False, False, False, False, False, False, False, False,
            False],
           [False, False, False, False, False, False, False, False, False,
            False],
           [False, False, False,  True, False,  True, False, False, False,
            False],
           [False, False, False, False,  True, False, False, False, False,
            False],
           [False, False, False, False,  True, False, False, False, False,
            False],
           [False, False, False, False, False, False, False, False, False,
            False],
           [False, False, False, False, False, False, False, False, False,
            False],
           [False, False, False, False, False, False, False, False, False,
            False]], dtype=bool)</samp></pre>
<pre><code class="language-python"># а теперь те, в которых была жизнь и имеется ровно два соседа
population &amp; (neighbors == 2)
</code></pre>
<pre><samp>    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</samp></pre>
<pre><code class="language-python"># и объединим их
population = (neighbors == 3) | (population &amp; (neighbors == 2))
population
</code></pre>
<pre><samp>    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 1, 0, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</samp></pre>
<p>Объединить матрицы с&nbsp;логическими и&nbsp;целочисленными элементами можно, поскольку они в&nbsp;данном случае могут быть сведены друг к&nbsp;другу: 0&nbsp;&mdash; False, 1&nbsp;&mdash; True.</p>
<p>Проследим эволюцию глайдера на&nbsp;протяжении четырех поколений. Для этого создадим функцию <code>next_population()</code>.</p>
<pre><code class="language-python">def next_population(population):
    neighbors = sum([
        np.roll(np.roll(population, -1, 1), 1, 0),
        np.roll(np.roll(population, 1, 1), -1, 0),
        np.roll(np.roll(population, 1, 1), 1, 0),
        np.roll(np.roll(population, -1, 1), -1, 0),
        np.roll(population, 1, 1),
        np.roll(population, -1, 1),
        np.roll(population, 1, 0),
        np.roll(population, -1, 0)
    ])
    return (neighbors == 3) | (population &amp; (neighbors == 2))


population = np.array(
    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=np.uint8)

for _ in range(4):
    print(population, '\n')
    population = next_population(population)
</code></pre>
<pre><samp>[[0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 1 0 0 0 0 0]
     [0 0 0 0 0 1 0 0 0 0]
     [0 0 0 1 1 1 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]] 
    
    [[0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 1 0 1 0 0 0 0]
     [0 0 0 0 1 1 0 0 0 0]
     [0 0 0 0 1 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]] 
    
    [[0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 1 0 0 0 0]
     [0 0 0 1 0 1 0 0 0 0]
     [0 0 0 0 1 1 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]] 
    
    [[0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 1 0 0 0 0 0]
     [0 0 0 0 0 1 1 0 0 0]
     [0 0 0 0 1 1 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]
     [0 0 0 0 0 0 0 0 0 0]]</samp></pre>
<p>С&nbsp;визуализацией у&nbsp;нас не&nbsp;очень здорово, но&nbsp;видно, что глайдер &laquo;летит&raquo;: каждые четыре поколения он&nbsp;сдвигается вниз и&nbsp;вправо. Иными словами, он&nbsp;движется в&nbsp;правый нижний угол, что демонстрирует красивая анимация <a class="material__link" href="https://ru.wikipedia.org/wiki/Игра_&laquo;Жизнь&raquo;" target="_blank" rel="noopener noreferrer">источника</a>.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/game-life.gif" width="500" height="auto" /></div>
<p>За&nbsp;время поисков были найдены разнообразные движущиеся комбинации, периодические комбинации, порождающие глайдеры (&laquo;глайдерные ружья&raquo;). Была даже доказана возможность построить в&nbsp;игре &laquo;Жизнь&raquo; универсальную вычислительную машину.</p>
<p><strong>Итоги</strong></p>
<p>Мы&nbsp;увидели, что значительную часть вычислений можно реализовывать в&nbsp;библиотеках, избавляясь от&nbsp;циклов в&nbsp;Python и&nbsp;ускоряя вычисления. Массивы Numpy&nbsp;&mdash; одна из&nbsp;самых востребованных структур в&nbsp;вычислительной математике.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>