<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Строки. Срезы </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Срезы</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Строки. Срезы</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Работа со&nbsp;строками (повторение)</a></li>
<li><a class="material__link" href="#2">Срезы строк</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;этом занятии мы&nbsp;продолжим отрабатывать навыки работы со&nbsp;строкой и&nbsp;познакомимся с&nbsp;новым методом извлечения подстроки&nbsp;&mdash; срезами.</p>
</section>
<section class="material__chapter">
<h2 id="1">Работа со&nbsp;строками (повторение)</h2>
<p>Рассмотрим еще одну задачу. Билет называют счастливым по-питерски, если сумма цифр его номера, стоящих на&nbsp;четных местах, равна сумме цифр, стоящих на&nbsp;нечетных местах. Нам необходимо написать программу, которая определяет, является&nbsp;ли билет счастливым по-питерски.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-11/11.svg" width="480" height="auto" /></div>
<p>Если рассматривать номер билета как строку из&nbsp;цифр, задача сводится к&nbsp;подсчету суммы цифр, стоящих на&nbsp;позициях 0, 2, 4..., и&nbsp;суммы цифр, стоящих на&nbsp;позициях 1, 3, 5... Чтобы перебрать элементы, мы&nbsp;можем воспользоваться конструкцией <code>for i&nbsp;in&nbsp;range(...)</code>, указав шаг 2. Тогда соответствующий фрагмент программы может выглядеть следующим образом:</p>
<pre><code class="language-python">number = input()
odd = even = 0
for i in range(0, len(number), 2):
    odd += int(number[i])
for i in range(1, len(number), 2):
    even += int(number[i])
if odd == even:
    print('Счастливый по-питерски!')
</code></pre>
<p>Подумайте, как можно решить данную задачу за&nbsp;один цикл.</p>
</section>
<section class="material__chapter">
<h2 id="2">Срезы строк</h2>
<p>На&nbsp;примере разобранной задачи мы&nbsp;увидели, что перебор элементов строки с&nbsp;помощью конструкции <code>for i&nbsp;in&nbsp;range(...)</code> является достаточно гибким: можно перебрать не&nbsp;все индексы, можно идти с&nbsp;шагом, скажем, 2&nbsp;или даже &minus;1, то&nbsp;есть в&nbsp;обратном порядке. Но&nbsp;существует способ без всякого цикла преобразовать строку нужным образом: взять отдельный ее&nbsp;кусок, символы с&nbsp;нечетными номерами и&nbsp;т.&nbsp;д. Этот способ&nbsp;&mdash; <strong>срез (slice)</strong>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Срез строки</strong></p>
<p>В&nbsp;самом простом варианте срез строки&nbsp;&mdash; ее&nbsp;кусок от&nbsp;одного индекса включительно и&nbsp;до&nbsp;другого не&nbsp;включительно (как для <var>range</var>). То&nbsp;есть это новая, более короткая строка.</p>
<p>Срез записывается с&nbsp;помощью квадратных скобок, в&nbsp;которых указывается начальный и&nbsp;конечный индекс, разделенные двоеточием.</p>
</section>
<pre><code class="language-python">text = 'Hello, world!'
print(text[0:5])
print(text[7:12])
</code></pre>
<p>Если не&nbsp;указан <strong>начальный индекс</strong>, срез берется от&nbsp;начала (от&nbsp;0). Если не&nbsp;указан <strong>конечный индекс</strong>, срез берется до&nbsp;конца строки. Попробуйте предположить, что будет выведено на&nbsp;экран, если в&nbsp;предыдущей программе записать срезы следующим образом:</p>
<pre><code class="language-python">text = 'Hello, world!'
print(text[:5])
print(text[7:])
</code></pre>
<p><strong>Разрешены отрицательные индексы</strong> для отсчета с&nbsp;конца списка. В&nbsp;следующем примере из&nbsp;строки, содержащей фамилию, имя и&nbsp;отчество, будет извлекаться фамилия.</p>
<pre><code class="language-python">full_name = 'Иванов И. И.'
surname = full_name[:-6]
</code></pre>
<p>Как и&nbsp;для <var>range</var>, в&nbsp;параметры среза можно добавить третье число&nbsp;&mdash; <strong>шаг обхода</strong>. Этот параметр не&nbsp;является обязательным и&nbsp;записывается через второе двоеточие. Вот как может выглядеть программа &laquo;Счастливый билет&raquo;, если решать ее&nbsp;с&nbsp;помощью срезов:</p>
<pre><code class="language-python">number = input()
odd = even = 0

# срез будет от начала строки до конца с шагом два: 0, 2, 4,... 
for n in number[::2]:  
    odd += int(n)

# срез от второго элемента строки до конца с шагом два: 1, 3, 5,...
for n in number[1::2]: 
    even += int(n)

if odd == even:
    print('Счастливый по-питерски!')
</code></pre>
<p>Интересное отличие среза от&nbsp;обращения по&nbsp;индексу к&nbsp;отдельному элементу состоит в&nbsp;том, что мы&nbsp;не&nbsp;получим ошибку при указании границ среза за&nbsp;пределами строки. В&nbsp;срез в&nbsp;таком случае попадут только те&nbsp;элементы, которые находятся по&nbsp;валидным индексам среза:</p>
<pre><code class="language-python">a = 'Python'
print(a[2:10000]) # thon
print(a[999:]) # пустая строка
</code></pre>
<p><strong>Шаг может быть и&nbsp;отрицательным</strong>&nbsp;&mdash; для прохода по&nbsp;строке в&nbsp;обратном порядке. Если в&nbsp;этом случае не&nbsp;указать начальный и&nbsp;конечный индекс среза, ими станут последний и&nbsp;первый индексы строки соответственно (а&nbsp;не&nbsp;наоборот, как при положительном шаге):</p>
<pre><code class="language-python">text = 'СЕЛ В ОЗЕРЕ БЕРЕЗОВ ЛЕС'
text_reversed = text[::-1]
print(text == text_reversed)
</code></pre>
<p>Итак, с&nbsp;помощью квадратных скобок можно получить доступ как к&nbsp;одному символу строки, так и&nbsp;к&nbsp;некоторой последовательности символов, причем совсем необязательно идущих подряд!</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>