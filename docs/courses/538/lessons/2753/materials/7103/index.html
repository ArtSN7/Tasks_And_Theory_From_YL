<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Функции </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Функции</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Функции</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Среда разработки PyCharm</a></li>
<li><a class="material__link" href="#2">Функция как способ группировать команды и&nbsp;именовать участки кода</a></li>
<li><a class="material__link" href="#3">Определение простейших функций</a></li>
<li><a class="material__link" href="#4">Начальные знания о&nbsp;локальных переменных</a></li>
<li><a class="material__link" href="#5">Аргументы функций</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Второе полугодие мы&nbsp;начнем с&nbsp;перехода на&nbsp;новую интегрированную среду разработку PyCharm. Эта среда динамично развивается, постоянно обновляется и&nbsp;предоставляет расширенную функциональность, которая в&nbsp;дальнейшем потребуется нам при решении задач.</p>
<p>Сегодня мы&nbsp;поговорим о&nbsp;том, как группировать команды в&nbsp;функции&nbsp;&mdash; участки кода, которые можно использовать многократно. Обсудим, как можно сделать так, чтобы код функции работал по-разному в&nbsp;зависимости от&nbsp;параметров. Наконец, коснемся вопроса, что представляют собой локальные переменные.</p>
</section>
<section class="material__chapter">
<h2 id="1">Среда разработки PyCharm</h2>
<p>Для программирования на&nbsp;Python можно использовать различные среды разработки: так, в&nbsp;первом полугодии мы&nbsp;работали в&nbsp;Wing IDE, которая очень хороша для старта. В&nbsp;этом полугодии мы&nbsp;познакомимся с&nbsp;другой средой, которая наиболее распространена в&nbsp;профессиональном сообществе,&nbsp;&mdash; PyCharm, созданной компанией JetBrains. Ее&nbsp;отличает значительный прогресс в&nbsp;развитии, наличие постоянных обновлений и&nbsp;широкое распространение на&nbsp;таких операционных системах, как Windows, MacOS, Linux.</p>
<p>PyCharm доступна в&nbsp;двух основных вариантах: платный выпуск Professional и&nbsp;бесплатный Community. Мы&nbsp;будем использовать бесплатную версию, в&nbsp;которой доступны все необходимые в&nbsp;рамках нашего курса возможности.</p>
<p>Для этого перейдем на&nbsp;<span style="text-decoration: underline; color: #0000ff;"><a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener noreferrer">страницу загрузки</a></span> и&nbsp;загрузим установочный файл PyCharm Community. После загрузки выполним его установку.</p>
<p>Далее запустим программу. При первом запуске открывается начальное окно:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-18/pycharm1.png" width="680" height="auto" /></div>
<p><strong>Шаг&nbsp;1.</strong> Откройте/создайте проект в&nbsp;PyCharm</p>
<p>А&nbsp;зачем вообще нужны проекты? Дело в&nbsp;том, что все, что вы&nbsp;делаете в&nbsp;PyCharm, выполняется в&nbsp;контексте проекта. Он&nbsp;служит основой для поддержки кодирования, переработки кода, согласованности стиля кодирования и&nbsp;т.&nbsp;д. Кроме того, вы, наверное, догадываетесь, что сложные проекты могут делиться на&nbsp;части (в&nbsp;терминологии Python&nbsp;&mdash; модули, но&nbsp;об&nbsp;этом позднее), которые реализовываются разными разработчиками. Концепция организации программного кода в&nbsp;проекты позволяет сделать такое взаимодействие более удобным.</p>
<p>У&nbsp;вас есть два варианта начать работу над проектом внутри среды IDE:</p>
<p>1. Открыть существующий проект</p>
<p>Начните, открыв один из&nbsp;своих проектов, хранящихся на&nbsp;вашем компьютере. Папку с&nbsp;вашими решениями можно рассматривать как проект. Вы&nbsp;можете это сделать, нажав <strong>Открыть проект (Open)</strong> на&nbsp;экране приветствия (или <strong>File&nbsp;&rarr;&nbsp;Open</strong>).</p>
<p>2. Создать проект с&nbsp;нуля</p>
<p>Если вы&nbsp;предпочитаете начинать с&nbsp;нуля, нажмите <strong>New Project</strong>, на&nbsp;открывшемся экране введите местоположение проекта или выберите его в&nbsp;диалоговом окне (название конечной папки принято считать именем проекта). Нажмите кнопку <strong>Create</strong>, после чего будет создан проект Python.</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-18/pycharm3.png" width="680" height="auto" /></div>
<p><strong>Шаг&nbsp;2.</strong> Знакомство с&nbsp;интерфейсом</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-18/pycharm-4.png" width="680" height="auto" /></div>
<ol>
<li><strong>Project Tool Window.</strong> Панель инструментов проекта. В&nbsp;этом окне отображаются файлы вашего проекта.</li>
<li><strong>PyCharm Editor.</strong> Редактор PyCharm. Находится с&nbsp;правой стороны, где вы&nbsp;пишете свой код. В&nbsp;нем есть вкладки для удобной навигации между открытыми файлами.</li>
<li><strong>Navigation Bar.</strong> Панель навигации. Находится над редактором, позволяет быстро запускать и&nbsp;отлаживать ваше приложение.</li>
<li><strong>Left gutter.</strong> Левый столбец, вертикальная полоса рядом с&nbsp;редактором, показывает точки остановки и&nbsp;обеспечивает удобный способ перехода по&nbsp;иерархии кода.</li>
<li><strong>Right gutter.</strong> Правый столбец, справа от&nbsp;редактора. PyCharm постоянно контролирует качество кода и&nbsp;постоянно показывает результаты проверки в&nbsp;правом столбце: ошибки, предупреждения и&nbsp;т.&nbsp;д. Тут&nbsp;же вы&nbsp;можете отслеживать соответствие вашего кода стандарту PEP&nbsp;8. Индикатор в&nbsp;правом верхнем углу показывает общий статус проверки кода для всего файла.</li>
<li><strong>PyCharm Tool Windows.</strong> Панель инструментов PyCharm. Это специальные окна, прикрепленные к&nbsp;низу и&nbsp;сторонам рабочей области, которые обеспечивают доступ к&nbsp;типичным задачам, таким как управление проектами, поиск и&nbsp;навигация по&nbsp;исходному коду, интеграция с&nbsp;системами контроля версий и&nbsp;т.&nbsp;д.</li>
<li><strong>Status Bar.</strong> Строка состояния. Указывает состояние вашего проекта и&nbsp;показывает различные предупреждения и&nbsp;информационные сообщения.</li>
</ol>
<p>У&nbsp;PyCharm есть гибкая система настройки интерфейса и&nbsp;даже возможность задания собственного стиля кода. Но&nbsp;сейчас мы&nbsp;не&nbsp;будем останавливаться на&nbsp;этом, а&nbsp;перейдем непосредственно к&nbsp;написанию программ.</p>
</section>
<section class="material__chapter">
<h2 id="2">Функция как способ группировать команды и&nbsp;именовать участки кода</h2>
<p>Работа любой компьютерной программы&nbsp;&mdash; это выполнение процессором большого набора элементарных инструкций. В&nbsp;машинном коде, с&nbsp;которым работает процессор, все команды очень простые:</p>
<ul>
<li>Считать из&nbsp;оперативной памяти одно целое число в&nbsp;специальную ячейку</li>
<li>Прибавить к&nbsp;одному числу значение другой ячейки</li>
<li>Сравнить ячейку с&nbsp;нулем</li>
<li>Вернуться на&nbsp;пару команд назад и&nbsp;пр.</li>
</ul>
<p>Команды машинного кода не&nbsp;могут вывести окошко программы или проиграть аудиофайл, не&nbsp;могут посчитать среднюю оценку в&nbsp;классе или загрузить страничку из&nbsp;Интернета. Машинный код не&nbsp;умеет полноценно работать даже с&nbsp;обычными строками или списками и&nbsp;не&nbsp;может выполнять сложные математические расчеты. Однако программа целиком все это делает, потому что состоит из&nbsp;множества команд, которые в&nbsp;комбинации дают нужный эффект.</p>
<p>Многие из&nbsp;команд Python, которые вы&nbsp;уже знаете, требуют от&nbsp;процессора выполнения десятков команд. Если&nbsp;бы программист писал их&nbsp;вручную, даже простейшие программы&nbsp;&mdash; вроде наших учебных заданий&nbsp;&mdash; создавались&nbsp;бы несколько дней. При этом даже опытному программисту было&nbsp;бы очень легко допустить ошибку.</p>
<p>В&nbsp;качестве мотивирующего примера рассмотрим программу, в&nbsp;которой последовательно запрашивается имя, а&nbsp;затем выводится приветствие по&nbsp;имени для трех живых существ:</p>
<pre><code class="language-python">print('Как тебя зовут?')
name_1 = input()
print('Привет', name_1)
print('А тебя?')
name_2 = input()
print('Привет', name_2)
print('А твоего пса?')
name_3 = input()
print('Привет', name_3)
</code></pre>
<pre><samp>Как тебя зовут?
Вася
Привет Вася
А тебя?
Коля
Привет Коля
А твоего пса?
Шарик
Привет Шарик</samp></pre>
<p>Программа небольшая, но&nbsp;уже видно много проблем:</p>
<ul>
<li>Во-первых, три раза приходится повторять фактически одно и&nbsp;то&nbsp;же</li>
<li>Во-вторых, приходится вводить разные имена переменных, чтобы ничего не&nbsp;перепутать и&nbsp;не&nbsp;поприветствовать кого-нибудь неправильным именем</li>
<li>В-третьих, если вы&nbsp;захотите исправить приветствие на&nbsp;более официальное&nbsp;&mdash; например, &laquo;Здравствуйте&raquo;, вам придется внести одинаковые исправления сразу в&nbsp;трех разных местах</li>
</ul>
<p>Даже в&nbsp;такой маленькой программе можно при исправлении допустить опечатку. А&nbsp;представьте, что фраза используется десять раз в&nbsp;разных местах большой программы&nbsp;&mdash; тогда придется искать каждое приветствие и&nbsp;исправлять его.</p>
<p>Было&nbsp;бы здорово иметь возможность устранить дублирование кода: в&nbsp;каком-то одном месте сообщить интерпретатору, что именно мы&nbsp;понимаем под словом &laquo;поприветствовать&raquo;, а&nbsp;затем попросить интерпретатор использовать определение термина &laquo;поприветствовать&raquo; там, где мы&nbsp;его попросим об&nbsp;этом.</p>
<p>Итак, сформулируем, чего мы&nbsp;хотим добиться:</p>
<ul>
<li><strong>Один раз</strong> определить, что значит &laquo;поприветствовать&raquo;, т.&nbsp;е. сгруппировать и&nbsp;поименовать повторяющийся кусок кода</li>
<li><strong>Многократно</strong> в&nbsp;дальнейшем &laquo;ссылаться&raquo; на&nbsp;это определение везде, где нам только потребуется</li>
</ul>
<p>Замечательно, что язык Python действительно обладает такими выразительными возможностями&nbsp;&mdash; <strong>функциями</strong>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функция</strong></p>
<p>Функция&nbsp;&mdash; особым образом сгруппированный набор команд, которые выполняются последовательно, но&nbsp;воспринимаются как единое целое. При этом функция может возвращать (или не&nbsp;возвращать) свой результат.</p>
</section>
<p>Для того чтобы использовать какую-нибудь собственную функцию, вначале необходимо ее&nbsp;<strong>объявить</strong>, т.&nbsp;е. рассказать, что именно она будет делать. В&nbsp;нашем примере мы&nbsp;объявим функцию <var>greet</var> с&nbsp;помощью ключевого слова <var>def</var>, после которого идет название нашей функции, скобки, двоеточие, а&nbsp;затем на&nbsp;двух последующих строчках&nbsp;&mdash; описание того, что она собой представляет:</p>
<pre><code class="language-python">def greet():
    name = input()
    print('Привет', name)
</code></pre>
<p>Обратите внимание: это описание расположено в&nbsp;блоке кода с&nbsp;отступом.</p>
<p>Далее мы&nbsp;можем использовать нашу функцию <var>greet</var> всякий раз, когда в&nbsp;нашем коде возникает необходимость кого-нибудь поприветствовать:</p>
<pre><code class="language-python">print('Как тебя зовут?')
greet()

print('А тебя?')
greet()

print('А твоего пса?')
greet()
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Вызов функции</strong></p>
<p>Обращение к&nbsp;ранее объявленной функции с&nbsp;целью выполнения ее&nbsp;команд называется вызовом.</p>
</section>
<p>В&nbsp;нашем примере функция <var>greet</var> один раз объявляется, а&nbsp;затем три раза вызывается.</p>
<p>Что мы&nbsp;получили в&nbsp;результате:</p>
<ol>
<li>Код сократился и&nbsp;стал понятнее. Теперь нам не&nbsp;нужно выискивать, где какая переменная заводится, где и&nbsp;для чего она используется. Функция сама говорит, что она делает: <var>greet</var>&nbsp;&mdash; &laquo;поприветствовать&raquo;.</li>
<li>Нам не&nbsp;приходится заводить несколько разных переменных.</li>
<li>Чтобы поменять приветствие во&nbsp;всей программе, достаточно изменить одну строчку.</li>
</ol>
<p>Итак, функции нужны, чтобы группировать команды, а&nbsp;заодно&nbsp;&mdash; чтобы не&nbsp;писать один и&nbsp;тот&nbsp;же код несколько раз.</p>
<p>Например, достаточно один раз написать функцию <var>greet</var> и&nbsp;потом пользоваться ею&nbsp;постоянно. Польза от&nbsp;этого особенно очевидна, когда функция действительно сложная и&nbsp;используется много раз в&nbsp;разных местах программы. Например, загрузку данных из&nbsp;Интернета или отрисовку персонажа компьютерной игры удобно оформлять в&nbsp;виде отдельных функций.</p>
<p>Еще одна важная вещь состоит в&nbsp;том, что функции имеют <strong>имена</strong>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>PEP&nbsp;8</strong></p>
<p>Имена функций должны состоять из&nbsp;маленьких букв, а&nbsp;слова разделяться символами подчеркивания, это необходимо, чтобы увеличить читабельность.</p>
</section>
<p>Благодаря им&nbsp;программу можно сделать понятной не&nbsp;только компьютеру, но&nbsp;и&nbsp;человеку. Тут все так&nbsp;же, как с&nbsp;именами переменных: если переменная имеет ничего не&nbsp;говорящее название, сложно угадать, что в&nbsp;ней хранится. Если участок кода не&nbsp;сгруппирован в&nbsp;функцию, иногда приходится буквально дешифрировать, для чего он&nbsp;нужен в&nbsp;программе. А&nbsp;если он&nbsp;оформлен в&nbsp;виде функции, название функции само подскажет, что делает этот код.</p>
<p>Проиллюстрируем сказанное на&nbsp;примере. Попробуйте угададать, что делает такой код:</p>
<pre><code class="language-python">t = [-5, -10, 1, 11, 20, 25, 27, 23, 18, 8, 2, -3]
s = 0
mm = 1000
mx = -1000
for e in t:
    s += e
    if e &lt; mm:
        mm = e
    if e &gt; mx:
        mx = e
print(s / len(t))
print(mm)
print(mx)
</code></pre>
<p>После некоторых нетривиальных усилий по&nbsp;дешифровке можно понять, что этот код вычисляет среднее, минимальное и&nbsp;максимальное значение списка:</p>
<pre><samp>9.75
-10
27</samp></pre>
<p>А&nbsp;вот тот&nbsp;же самый код, но&nbsp;переработанный с&nbsp;помощью встроенных функций и&nbsp;хороших названий переменных:</p>
<pre><code class="language-python">temperatures = [-5, -10, 1, 11, 20, 25, 27, 23, 18, 8, 2, -3]
average_temperature = sum(temperatures) / len(temperatures)

print(average_temperature)
print(min(temperatures))
print(max(temperatures))
</code></pre>
<pre><samp>9.75
-10
27</samp></pre>
<p>Какой вариант вам нравится больше?</p>
<p>На&nbsp;самом деле, когда программист думает о&nbsp;том, что должна делать программа, он&nbsp;обычно представляет ее&nbsp;как раз в&nbsp;форме функций. Мы&nbsp;обычно не&nbsp;говорим, какие действия должен выполнить алгоритм, а&nbsp;описываем, что мы&nbsp;хотим получить. Например, мы&nbsp;хотим посчитать среднегодовую температуру, значит, нам нужна функция вычисления среднего значения из&nbsp;набора чисел.</p>
</section>
<section class="material__chapter">
<h2 id="3">Определение простейших функций</h2>
<p>Давайте подытожим&nbsp;то, что мы&nbsp;знаем о&nbsp; функциях.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Заголовок и тело функции</strong></p>
<p>У&nbsp;каждой функции есть заголовок (его обычно называют сигнатурой) и&nbsp;тело.</p>
<p>Сигнатура описывает, как функцию вызывать, а&nbsp;тело описывает, что эта функция делает.</p>
<p>Сигнатура содержит имя функции и&nbsp;аргументы (то&nbsp;есть параметры), которые передаются в&nbsp;функцию.</p>
</section>
<p>Записывается это так:</p>
<pre><code class="language-python">def &lt;имя функции&gt;([аргументы]):
    &lt;тело функции&gt;
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Тело функции, как и&nbsp;в&nbsp;операторе <var>if</var>&nbsp;или в&nbsp;операторе цикла, обязательно идет с&nbsp;<strong>отступом</strong>. Это нужно, чтобы интерпретатор Python знал, где заканчивается код функции. Заодно это здорово помогает структурировать программу. Даже в&nbsp;языках, где отступы не&nbsp;требуются, их&nbsp;все равно принято писать, чтобы упростить чтение программы.</p>
</section>
<p>Давайте напишем еще одну совсем простую функцию из&nbsp;одной единственной команды, которая просто выводит на&nbsp;экран приветствие.</p>
<pre><code class="language-python">def simple_greetings():
    print('Привет!')
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Вызов функции</strong></p>
<p>Теперь, чтобы поприветствовать пользователя, вам достаточно в&nbsp;основной программе написать: <code>simple_greetings()</code>. Это называется &laquo;вызвать функцию&raquo;.</p>
<p>Обратите внимание: у&nbsp;этой функции нет аргументов ни&nbsp;в&nbsp;определении, ни&nbsp;при вызове. Однако пустые скобочки после названия функции писать все равно нужно.</p>
</section>
<p>Функцию, как и&nbsp;переменную, необходимо сначала объявить, и&nbsp;только потом использовать. Поэтому следующая программа выдаст вам ошибку <code>name &rsquo;simple_greetings2&prime; is&nbsp;not defined</code>.</p>
<pre><code class="language-python">simple_greetings2()


def simple_greetings2():
    print('Привет, username!')
</code></pre>
<pre><samp>NameError                  Traceback (most recent call last)
&lt;ipython-input-12-4f64c3fab903&gt; in &lt;module&gt;()
----&gt; 1 simple_greetings2()
      2 
      3 
      4 def simple_greetings2():
      5     print('Привет, username!')

NameError: name 'simple_greetings2' is not defined</samp></pre>
<p>Впрочем, от&nbsp;такой функции проку не&nbsp;очень много: она не&nbsp;сокращает количество кода и&nbsp;не&nbsp;сильно упрощает понимание происходящего в&nbsp;программе. Поэтому в&nbsp;виде функции стоит оформлять только логически законченный блок кода, особенно если он&nbsp;необходим в&nbsp;нескольких местах программы.</p>
<section class="material__note">
<p class="material__note-heading"><strong>PEP&nbsp;8</strong></p>
<p>После функции до&nbsp;кода, который находится вне функции, необходимо делать отступ в&nbsp;две пустые строки для повышения читаемости кода. Если у&nbsp;вас есть несколько функций в&nbsp;одном файле, между кодом одной и&nbsp;сигнатурой другой функции тоже надо оставлять две пустые строки.</p>
</section>
<p>А&nbsp;теперь&nbsp;то, что заставит вас полюбить новую среду разработки еще сильнее: PyCharm умеет в&nbsp;автоматическом режиме исправлять часть недочетов кода, связанных в&nbsp;основном с&nbsp;отступами, пропущенными или лишними пробелами. Для автоформатирования кода по&nbsp;PEP&nbsp;8&nbsp;можно нажать комбинацию клавиш Ctrl + Alt + l.</p>
<p>Обратите внимание на&nbsp;некоторые особенности, которые существуют при сдаче в&nbsp;LMS задач на&nbsp;функции:</p>
<ol>
<li>В&nbsp;LMS необходимо отправить файл только с&nbsp;необходимой функцией. Если в&nbsp;файле есть код вызова данной функции, закомментируйте его. В&nbsp;PyCharm можно выделить код, который необходимо закомментировать, и&nbsp;нажать Ctrl + /. Для раскомментирования надо повторить то же самое.</li>
<li>При проверке функции тестирующая система запускает программу на&nbsp;Python, которая осуществляет вызов вашей функции (с&nbsp;передачей в&nbsp;нее параметров), поэтому необходимо точно соблюсти формат сигнатуры функции, который дается в&nbsp;условии.</li>
</ol>
</section>
<section class="material__chapter">
<h2 id="4">Начальные знания о&nbsp;локальных переменных</h2>
<p>В&nbsp;тот момент, когда вы&nbsp;вызываете функцию <var>greet</var>, начинают выполняться команды, написанные в&nbsp;теле функции. Когда работа функции доходит до&nbsp;конца, исполнение программы продолжается со&nbsp;строки, которая вызывала функцию. Мы&nbsp;еще посмотрим на&nbsp;этот процесс подробнее с&nbsp;помощью отладчика.</p>
<p>Обратите внимание: теперь в&nbsp;программе используется только одна переменная&nbsp;&mdash; <var>name</var>. Как&nbsp;же&nbsp;так? Ведь мы&nbsp;договорились, что не&nbsp;будем использовать одну и&nbsp;ту&nbsp;же&nbsp;переменную для разных имен? На&nbsp;самом деле мы&nbsp;не&nbsp;используем одну и&nbsp;ту&nbsp;же&nbsp; переменную. При каждом вызове функции эта переменная создается заново, а&nbsp;в&nbsp;конце работы функции&nbsp;&mdash; прекращает свое существование. Это очень важный момент.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Область видимости переменной</strong></p>
<p>Снаружи функции <var>greet</var> переменная <var>name</var> вообще не&nbsp;существует. Таким образом, функция очерчивает тот участок программы, где переменная нужна и&nbsp;используется. Этот участок, в&nbsp;котором переменная <strong>живет</strong>, называется областью видимости переменной (по-английски&nbsp;&mdash; <em>scope</em>).</p>
</section>
<p>Благодаря ограничению области видимости переменной программисту не&nbsp;нужно беспокоиться, не&nbsp;&laquo;всплывет&raquo;&nbsp;ли эта переменная в&nbsp;другом месте программы. Изменяя переменную внутри функции, программист понимает, что он&nbsp;может что-то испортить <strong>только внутри</strong> функции, но&nbsp;не&nbsp;поломает работу остальной программы. Можно сказать, что вся работа с&nbsp;переменной локализована, т.&nbsp;е. сосредоточена внутри функции.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Локальные и глобальные переменные</strong></p>
<p>Переменные, создаваемые внутри функций, недоступны извне и&nbsp;существуют только внутри функции. Они называются локальными.</p>
<p>Создаваемые вне функции переменные могут быть доступны из&nbsp;функций. Они являются глобальными.</p>
</section>
<p>По&nbsp;возможности избегайте использования глобальных переменных для предотвращения конфликтов. О&nbsp;локальных переменных и&nbsp;областях видимости мы&nbsp;поговорим намного подробнее на&nbsp;следующих уроках.</p>
</section>
<section class="material__chapter">
<h2 id="5">Аргументы функций</h2>
<p>Мы&nbsp;рассмотрели функции, которые выполняют всякий раз одни и&nbsp;те&nbsp;же действия. Это бывает полезно, но&nbsp;все&nbsp;же большая часть программ требует выполнения немного разных действий.</p>
<p>Например, функция <var>print</var> (а&nbsp;это именно функция) должна каждый раз выводить на&nbsp;экран разные сообщения&nbsp;&mdash; в&nbsp;зависимости от&nbsp;переданных аргументов.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Аргументы функций</strong></p>
<p>Аргументы (параметры) могут изменять поведение функции. Например, функция <var>len</var> принимает строки или списки (и&nbsp;другие коллекции). В&nbsp;зависимости от&nbsp;конкретного аргумента она возвращает разный результат, а&nbsp;значит, выполняет внутри немного различные действия.</p>
</section>
<p>Рассмотрим функцию, которая должна выводить на&nbsp;экран содержимое списка, печатая каждый элемент на&nbsp;своей строчке. Вряд&nbsp;ли нам захочется заводить функцию, которая раз за&nbsp;разом выводит содержимое одного и&nbsp;того&nbsp;же&nbsp;списка. Скорее, нужна функция, которая может распечатать любой список. Конкретный список мы&nbsp;передаем функции в&nbsp;качестве параметра при ее&nbsp;вызове. Функция&nbsp;же работает с&nbsp;тем, что ей&nbsp;передали. Выглядит это так:</p>
<pre><code class="language-python">def print_array(array):
    for element in array:
        print(element)


print_array(['Hello', 'world'])
print()
print_array([123, 456, 789])
</code></pre>
<pre><samp>Hello
world

123
456
789</samp></pre>
<p>При первом вызове функции <var>print_array</var> переменная <var>array</var> будет равна <code>['Hello', 'world']</code>. При втором вызове переменная <var>array</var> будет равна <code>[123, 456, 789]</code>.</p>
<p>Разберемся, в&nbsp;каком порядке выполняется код при вызове функций. В&nbsp;примере:</p>
<pre><code class="language-python">print_array(['Hello'] + ['world'])
</code></pre>
<p>ничего удивительного не&nbsp;происходит&nbsp;&mdash; списки складываются, а&nbsp;затем передаются в&nbsp;функцию.</p>
<pre><samp>Hello
world</samp></pre>
<p>Давайте рассмотрим более сложный пример:</p>
<pre><code class="language-python">def print_hello(arg_1, arg_2):
    print('hello')


def print_comrade():
    print('comrade')


def print_petrov():
    print('Petrov')


print_hello(print_comrade(), print_petrov())
</code></pre>
<p>Аргументы в&nbsp;функции <var>print_hello</var> никак не&nbsp;используются, но&nbsp;сейчас это неважно. Рассмотрим, в&nbsp;каком порядке выполняются функции.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>В&nbsp;момент вызова функции ей&nbsp;необходимо передать вычисленные аргументы. Если аргументы не&nbsp;вычислены, они вычисляются слева направо.</p>
</section>
<p>В&nbsp;данном случае функция <var>print_hello</var> принимает аргумент <var>arg_1</var>, который является значением функции <var>print_comrade</var> (по умолчанию&nbsp;&mdash; <var>None</var>), и&nbsp;аргумент <var>arg_2</var>, который является значением функции <var>print_petrov</var>. Таким образом, сначала выполнится функция <var>print_comrade</var>, затем <var>print_petrov</var> и&nbsp;лишь в&nbsp;самом конце <var>print_hello</var>. Результатом работы программы будет напечатанный текст:</p>
<pre><samp>comrade 
Petrov 
hello</samp></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>