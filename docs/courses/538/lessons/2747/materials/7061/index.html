<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Кортежи. Преобразование коллекций </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Кортежи</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Кортежи. Преобразование коллекций</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Кортежи</a></li>
<li><a class="material__link" href="#2">Присваивание кортежей</a></li>
<li><a class="material__link" href="#3">Сортировка пузырьком</a></li>
<li><a class="material__link" href="#4">Преобразования между коллекциями</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;уроке вводится еще один контейнер&nbsp;&mdash; кортеж (<var>tuple</var>). Более подробно рассматривается операция присваивания кортежей, знакомая нам по&nbsp;конструкции&nbsp;<code>a,&nbsp;b&nbsp;=&nbsp;b,&nbsp;a</code>, и&nbsp;применение этой операции в&nbsp;реализации классического алгоритма&nbsp;&mdash; сортировки пузырьком. Рассматриваются и&nbsp;вопросы преобразования одной коллекции в&nbsp;другую.</p>
</section>
<section class="material__chapter">
<h2 id="1">Кортежи</h2>
<p>Мы&nbsp;уже знаем такие коллекции, как списки, множества и&nbsp;строки. Сегодня мы&nbsp;рассмотрим еще один тип данных, являющийся коллекцией, который называется <var>tuple</var> (читается &laquo;тюпл&raquo; или &laquo;тьюпл&raquo;, а&nbsp;переводится как &laquo;кортеж&raquo;).</p>
<section class="material__note">
<p class="material__note-heading"><strong>Кортежи</strong></p>
<p>Кортежи очень похожи на&nbsp;списки, они тоже являются индексированной коллекцией, только вместо квадратных в&nbsp;них используются круглые скобки (причем их часто можно пропускать):</p>
<pre><code class="language-python"># кортеж из двух элементов; тип элементов может быть любой
card = ('7', 'пик')           
          
# пустой кортеж (из 0 элементов)
empty = ()
 
# кортеж из 1 элемента - запятая нужна, чтобы отличить от обычных скобок
t = (18,)

# длина, значение отдельного элемента, сложение - как у списков
print(len(card), card[0], card + t)
</code></pre>
</section>
<p>Кортежи можно сравнивать между собой:</p>
<pre><code class="language-python">(1, 2) == (1, 3)    # False
(1, 2) &lt; (1, 3)     # True
(1, 2) &lt; (5,)       # True
('7', 'червей') &lt; ('7', 'треф')    # False

# А вот так сравнивать нельзя: элементы кортежей разных типов
(1, 2) &lt; ('7', 'пик') 
</code></pre>
<p>Обратите внимание: операции <code>==</code> и <code>!=</code> применимы к&nbsp;любым кортежам, независимо от&nbsp;типов элементов. А&nbsp;вот операции <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> применимы только в&nbsp;том случае, когда соответствующие элементы кортежей имеют один тип. Поэтому сравнивать ('7', 'червей') и ('7', 'треф') можно, а&nbsp;вот кортежи (1, 2) и ('7', 'пик') нельзя&nbsp;&mdash; интерпретатор Python выдаст ошибку. При этом сравнение происходит последовательно элемент за&nbsp;элементом, а&nbsp;если элементы равны&nbsp;&mdash; просматривается следующий элемент.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Неизменяемость</strong></p>
<p>Важнейшее техническое отличие кортежей от&nbsp;списков&nbsp;&mdash; неизменяемость. Как и&nbsp;к&nbsp;строке, к&nbsp;кортежу нельзя добавить элемент методом <var>append</var>, а&nbsp;существующий элемент нельзя изменить, обратившись к&nbsp;нему по&nbsp;индексу. Это выглядит недостатком, но&nbsp;в&nbsp;дальнейшем мы&nbsp;поймем, что у&nbsp;кортежей есть и&nbsp;преимущества.</p>
</section>
<p>Есть и&nbsp;семантическое, то&nbsp;есть смысловое, отличие. Если списки предназначены скорее для объединения неопределенного количества однородных сущностей, то&nbsp;кортеж&nbsp;&mdash; быстрый способ объединить под одним именем несколько разнородных объектов, имеющих различный смысл.</p>
<p>Так, в&nbsp;примере выше кортеж <var>card</var> состоит из&nbsp;двух элементов, означающих достоинство карты и&nbsp;ее&nbsp;масть.</p>
<p>Еще одним приятным отличием кортежей от&nbsp;списков является&nbsp;то, что они могут быть элементами множества:</p>
<pre><code class="language-python">a = {('7', 'червей'), ('7', 'треф')}
print(a) # -&gt; {('7', 'треф'), ('7', 'червей')}
</code></pre>
</section>
<section class="material__chapter">
<h2 id="2">Присваивание кортежей</h2>
<p>Кортежи можно присваивать друг другу. Именно благодаря этому работает красивая особенность Python&nbsp;&mdash; уже знакомая нам конструкция вида&nbsp;<code>a, b = b, a</code>.</p>
<p>Как известно, по&nbsp;левую сторону от&nbsp;знака присваивания <code>=</code> должно стоять имя переменной либо имя списка с&nbsp;индексом или несколькими индексами. Они указывают, куда можно &laquo;положить&raquo; значение, записанное справа от&nbsp;знака присваивания. Однако слева от&nbsp;знака присваивания можно записать еще и&nbsp;кортеж из&nbsp;таких обозначений (грубо говоря, имен переменных), а&nbsp;справа&nbsp;&mdash; кортеж из&nbsp;значений, которые следует в&nbsp;них поместить. Значения справа указываются в&nbsp;том&nbsp;же порядке, что и&nbsp;переменные слева (здесь скобки вокруг кортежа необязательны):</p>
<pre><code class="language-python">n, s = 10, 'hello'
# то же самое, что
n = 10
s = 'hello'
</code></pre>
<p>В&nbsp;примере выше мы&nbsp;изготовили кортеж, стоящий справа от <code>=</code>, прямо на&nbsp;этой&nbsp;же строчке. Но&nbsp;можно заготовить его и&nbsp;заранее:</p>
<pre><code class="language-python">cards = [('7', 'пик'), ('Д', 'треф'), ('Т', 'пик')]
value, suit = cards[0]
print('Достоинство карты:', value)
print('Масть карты:', suit)
</code></pre>
<p>Самое приятное: сначала вычисляются все значения справа, и&nbsp;лишь затем они кладутся в&nbsp;левую часть оператора присваивания. Поэтому можно, например, поменять местами значения переменных <var>a</var>&nbsp;и&nbsp;<var>b</var>, написав: <code>a, b = b, a</code>.</p>
<pre><code class="language-python">a, b = 1, 2  # теперь a == 1 and b == 2
a, b = b, a  # теперь a == 2 and b == 1
</code></pre>
<p>Пример ниже выведет &laquo;1 2 3&raquo;. Убедитесь, что вы&nbsp;понимаете, почему так.</p>
<pre><code class="language-python"># кручу-верчу
a, b, c = 3, 2, 1
b, a, c = c, a, b
print(b, c, a)
</code></pre>
<p>С&nbsp;использованием кортежей многие алгоритмы приобретают волшебную краткость. Например, вычисление чисел Фибоначчи:</p>
<pre><code class="language-python">n = int(input())
f1, f2 = 0, 1
for i in range(n):
    print(f2)
    f1, f2 = f2, f1 + f2
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Сортировка пузырьком</h2>
<p>Итак, у&nbsp;нас есть удобный способ поменять местами значения двух переменных. Теперь рассмотрим алгоритм, в&nbsp;котором эта операция играет важную роль.</p>
<p>Часто бывает нужно, чтобы данные не&nbsp;просто содержались в&nbsp;списке, а&nbsp;были отсортированы (например, по&nbsp;возрастанию), то&nbsp;есть чтобы каждый следующий элемент списка был не&nbsp;меньше предыдущего. В&nbsp;качестве данных могут выступать числа или строки. Скажем, отсортированный список [4, 1, 9, 3, 1] примет вид [1, 1, 3, 4, 9]. Конечно, для этого есть стандартные функции и&nbsp;методы, но&nbsp;как они работают?</p>
<p>Классический алгоритм сортировки&nbsp;&mdash; <strong>сортировка пузырьком</strong> (по-научному&nbsp;&mdash; сортировка обменом). Она называется так потому, что элементы последовательно &laquo;всплывают&raquo; (отправляются в&nbsp;конец списка), как пузырьки воздуха в&nbsp;воде. Сначала всплывает самый большой элемент, за&nbsp;ним&nbsp;&mdash; следующий по&nbsp;старшинству и&nbsp;т.&nbsp;д. Для этого мы&nbsp;сравниваем по&nbsp;очереди все соседние пары&nbsp;и при необходимости меняем элементы местами, ставя больший элемент на&nbsp;более старшее место.</p>
<p>Идею наглядно объясняет венгерский народный танец:</p>
<div class="material__content-positioner"><iframe src="https://www.youtube.com/embed/lyZQPjUT5B4" width="560" height="315" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div>
<p>А&nbsp;полный код программы, которая считывает, сортирует и&nbsp;выводит список, выглядит, например, так:</p>
<pre><code class="language-python">n = int(input())    # количество элементов
a = []
for i in range(n):  # считываем элементы списка
    a.append(int(input()))
# Сортировка пузырьком:
for i in range(n - 1):
    for j in range(n - 1 - i):
        if a[j] &gt; a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
print(a)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="4">Преобразования между коллекциями</h2>
<p>Итак, на&nbsp;данный момент мы&nbsp;знаем уже четыре вида коллекций: строки, списки, множества и&nbsp;кортежи. У&nbsp;вас может возникнуть вопрос: можно&nbsp;ли из&nbsp;одной коллекции сделать другую? Например, преобразовать строку в&nbsp;список или во&nbsp;множество? Конечно, да, для этого можно использовать функции <var>list</var>, <var>set</var> и&nbsp;<var>tuple</var>. Если в&nbsp;качестве аргумента передать этим функциям какую-либо коллекцию, новая коллекция будет создана на&nbsp;ее&nbsp;основе.</p>
<p>Зачем нужно преобразование коллекций?</p>
<p>Преобразование строки в&nbsp;список позволяет получить список символов. В&nbsp;некоторых задачах это может быть полезно: например, если мы&nbsp;хотим изменить один символ строки:</p>
<pre><code class="language-python">s = 'симпотичный'   # Написали с ошибкой
a = list(s)         # a == ['с', 'и', 'м', 'п', 'о', 'т', 'и,' 'ч', 'н', 'ы', 'й']
a[4] = 'а'          # a == ['с', 'и', 'м', 'п', 'а', 'т', 'и,' 'ч', 'н', 'ы', 'й']
</code></pre>
<p>С&nbsp;этой&nbsp;же целью может потребоваться преобразование кортежа в&nbsp;список:</p>
<pre><code class="language-python"># В кортеже (писатель, дата рождения) допущена ошибка
writer = ('Лев Толстой', 1827)
a = list(writer)                # a == ['Лев Толстой', 1827]
a[1] = 1828                     # a == ['Лев Толстой', 1828]
</code></pre>
<p>Преобразование списка или строки во&nbsp;множество позволяет получить очень интересные результаты. Как вы&nbsp;помните, все элементы множества должны быть уникальны, поэтому при преобразовании списка во&nbsp;множество каждый элемент останется только в&nbsp;одном экземпляре. Таким образом, можно очень легко убрать повторяющиеся элементы и&nbsp;узнать, сколько элементов встречается в&nbsp;списке хотя&nbsp;бы один раз:</p>
<pre><code class="language-python">a = [1, 2, 1, 1, 2, 2, 3, 3]
print('Количество элементов в списке без повторений: ', len(set(a)))
</code></pre>
<p>Таким&nbsp;же образом можно получить все буквы без повторений, которые встречаются в&nbsp;строке:</p>
<pre><code class="language-python">a = set("Тетрагидропиранилциклопентилтетрагидропиридопиридиновые")
print(a, len(a))
</code></pre>
<pre><samp>{'л', 'н', 'в', 'о', 'и', 'ц', 'п', 'т', 'Т', 'г', 'ы', 'а', 'д', 'к', 'р', 'е'} 16</samp></pre>
<p>Преобразование множества в&nbsp;список тоже возможно, но&nbsp;при этом нужно учитывать, что элементы множества не&nbsp;упорядочены и&nbsp;при преобразовании множества в&nbsp;список порядок элементов в&nbsp;нем предсказать заранее не&nbsp;всегда возможно:</p>
<pre><code class="language-python">names = {'Иван', 'Петр', 'Сергей', 'Алексей'}
print(list(names))
# Возможные варианты вывода на экран - ['Сергей', 'Алексей', 'Иван', 'Петр'], 
# ['Сергей', 'Петр', 'Иван', 'Алексей'], ['Алексей', 'Иван', 'Петр', 'Сергей'] 
# и так далее.
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>