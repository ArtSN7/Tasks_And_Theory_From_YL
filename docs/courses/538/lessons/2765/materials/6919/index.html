<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Введение в ООП </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Введение в ООП</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Введение в&nbsp;ООП</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Введение</a></li>
<li><a class="material__link" href="#2">Основные понятия</a></li>
<li><a class="material__link" href="#3">Создание классов</a></li>
<li><a class="material__link" href="#4">Методы классов</a></li>
<li><a class="material__link" href="#5">Инициализация экземпляров класса</a></li>
<li><a class="material__link" href="#6">Соглашения об&nbsp;именовании, вызов методов атрибутов</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Одна из&nbsp;самых распространенных методик разработки программных продуктов&nbsp;&mdash; объектно-ориентированное программирование (ООП). При работе с&nbsp;функциями мы&nbsp;уже использовали принцип модульности (сокрытие сложного алгоритма за&nbsp;вызовом функций) и&nbsp;библиотеки (упаковка функций, решающих схожие задачи, в&nbsp;одно хранилище&nbsp;&mdash; библиотеку). В&nbsp;ООП появляется еще один пример модульности&nbsp;&mdash; <strong>объект</strong>. Объекты хранят внутри себя и&nbsp;данные, и&nbsp;обрабатывающие их&nbsp;функции. Изучению парадигмы объектно-ориентированного программирования и&nbsp;посвящены следующие уроки.</p>
</section>
<section class="material__chapter">
<h2 id="1">Введение</h2>
<p>Язык программирования Python появился в&nbsp;1991&nbsp;году. К&nbsp;этому времени была разработана теоретическая база объектно-ориентированного программирования, появились исследовательские языки программирования, проверившие эти идеи на&nbsp;практике, и&nbsp;даже возникло первое поколение объектно-ориентированных языков для широкого круга программистов.</p>
<p>Поэтому, ориентируясь на&nbsp;чужие успехи и&nbsp;неудачи, Гвидо ван Россум и&nbsp;его коллеги смогли спроектировать достаточно простую и&nbsp;мощную реализацию ООП. Python поддерживает ООП на&nbsp;сто процентов: все данные в&nbsp;нем являются объектами. Числа всех типов, строки, списки, словари, даже функции, модули и, наконец, сами типы данных&nbsp;&mdash; все это объекты!</p>
<p>Давайте для начала рассмотрим несколько предметов из&nbsp;реального мира. Вообще говоря, прямой аналогии между объектами материального мира и&nbsp;объектами из&nbsp;мира программирования нет. Ведь в&nbsp;программировании есть объекты, которые обозначают какой-то процесс (например, функции), или состояние процесса, или вообще произвольные абстрактные понятия. Например, массив или число с&nbsp;плавающей точкой&nbsp;&mdash; сами по&nbsp;себе достаточно абстрактные понятия, которые имеют отдаленные аналоги в&nbsp;реальном мире. Но&nbsp;все&nbsp;же давайте пока порассуждаем о&nbsp;реальных объектах.</p>
<p>Представим себе комнату. В&nbsp;ней есть мебель: несколько столов, стулья, шкафы. Стулья могут отличаться цветом, формой, количеством ножек, но&nbsp;все равно мы&nbsp;всегда сможем отличить стул от&nbsp;шкафа.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Если задуматься, у&nbsp;каждого <strong>объекта</strong> есть набор <strong>свойств</strong> и&nbsp;<strong>действия</strong>, в&nbsp;которых он&nbsp;может участвовать. Основываясь на&nbsp;этих <strong>свойствах</strong> (наличие сиденья) и&nbsp;<strong>действиях</strong> (на&nbsp;стуле можно сидеть), мы&nbsp;классифицируем объекты, то&nbsp;есть относим их&nbsp;к&nbsp;тому или иному <strong>классу</strong>.</p>
</section>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-30/2.svg" width="680" height="auto" /></div>
</section>
<section class="material__chapter">
<h2 id="2">Основные понятия</h2>
<p>Давайте определим несколько терминов.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Класс</strong></p>
<p>Описывает модель объекта, его свойства и&nbsp;поведение. Говоря языком программиста, класс&nbsp;&mdash; такой тип данных, который создается для описания сложных объектов.</p>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Экземпляр</strong></p>
<p>Для краткости вместо &laquo;Объект, порожденный классом &bdquo;Стул&ldquo;&raquo; говорят &laquo;экземпляр класса &bdquo;Стул&ldquo;&raquo;.</p>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Объект</strong></p>
<p>Хранит конкретные значения свойств и&nbsp;информацию о&nbsp;принадлежности к&nbsp;классу. Может выполнять методы.</p>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Атрибут</strong></p>
<p>Свойство, присущее объекту. Класс объекта определяет, какие атрибуты есть у&nbsp;объекта. Конкретные значения атрибутов&nbsp;&mdash; характеристика уже не&nbsp;класса, а&nbsp;конкретного экземпляра этого класса, то&nbsp;есть объекта.</p>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Метод</strong></p>
<p>Действие, которое объект может выполнять над самим собой или другими объектами.</p>
</section>
<p>Чтобы стало чуть понятнее, давайте разберем на&nbsp;примере: <code>1</code>, <code>2</code>, <code>3</code>, <code>"abc"</code>, <code>[10, 20, 30]</code>&nbsp;&mdash; объекты. А&nbsp;<var>int</var>, <var>str</var>, <var>list</var>&nbsp;&mdash; классы. Да, все типы данных, которые мы&nbsp;изучали ранее, на&nbsp;самом деле&nbsp;&mdash; классы:</p>
<ul>
<li><code>1</code>, <code>2</code>, <code>3</code>&nbsp;&mdash; экземпляры класса <var>int</var></li>
<li><code>"abc"</code>&nbsp;&mdash; класса <var>str</var></li>
<li><code>[10, 20, 30]</code>&nbsp;&mdash; экземпляр класса <var>list</var>, в&nbsp;который вложены экземпляры <var>int</var></li>
</ul>
<p>Чтобы узнать, к&nbsp;какому классу относится тот или иной объект, можно воспользоваться функцией <var>type</var>.</p>
<p>Например,</p>
<pre><code class="language-python">&gt;&gt;&gt; type(123)
# =&gt; '&lt;class 'int'&gt;'

&gt;&gt;&gt; type([1, 2, 3])
# =&gt; '&lt;class 'list'&gt;'
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Создание классов</h2>
<p>Давайте создадим простейший класс, который будет моделировать обычный фрукт. На&nbsp;языке Python это будет выглядеть так:</p>
<pre><code class="language-python">class Fruit:
    pass
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>PEP&nbsp;8</strong></p>
<p>Имена классов по&nbsp;стандарту именования PEP&nbsp;8&nbsp;должны начинаться с&nbsp;большой буквы. Встроенные классы (<var>int</var>, <var>float</var>, <var>str</var>, <var>list</var> и&nbsp;др.) этому правилу не&nbsp;следуют, однако в&nbsp;вашем коде его лучше придерживаться&nbsp;&mdash; так делает большинство программистов на&nbsp;Python.</p>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Определение класса</strong></p>
<p>Определение этого класса состоит из&nbsp;зарезервированного слова <var>class</var>, имени класса и&nbsp;пустой инструкции после отступа.</p>
<p>Внутри класса с&nbsp;дополнительным уровнем отступов должны определяться его методы, но&nbsp;сейчас их&nbsp;нет. Однако хотя&nbsp;бы одна инструкция должна быть, поэтому приходится использовать пустую инструкцию-заглушку <var>pass</var>. Она предназначена как раз для таких случаев.</p>
</section>
<p>Описав класс, мы&nbsp;создали модель фрукта.</p>
<p>Теперь создадим два конкретных фрукта&nbsp;&mdash; <strong>экземпляра класса</strong> <var>Fruit</var>:</p>
<pre><code class="language-python">a = Fruit()
b = Fruit()
</code></pre>
<p>Переменные <var>a</var>&nbsp;и&nbsp;<var>b</var>&nbsp;содержат ссылки на&nbsp;два разных объекта&nbsp;&mdash; экземпляра класса <var>Fruit</var>, которые можно наделить разными атрибутами:</p>
<pre><code class="language-python">a.name = 'apple'
a.weight = 120
# теперь a - это яблоко весом 120 грамм
b.name = 'orange'
b.weight = 150
# а b - это апельсин весом 150 грамм
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Атрибуты можно не&nbsp;только устанавливать, но&nbsp;и&nbsp;читать. При чтении еще не&nbsp;созданного атрибута будет появляться ошибка <var>AttributeError</var>. Вы&nbsp;ее&nbsp;часто увидите, допуская неточности в&nbsp;именах атрибутов и&nbsp;методов.</p>
</section>
<pre><code class="language-python">print(a.name, a.weight)  # apple 120
print(b.name, b.weight)  # orange 150
b.weight -= 10  # Апельсин долго лежал на складе и усох
print(b.name, b.weight)  # orange 140
 
c = Fruit()
c.name = 'lemon'
c.color = 'yellow'
# Атрибут color появился только в объекте c.
# Забыли добавить свойство weight и обращаемся к нему
print(c.name, c.weight)  
# Ошибка AttributeError, нет атрибута weight
</code></pre>
</section>
<section class="material__chapter">
<h2 id="4">Методы классов</h2>
<p>На&nbsp;данный момент мы&nbsp;пользуемся объектами только для хранения соответствий между именами атрибутов и&nbsp;их&nbsp;значениями. Но&nbsp;на&nbsp;самом деле возможности объектов значительно шире. Давайте рассмотрим, как можно запрограммировать объекты на&nbsp;выполнение определенных действий:</p>
<pre><code class="language-python">class Greeter:
    def hello_world(self):
        print("Привет, Мир!")
 

greet = Greeter()
greet.hello_world()  # выведет "Привет, Мир!"
</code></pre>
<p>После беглого осмотра этого кода видно, что внутри класса <var>Greeter</var> находится определение чего-то, похожего на&nbsp;функцию, печатающую фразу &laquo;Привет, Мир!&raquo; На&nbsp;самом деле мы&nbsp;написали метод, с&nbsp;синтаксисом вызова которого вы&nbsp;хорошо знакомы по&nbsp;методу строк <var>split</var> или методу списков <var>append</var>. Теперь мы&nbsp;можем создавать такие методы самостоятельно.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>При создании собственных методов обратите внимание на&nbsp;два момента:</p>
<ul>
<li>Метод должен быть определен внутри класса (добавляется уровень отступов)</li>
<li>У&nbsp;методов всегда есть хотя&nbsp;бы один аргумент, и&nbsp;<strong>первый по&nbsp;счету аргумент должен называться self</strong></li>
</ul>
</section>
<p>Аргументу <var>self</var> следует уделить особое внимание. В&nbsp;него передается тот объект, который вызвал этот метод. Поэтому <var>self</var> еще часто называют <strong>контекстным объектом</strong>. Рассмотрим чуть подробнее. Когда программа вызывает метод объекта, Python передает ему в&nbsp;первом аргументе экземпляр вызывающего объекта, который всегда связан с&nbsp;параметром <var>self</var>. Иными словами, <code>greet.hello_world()</code> преобразуется в&nbsp;вызов <code>Greeter.hello_world(greet)</code>. Этот факт объясняет особую важность параметра <var>self</var> и&nbsp;то, почему он&nbsp;всегда должен быть первым в&nbsp;любом методе объекта, который вы&nbsp;пишете. Вызывая метод, вы&nbsp;не&nbsp;должны передавать значение для <var>self</var> явно&nbsp;&mdash; интерпретатор сделает это за&nbsp;вас.</p>
<p>Вообще говоря, <var>self</var>&nbsp;&mdash; обычная переменная, которая может называться по-другому. Но&nbsp;так категорически не&nbsp;рекомендуется делать: соглашение об&nbsp;имени контекстного объекта&nbsp;&mdash; самое строгое из&nbsp;всех соглашений в&nbsp;мире Python. Его выполняют 99,9&nbsp;% программистов. Если нарушить это соглашение, другие программисты просто не&nbsp;будут понимать ваш код. Кроме того, некоторые текстовые редакторы подсвечивают слово <var>self</var> цветом, и&nbsp;это удобно.</p>
<p>В&nbsp;примере выше мы&nbsp;не&nbsp;передавали нашему методу никаких аргументов. Это довольно скучно, ведь мы&nbsp;уже умеем передавать аргументы функциям. Давайте расширим пример и&nbsp;добавим в&nbsp;наш класс два новых метода:</p>
<pre><code class="language-python">class Greeter:
    def hello_world(self):
        print("Привет, Мир!")
 
    def greeting(self, name):
        '''Поприветствовать человека с именем name.'''
        print(f"Привет, {name}!")
 
    def start_talking(self, name, weather_is_good):
        '''Поприветствовать и начать разговор с вопроса о погоде.'''
        print(f"Привет, {name}!")
        if weather_is_good:
            print("Хорошая погода, не так ли?")
        else:
            print("Отвратительная погода, не так ли?")
 
 
greet = Greeter()
greet.hello_world()     # Привет, Мир!
greet.greeting("Петя")  # Привет, Петя!
 
greet.start_talking("Саша", True)  
# Привет, Саша!
# Хорошая погода, не так ли?
</code></pre>
<p>Значение <var>self</var> автоматически получается из&nbsp;объекта, на&nbsp;котором сделан вызов метода, но&nbsp;мы&nbsp;его пока никак не&nbsp;используем.</p>
<p>Давайте попробуем запоминать информацию из&nbsp;предыдущих вызовов методов. Напишем класс &laquo;Машина&raquo;, которую, как известно, надо сначала завести, а&nbsp;потом уже ехать:</p>
<pre><code class="language-python">class Car:
    def start_engine(self):
        engine_on = True  # К сожалению, не сработает
 
    def drive_to(self, city):
        if engine_on:  # Ошибка NameError
            print(f"Едем в город {city}.")
        else:
            print("Машина не заведена, никуда не едем")
 

c = Car()
c.start_engine()
c.drive_to('Владивосток')
</code></pre>
<p>Итак, первая версия класса &laquo;Машина&raquo; специально сделана нерабочей, чтобы показать, что переменные внутри методов ведут себя точно так&nbsp;же, как и&nbsp;переменные функций. То&nbsp;есть если мы&nbsp;инициализируем переменную внутри метода, то&nbsp;после его завершения все созданные таким образом переменные уничтожаются и&nbsp;оказываются недоступны как следующему вызову этого&nbsp;же метода, так и&nbsp;другим методам. Под &laquo;уничтожением&raquo; мы&nbsp;понимаем исчезновение самих переменных, а&nbsp;не&nbsp;объектов, на&nbsp;которые они ссылаются. Если ссылка на&nbsp;объект сохранилась где-нибудь (например, мы&nbsp;вернули объект с&nbsp;помощью <var>return</var>), он&nbsp;все еще доступен. Если ссылок не&nbsp;осталось, объект будет скоро переработан сборщиком мусора.</p>
<p>Напомним, что такие переменные называются <strong>локальными</strong>.</p>
</section>
<section class="material__chapter">
<h2 id="5">Инициализация экземпляров класса</h2>
<p>Но&nbsp;вернемся к&nbsp;методам. Пора нашей машине наконец поехать&nbsp;&mdash; и&nbsp;в&nbsp;этом нам поможет контекстный объект <var>self</var>. Он&nbsp;общий для всех методов класса, и&nbsp;именно в&nbsp;нем мы&nbsp;с&nbsp;помощью атрибутов сохраним информацию о&nbsp;состоянии двигателя:</p>
<pre><code class="language-python">class Car:
    def start_engine(self):
        self.engine_on = True
 
    def drive_to(self, city):
        if self.engine_on:
            print(f"Едем в город {city}.")
        else:
            print("Машина не заведена, никуда не едем.")
</code></pre>
<p>Теперь наша машина отлично заведется и&nbsp;поедет:</p>
<pre><code class="language-python">car1 = Car()
car1.start_engine()
car1.drive_to('Владивосток')  # Едем в город Владивосток.
</code></pre>
<p>Однако одна проблема осталась. При попытке выехать на&nbsp;незаведенной машине</p>
<pre><code class="language-python">car2 = Car()
car2.drive_to('Лиссабон')
</code></pre>
<p>вместо красивого сообщения о&nbsp;том, что незаведенная машина не&nbsp;поедет, получим &laquo;падение&raquo; программы с&nbsp;ошибкой <var>AttributeError</var> (отсутствие атрибута или метода). Еще&nbsp;бы! Ведь атрибут создавался в&nbsp;методе <var>start_engine</var>, а&nbsp;мы&nbsp;не&nbsp;вызвали его для объекта <var>car2</var>.</p>
<p>Кроме того, стоит добавить метод <var>stop_engine</var>, чтобы не&nbsp;только заводить машину, но&nbsp;и&nbsp;глушить двигатель. Этот метод помог&nbsp;бы нам избежать вышеуказанной ошибки, но&nbsp;странно глушить еще не&nbsp;заведенную машину, чтобы избежать ошибки: ведь интуитивно мы&nbsp;понимаем, что машина должна создаваться с&nbsp;выключенным двигателем.</p>
<p>Нет&nbsp;ли способа задать значение атрибута <var>engine_on</var> по&nbsp;умолчанию? Да. Есть метод <var>__init__</var>, который относится к&nbsp;группе так называемых специальных методов, которые имеют особое значение для интерпретатора Python.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Метод __init__</strong></p>
<p>Особое значение метода <var>__init__</var> заключается в&nbsp;том, что, если такой метод в&nbsp;классе определен, интерпретатор <strong>автоматически</strong> вызывает его при создании каждого экземпляра этого класса для инициализации экземпляра.</p>
</section>
<p>Давайте воспользуемся этим, чтобы при создании объекта создать атрибут <var>engine_on</var> и&nbsp;записать в&nbsp;него False.</p>
<pre><code class="language-python">class Car:
    def __init__(self):
        self.engine_on = False
 
    def start_engine(self):
        self.engine_on = True
 
    def drive_to(self, city):
        if self.engine_on:
            print(f"Едем в город {city}.")
        else:
            print("Машина не заведена, никуда не едем.")
 

car1 = Car()
car1.start_engine()
car1.drive_to('Владивосток')  # Едем в город Владивосток.
car2 = Car()
car2.drive_to('Лиссабон')     # Машина не заведена, никуда не едем.
</code></pre>
<p>Метод <var>__init__</var> после <var>self</var> может получать параметры, передаваемые ему при создании экземпляра:</p>
<pre><code class="language-python">class Car:
    def __init__(self, color):
        self.engine_on = False
        self.color = color

    def start_engine(self):
        self.engine_on = True

    def drive_to(self, city):
        if self.engine_on:
            print(f"{self.color} машина едет в город {city}.")
        else:
            print(f"{self.color} машина не заведена, никуда не едем.")


car1 = Car('красная')  # Создали машину красного цвета

car2 = Car('синяя')  # И еще одну синего

car1.start_engine()
# Обратите внимание, что мы завели только одну машину,
# ту, на которую ссылается car1 (красную).

# car2 -- это другой объект, он не изменится.

car1.drive_to('Владивосток')
# красная машина едет в город Владивосток.

car2.drive_to('Лиссабон')
# синяя машина не заведена, никуда не едем.
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Еще раз обратите внимание на&nbsp;комментарии в&nbsp;тексте. Они показывают, что при записи атрибутов в&nbsp;<var>self</var> метод изменяет только свой контекстный объект. Мы&nbsp;знаем, что объекты класса совместно используют код методов класса (то&nbsp;есть поведение), но&nbsp;хранят свои собственные копии всех атрибутов данных (то&nbsp;есть состояние). Это достигается за&nbsp;счет связывания значений атрибутов с&nbsp;объектом, то&nbsp;есть с&nbsp;<var>self</var>.</p>
</section>
<p>Обсудим еще один вопрос: зачем нам понадобился метод <var>start_engine</var>, ведь его можно было&nbsp;бы заменить строчкой <code>car.engine_on = True</code>? Казалось&nbsp;бы, это лишнее усложнение. На&nbsp;самом деле нет. При дальнейшей разработке нашей программы может оказаться, что завести двигатель можно только в&nbsp;машине, в&nbsp;которой есть бензин. Если&nbsp;бы мы&nbsp;в&nbsp;нескольких десятках мест программы написали <code>car.engine_on = True</code>, нам пришлось&nbsp;бы найти все эти места и&nbsp;вставить в&nbsp;них проверку на&nbsp;наличие бензина в&nbsp;баке. А&nbsp;с&nbsp;методом <var>start_engine</var> мы&nbsp;можем изменить только этот метод.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Инкапсуляция</strong></p>
<p>Такая технология сокрытия информации о&nbsp;внутреннем устройстве объекта за&nbsp;внешним интерфейсом из&nbsp;методов называется <strong>инкапсуляцией</strong>. Надо стараться делать интерфейс методов достаточно полным. Тогда&nbsp;вы, как и&nbsp;другие программисты, будете пользоваться этими методами, а&nbsp;изменения в&nbsp;атрибутах не&nbsp;будут расползаться по&nbsp;коду, использующему ваш класс. Кроме того, инкапсуляция позволяет шире использовать такое понятие, как полиморфизм. О&nbsp;нем мы&nbsp;поговорим на&nbsp;следующем уроке.</p>
</section>
<p>В&nbsp;некоторых языках программирования автор класса может закрыть доступ к&nbsp;атрибутам извне класса и&nbsp;заставить всех использующих его программистов работать только с&nbsp;методами. К&nbsp;сожалению, в&nbsp;Python так делать нельзя, однако стоит по&nbsp;возможности пользоваться только методами.</p>
</section>
<section class="material__chapter">
<h2 id="6">Соглашения об&nbsp;именовании, вызов методов атрибутов</h2>
<p>Давайте разберемся еще с&nbsp;одним примером. Напишем класс робота-почтальона, который должен разносить письма в&nbsp;определенные дома и&nbsp;квартиры. (Для простоты считаем, что робот обслуживает одну улицу, и&nbsp;не&nbsp;будем ее&nbsp;указывать.) Класс назовем длинным именем <var>RoboticMailDelivery</var>, чтобы показать, как в&nbsp;Python принято называть классы с&nbsp;длинным составным именем.</p>
<section class="material__note">
<p class="material__note-heading"><strong>PEP&nbsp;8</strong></p>
<p>Имя класса должно начинаться с&nbsp;большой буквы, между словами не&nbsp;должно быть прочерка, каждое слово внутри имени должно начинаться с&nbsp;большой буквы.</p>
<p>Например, <var>RoboticMailDelivery</var>.</p>
</section>
<p>Текст примера:</p>
<pre><code class="language-python">class RoboticMailDelivery:
    def __init__(self):
        self.house_flat_pairs = []
 
    def add_mail(self, house_number, flat_number):
        '''Добавить информацию о доставке письма по номеру дома
        house_number, квартирe flat_number.'''
        self.house_flat_pairs.append((house_number, flat_number))
 
    def flat_numbers_for_house(self, house_number):
        '''Вернуть список квартир в доме house_number,
        в которые нужно доставить письма.'''
        flat_numbers = []
        for h, f in self.house_flat_pairs:
            if h == house_number:
                flat_numbers.append(f)
        return flat_numbers
</code></pre>
<p>Метод <var>add_mail</var> добавляет кортеж (номер_дома, номер_квартиры) в&nbsp;список-атрибут с&nbsp;помощью метода <var>append</var>. Как видно, вызовы методов для объектов-атрибутов производят обычным образом, вызов метода дописывается справа от&nbsp;объекта: <code>self.house_flat_pairs.append(...)</code>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>PEP&nbsp;8</strong></p>
<p>Для имен атрибутов и&nbsp;методов применяются те&nbsp;же правила, что и&nbsp;для имен переменных и&nbsp;функций. Имя должно быть записано в&nbsp;нижнем регистре, слова внутри имени разделяются подчеркиванием: <var>flat_numbers_for_house</var>, <var>house_flat_pairs</var>.</p>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Документация с&nbsp;описанием методов записывается в&nbsp;<code>'''многострочных строках'''</code> перед первой инструкцией как в&nbsp;функциях, так и&nbsp;в&nbsp;методах.</p>
</section>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>