<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Строки. Индексация </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Индексация</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Строки. Индексация</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Строка как коллекция</a></li>
<li><a class="material__link" href="#2">Что мы&nbsp;знаем о&nbsp;строках</a></li>
<li><a class="material__link" href="#3">Индексация в&nbsp;строках</a></li>
<li><a class="material__link" href="#4">Перебор элементов строки</a></li>
<li><a class="material__link" href="#5">Хранение текстов в&nbsp;памяти компьютера</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;этом занятии мы&nbsp;углубим свои знания о&nbsp;строках. Теперь мы&nbsp;сможем не&nbsp;только считывать строку, но&nbsp;и&nbsp;работать с&nbsp;ней, в&nbsp;том числе делать посимвольный перебор.</p>
</section>
<section class="material__chapter">
<h2 id="1">Строка как коллекция</h2>
<p>На&nbsp;прошлом занятии мы&nbsp;познакомились с&nbsp;коллекцией, которая называется <strong>множество</strong>. Вспомним, что основная особенность коллекций&nbsp;&mdash; возможность хранить несколько значений под одним именем. Можно сказать, что коллекция является <strong>контейнером</strong> для этих значений.</p>
<p>Но&nbsp;еще до&nbsp;изучения множеств мы&nbsp;уже знали тип данных, который ведет себя подобно коллекции. Этот тип данных&nbsp;&mdash; строка. Действительно, ведь строка фактически является последовательностью символов. В&nbsp;некоторых языках программирования есть специальный тип данных <strong>char</strong>, позволяющий хранить один символ. В&nbsp;Python такого типа данных нет, поэтому можно сказать, что строка&nbsp;&mdash; <strong>последовательность односимвольных строк</strong>.</p>
</section>
<section class="material__chapter">
<h2 id="2">Что мы&nbsp;знаем о&nbsp;строках</h2>
<p>Давайте вспомним, что мы&nbsp;уже знаем о&nbsp;работе со&nbsp;строками в&nbsp;языке Python. Мы&nbsp;умеем создавать строки четырьмя способами: задавать напрямую, считывать с&nbsp;клавиатуры функцией <code>input()</code>, преобразовывать число в&nbsp;строку функцией <var>str</var> и&nbsp;склеивать из&nbsp;двух других строк операцией <var>+</var>. Кроме того, мы&nbsp;умеем узнавать длину строки, используя функцию <var>len</var>, и&nbsp;проверять, является&nbsp;ли одна строка частью другой, используя операцию&nbsp;in:</p>
<pre><code class="language-python">fixed_word = 'опять'
print(fixed_word)
word = input()
print(word)
number = 25
number_string = str(number)
print(number_string)
word_plus_number = fixed_word + number_string
print(word_plus_number)
print(len(word_plus_number))
print('оп' in word_plus_number)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Индексация в&nbsp;строках</h2>
<p>В&nbsp;отличие от&nbsp;множеств, в&nbsp;строках важен порядок элементов (символов). Действительно, если множества {1, 2, 3} и&nbsp;{3, 2, 1}&nbsp;&mdash; это одинаковые множества, то&nbsp;строки МИР и&nbsp;РИМ&nbsp;&mdash; две совершенно разные строки. Наличие порядка дает нам возможность пронумеровать символы. Нумерация символов начинается с&nbsp;0:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-10/string-index-1.svg" width="680" height="auto" /></div>
<section class="material__note">
<p class="material__note-heading"><strong>Индекс</strong></p>
<p>По&nbsp;индексу можно получить соответствующий ему символ строки. Для этого нужно после самой строки написать в&nbsp;квадратных скобках индекс символа.</p>
</section>
<pre><code class="language-python">word = 'привет'
initial_letter = word[0]
print(initial_letter)  # сделает то же, что print('п')
other_letter = word[3]
print(other_letter)  # сделает то же, что print('в')
</code></pre>
<p>Естественно, в&nbsp;этом примере <var>word</var> с&nbsp;тем&nbsp;же успехом можно было считать с&nbsp;клавиатуры через <code>input()</code>. Тогда мы&nbsp;не&nbsp;могли&nbsp;бы заранее сказать, чему равны переменные <var>initial_letter</var> и&nbsp;<var>other_letter</var>.</p>
<p>А&nbsp;что будет, если попытаться получить букву, номер которой слишком велик? В&nbsp;этом случае Python выдаст ошибку:</p>
<pre><code class="language-python">word = 'привет'
print(word[6]) # builtins.IndexError: string index out of range
</code></pre>
<p>Конечно, номер в&nbsp;квадратных скобках&nbsp;&mdash; не&nbsp;всегда фиксированное число, которое прописано в&nbsp;самой программе. Его тоже можно считать с&nbsp;клавиатуры или получить в&nbsp;результате арифметического действия.</p>
<pre><code class="language-python">word = 'привет'
number_of_letter = int(input())  # предположим, пользователь ввел 3
print(word[number_of_letter])  # тогда будет выведена буква 'в'
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Отрицательные индексы</strong></p>
<p>Кроме &laquo;прямой&raquo; индексации (начинающейся с&nbsp;0), в&nbsp;Python разрешены отрицательные индексы: <code>word[-1]</code> означает последний символ строки <var>word</var>, <code>word[-2]</code>&nbsp;&mdash; предпоследний и&nbsp;т&nbsp;д.</p>
</section>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-10/string-index-2.svg" width="680" height="auto" /></div>
<p>А&nbsp;можно&nbsp;ли, используя индексацию, изменить какой-либо символ строки? Давайте проверим:</p>
<pre><code class="language-python">word = 'карова'  # Написали слово с ошибкой
word[1] = 'о'    # Пробуем исправить, но:
# TypeError: 'str' object does not support item assignment
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Интерпретатор Python выдает ошибку&nbsp;&mdash; значит, изменить отдельный символ строки невозможно, т.&nbsp;е.&nbsp;строка относится к&nbsp;<strong>неизменяемым</strong> типам данных в&nbsp;Python.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="4">Перебор элементов строки</h2>
<p>В&nbsp;предыдущем уроке мы&nbsp;узнали, что цикл <var>for</var> можно использовать для перебора элементов множества. Таким&nbsp;же образом можно использовать цикл <var>for</var>, чтобы перебрать все буквы в&nbsp;слове:</p>
<pre><code class="language-python">text = 'hello, my dear friends!'
vowels = 0
for letter in text:
    if letter in {'a', 'e', 'i', 'o', 'u', 'y'}:
        vowels += 1
print(vowels)
</code></pre>
<p>Но, так как символы в&nbsp;строке пронумерованы, у&nbsp;нас есть еще один способ перебрать все элементы в&nbsp;строке: перебрать все индексы, используя уже знакомую нам конструкцию <code>for i&nbsp;in&nbsp;range(...)</code>.</p>
<pre><code class="language-python">text = 'hello, my dear friends!'
vowels = 0
for i in range(len(text)):
    if text[i] in 'aeiouy':
        vowels += 1
print(vowels)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="5">Хранение текстов в&nbsp;памяти компьютера</h2>
<p>Давайте немного поговорим о&nbsp;том, как строки хранятся в&nbsp;памяти компьютера.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Кодирование</strong></p>
<p>Поскольку компьютер умеет хранить только двоичные числа, для записи нечисловой информации (текстов, изображений, видео, документов) прибегают к&nbsp;кодированию.</p>
<p>Самый простой случай кодирования&nbsp;&mdash; сопоставление кодов текстовым символам.</p>
</section>
<p>Один самых распространенных форматов такого кодирования&nbsp;&mdash; таблица ASCII (American standard code for information interchange).</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/ascii.png" width="423" height="auto" /></div>
<p>Изначально в&nbsp;этой таблице каждому символу был поставлен в&nbsp;соответствие 7-битный код, что позволяло идентифицировать 128 различных символов. В&nbsp;таблице вы&nbsp;не&nbsp;видите символы с&nbsp;кодами, меньшими&nbsp;32, так как они являются служебными и&nbsp;не&nbsp;предназначены для непосредственного вывода на&nbsp;экран (пробел, перевод строки, табуляция и&nbsp;т.&nbsp;д.).</p>
<p>Этого хватало на&nbsp;латинские буквы обоих регистров, знаки препинания и&nbsp;спецсимволы&nbsp;&mdash; например, перевод строки или разрыв страницы. Позже код расширили до&nbsp;1&nbsp;байта, что позволяло хранить уже 256 различных значений: в&nbsp;таблицу помещались буквы второго алфавита (например, кириллица) и&nbsp;дополнительные графические элементы (псевдографика).</p>
<p>В&nbsp;некоторых относительно низкоуровневых языках (например, в&nbsp;С) можно в&nbsp;любой момент перейти от&nbsp;представления строки в&nbsp;памяти к&nbsp;последовательности байтов, начинающейся по&nbsp;какому-либо адресу.</p>
<p>Сейчас однобайтные кодировки отошли на&nbsp;второй план, уступив место Юникоду.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Юникод</strong></p>
<p>Юникод&nbsp;&mdash; таблица, которая содержит соответствия между числом и&nbsp;каким-либо знаком, причем количество знаков может быть любым. Это позволяет одновременно использовать любые символы любых алфавитов и дополнительные графические элементы. Кроме того, в&nbsp;Юникоде каждый символ, помимо кода, имеет некоторые свойства: например, буква это или цифра. Это позволяет более гибко работать с&nbsp;текстами.</p>
</section>
<p>В&nbsp;Юникод все время добавляются новые элементы, а&nbsp;сам размер этой таблицы не&nbsp;ограничен и&nbsp;будет только расти, поэтому сейчас при хранении в&nbsp;памяти одного юникод-символа может потребоваться от&nbsp;1&nbsp;до&nbsp;8&nbsp;байт. Отсутствие ограничений привело к&nbsp;тому, что стали появляться символы на&nbsp;все случаи жизни. Например, есть несколько снеговиков.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/unicode-snowman.png" width="201" height="auto" /></div>
<p>Этого вы&nbsp;можете увидеть, если наберете:</p>
<pre><code class="language-python">print('\u2603')
</code></pre>
<pre><samp>☃</samp></pre>
<p>Важно понять, что все строки в&nbsp;Python хранятся именно как последовательность юникод-символов.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функция ord</strong></p>
<p>Для того чтобы узнать код некоторого символа, существует функция <var>ord</var> (от&nbsp;order&nbsp;&mdash; &laquo;порядок&raquo;).</p>
<pre><code class="language-python">ord('Б') 
</code></pre>
<pre><samp>1041</samp></pre>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Функция chr</strong></p>
<p>Зная код, всегда можно получить соответствующий ему символ. Для этого существует функция <var>chr</var> (от&nbsp;character&nbsp;&mdash; &laquo;символ&raquo;):</p>
<pre><code class="language-python">chr(1041) 
</code></pre>
<pre><samp>'Б'</samp></pre>
</section>
<p>Функции <var>ord</var> и&nbsp;<var>chr</var> часто работают в&nbsp;паре. Попробуйте, например, предположить, что будет выведено на&nbsp;экран в&nbsp;результате работы следующей программы:</p>
<pre><code class="language-python">for i in range(26):
    print(chr(ord('A') + i))
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>