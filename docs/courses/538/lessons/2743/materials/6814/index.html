<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Множества </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Множества</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Множества</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Объекты типа set</a></li>
<li><a class="material__link" href="#2">Операции над множеством</a></li>
<li><a class="material__link" href="#3">Операции над двумя множествами</a></li>
<li><a class="material__link" href="#4">Сравнение множеств</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке мы&nbsp;обсудим множества Python. Этот тип данных аналогичен математическим множествам, он&nbsp;поддерживает быстрые операции проверки наличия элемента в&nbsp;множестве, добавления и&nbsp;удаления элементов, операции объединения, пересечения и&nbsp;вычитания множеств.</p>
</section>
<section class="material__chapter">
<h2 id="1">Объекты типа set</h2>
<p>Мы&nbsp;написали уже много программ, работающих с&nbsp;данными, количество которых неизвестно на&nbsp;момент написания программы. Теперь было&nbsp;бы здорово уметь хранить в&nbsp;памяти неизвестное на&nbsp;момент написания программы количество данных. В&nbsp;этом нам помогут так называемые <strong>коллекции</strong>&nbsp;&mdash; специальные типы данных, которые умеют хранить несколько значений под одним именем. Первая из&nbsp;коллекций, с&nbsp;которой мы&nbsp;познакомимся, называется <strong>множество</strong>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Множество</strong></p>
<p>Множество&nbsp;&mdash; составной тип данных, представляющий собой несколько значений (элементов множества) под одним именем. Этот тип называется <var>set</var>, не&nbsp;создавайте, пожалуйста, переменные с&nbsp;таким именем! Чтобы задать множество, нужно в&nbsp;фигурных скобках перечислить его элементы.</p>
</section>
<p>Здесь создается множество из&nbsp;четырех элементов (названий млекопитающих), которое затем выводится на&nbsp;экран:</p>
<pre><code class="language-python">mammals = {'cat', 'dog', 'fox', 'elephant'}
print(mammals)
</code></pre>
<p>Введите этот код в&nbsp;Python и&nbsp;запустите программу несколько раз. Скорее всего, вы&nbsp;увидите разный порядок перечисления млекопитающих, так происходит потому, что элементы в&nbsp;множестве Python не&nbsp;упорядочены. Это позволяет быстро выполнять операции над множествами, о&nbsp;которых мы&nbsp;скоро поговорим.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Создание множества</strong></p>
<p>Для создания пустых множеств обязательно вызывать функцию <var>set</var>:</p>
<pre><code class="language-python">empty = set()
</code></pre>
</section>
<p>Обратите внимание: элементами множества могут быть строки или числа. Возникает вопрос: а&nbsp;может&nbsp;ли множество содержать и&nbsp;строки, и&nbsp;числа? Давайте попробуем:</p>
<pre><code class="language-python">mammals_and_numbers = {'cat', 5, 'dog', 3, 'fox', 12, 'elephant', 4}
print(mammals_and_numbers)
</code></pre>
<p>Как видим, множество может содержать и&nbsp;строки, и&nbsp;числа, а&nbsp;Python опять выводит элементы множества в&nbsp;случайном порядке. Заметьте, если поставить в&nbsp;программе оператор вывода множества на&nbsp;экран несколько раз, не&nbsp;изменяя само множество, порядок вывода элементов не&nbsp;изменится.</p>
<p>Может&nbsp;ли элемент входить в&nbsp;множество несколько раз? Это было&nbsp;бы странно, так как совершенно непонятно, как отличить один элемент от&nbsp;другого. Нет смысла хранить несколько одинаковых объектов, удобно иметь контейнер, сохраняющий только уникальные объекты. Поэтому множество содержит каждый элемент только один раз. Следующий фрагмент кода это демонстрирует:</p>
<pre><code class="language-python">birds = {'raven', 'sparrow', 'sparrow', 'dove', 'hawk', 'falcon'}
print(birds)
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Итак, у&nbsp;множеств есть три ключевые особенности:</p>
<ul>
<li>Порядок элементов в&nbsp;множестве не&nbsp;определен</li>
<li>Элементы множеств&nbsp;&mdash; строки и/или числа</li>
<li>Множество не&nbsp;может содержать одинаковых элементов</li>
</ul>
</section>
<p>Выполнение этих трех свойств позволяет организовать элементы множества в&nbsp;структуру со&nbsp;сложными взаимосвязями, благодаря которым можно быстро проверять наличие элементов в&nbsp;множестве, объединять множества и&nbsp;т.&nbsp;д. Но&nbsp;пока давайте обсудим ограничения.</p>
</section>
<section class="material__chapter">
<h2 id="2">Операции над множеством</h2>
<p>Простейшая операция&nbsp;&mdash; <strong>вычисление числа элементов</strong> множества. Для этого служит функция <var>len</var>. Мы&nbsp;уже встречались с&nbsp;этой функцией раньше, когда определяли длину строки:</p>
<pre><code class="language-python">my_set = {'a', 'b', 'c'}
n = len(my_set)  # =&gt; 3
</code></pre>
<p>Далее можно <strong>вывести элементы</strong> множества с&nbsp;помощью функции <var>print</var>:</p>
<pre><code class="language-python">my_set = {'a', 'b', 'c'}
print(my_set) # =&gt; {'b', 'c', 'a'}
</code></pre>
<p>В&nbsp;вашем случае порядок может отличаться, так как правило упорядочивания элементов в&nbsp;множестве выбирается случайным образом при запуске интерпретатора Python.</p>
<p>Очень часто необходимо <strong>обойти все элементы</strong> множества в&nbsp;цикле. Для этого используется цикл <var>for</var> и&nbsp;оператор&nbsp;<var>in</var>, с&nbsp;помощью которых можно перебрать не&nbsp;только все элементы диапазона (как мы&nbsp;это делали раньше, используя <var>range</var>), но&nbsp;и&nbsp;элементы множества:</p>
<pre><code class="language-python">my_set = {'a', 'b', 'c'}
for elem in my_set:
    print(elem)
</code></pre>
<p>такой код выводит:</p>
<pre><samp>b
a
c</samp></pre>
<p>Однако, как и&nbsp;в&nbsp;прошлый раз, в&nbsp;вашем случае порядок может отличаться: заранее он&nbsp;неизвестен. Код для работы с&nbsp;множествами нужно писать таким образом, чтобы он&nbsp;правильно работал при любом порядке обхода. Для этого надо знать два правила:</p>
<ul>
<li>Если мы&nbsp;не&nbsp;изменяли множество, порядок обхода элементов тоже не&nbsp;изменится</li>
<li>После изменения множества порядок элементов может измениться произвольным образом</li>
</ul>
<p>Чтобы <strong>проверить наличие элемента</strong> в&nbsp;множестве, можно воспользоваться уже знакомым оператором&nbsp;<var>in</var>:</p>
<pre><code class="language-python">if elem in my_set:
    print('Элемент есть в множестве')
else:
    print('Элемента нет в множестве')
</code></pre>
<p>Выражение <code>elem in&nbsp;my_set</code> возвращает True, если элемент есть в&nbsp;множестве, и&nbsp;False, если его нет. Интересно, что эта операция для множеств в&nbsp;Python выполняется за&nbsp;время, не&nbsp;зависящее от&nbsp;мощности множества (количества его элементов).</p>
<p><strong>Добавление элемента</strong> в&nbsp;множество делается при помощи <var>add</var>:</p>
<pre><code class="language-python">new_elem = 'e'
my_set.add(new_elem)
</code></pre>
<p><var>add</var>&nbsp;&mdash; что-то вроде функции, &laquo;приклеенной&raquo; к&nbsp;конкретному множеству. Такие &laquo;приклеенные функции&raquo; называются <strong>методами</strong>.</p>
<p>Таким образом, если в&nbsp;коде присутствует имя множества, затем точка и&nbsp;еще одно название со&nbsp;скобками, второе название&nbsp;&mdash; имя метода. Если элемент, равный <var>new_elem</var>, уже существует в&nbsp;множестве, оно не&nbsp;изменится, поскольку не&nbsp;может содержать одинаковых элементов. Ошибки при этом не&nbsp;произойдет. Небольшой пример:</p>
<pre><code class="language-python">my_set = set()
my_set.add('a')
my_set.add('b')
my_set.add('a')
print(my_set)
</code></pre>
<p>Данный код три раза вызовет метод <var>add</var>, &laquo;приклеенный&raquo; к&nbsp;множеству <var>my_set</var>, а&nbsp;затем выведет либо <code>{'a', 'b'}</code>, либо <code>{'b', 'a'}</code>.</p>
<p>С&nbsp;<strong>удалением элемента</strong> сложнее. Для этого есть сразу три метода: <var>discard</var> (удалить заданный элемент, если он&nbsp;есть в&nbsp;множестве, и&nbsp;ничего не&nbsp;делать, если его нет), <var>remove</var> (удалить заданный элемент, если он&nbsp;есть, и&nbsp;породить ошибку KeyError, если нет) и&nbsp;<var>pop</var>. Метод pop удаляет некоторый элемент из&nbsp;множества и&nbsp;возвращает его как результат. Порядок удаления при этом неизвестен.</p>
<pre><code class="language-python">my_set = {'a', 'b', 'c'}
 
my_set.discard('a')         # Удалён
my_set.discard('hello')     # Не удалён, ошибки нет
my_set.remove('b')          # Удалён
print(my_set)               # В множестве остался один элемент 'c'
my_set.remove('world')      # Не удалён, ошибка KeyError
</code></pre>
<p>На&nbsp;первый взгляд, странно, что есть метод <var>remove</var>, который увеличивает количество падений вашей программы. Однако если вы&nbsp;на&nbsp;100&nbsp;% уверены, что элемент должен быть в&nbsp;множестве, то&nbsp;лучше получить ошибку во&nbsp;время отладки и&nbsp;исправить&nbsp;ее, чем тратить время на&nbsp;поиски при неправильной работе программы.</p>
<p>Метод <var>pop</var> удаляет из&nbsp;множества случайный элемент и&nbsp;возвращает его значение:</p>
<pre><code class="language-python">my_set = {'a', 'b', 'c'}
print('до удаления:', my_set)
elem = my_set.pop()
print('удалённый элемент:', elem)
print('после удаления:', my_set)
</code></pre>
<p>Результат работы случаен, например, такой код может вывести следующее:</p>
<pre><samp>до удаления: {'b', 'a', 'c'}
удалённый элемент: b
после удаления: {'a', 'c'}</samp></pre>
<p>Если попытаться применить <var>pop</var> к&nbsp;пустому множеству, произойдет ошибка KeyError.</p>
<p><strong>Очистить</strong> множество от&nbsp;всех элементов можно методом <var>clear</var>:</p>
<pre><code class="language-python">my_set.clear()
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Операции над двумя множествами</h2>
<p>Есть четыре операции, которые из&nbsp;двух множеств делают новое множество: объединение, пересечение, разность и&nbsp;симметричная разность.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-9/set-union.svg" width="680" height="auto" /></div>
<p>Объединение двух множеств включает в&nbsp;себя все элементы, которые есть хотя&nbsp;бы в&nbsp;одном из&nbsp;них. Для этой операции существует метод <var>union</var>:</p>
<pre><code class="language-python">union = my_set1.union(my_set2)
</code></pre>
<p>Или можно использовать оператор <var>|</var>:</p>
<pre><code class="language-python">union = my_set1 | my_set2
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-9/set-intersection.svg" width="680" height="auto" /></div>
<p>Пересечение двух множеств включает в&nbsp;себя все элементы, которые есть в&nbsp;обоих множествах:</p>
<pre><code class="language-python">intersection = my_set1.intersection(my_set2)
</code></pre>
<p>Или аналог:</p>
<pre><code class="language-python">intersection = my_set1 &amp; my_set2
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-9/set-difference.svg" width="680" height="auto" /></div>
<p>Разность двух множеств включает в&nbsp;себя все элементы, которые есть в&nbsp;первом множестве, но&nbsp;которых нет во&nbsp;втором:</p>
<pre><code class="language-python">diff = my_set1.difference(my_set2)
</code></pre>
<p>Или аналог:</p>
<pre><code class="language-python">diff = my_set1 - my_set2
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-9/set-symmetric_difference.svg" width="680" height="auto" /></div>
<p>Симметричная разность двух множеств включает в&nbsp;себя все элементы, которые есть только в&nbsp;одном из&nbsp;этих множеств:</p>
<pre><code class="language-python">symm_diff = my_set1.symmetric_difference(my_set2)
</code></pre>
<p>Или аналогичный вариант:</p>
<pre><code class="language-python">symm_diff = my_set1 ^ my_set2
</code></pre>
<p>Люди часто путают обозначения&nbsp;| и&nbsp;&amp;, поэтому рекомендуется вместо них писать <code>s1.union(s2)</code> и&nbsp;<code>s1.intersection(s2)</code>. Операции&nbsp;&minus; и ^ перепутать сложнее, их&nbsp;можно записывать прямо так.</p>
<pre><code class="language-python">s1 = {'a', 'b', 'c'}
s2 = {'a', 'c', 'd'}
union = s1.union(s2)                # {'a', 'b', 'c', 'd'}
intersection = s1.intersection(s2)  # {'a', 'c'}
diff = s1 - s2                      # {'b'}
symm_diff = s1 ^ s2                 # {'b', 'd'}
</code></pre>
</section>
<section class="material__chapter">
<h2 id="4">Сравнение множеств</h2>
<p>Все операторы сравнения множеств, а&nbsp;именно: <var>==</var>, <var>&lt;</var>, <var>&gt;</var>, <var>&lt;=</var>, <var>&gt;=</var>, возвращают True, если сравнение истинно, и&nbsp;False&nbsp;&mdash; в&nbsp;противном случае.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Равенство и&nbsp;неравенство множеств</strong></p>
<p>Множества считаются равными, если они содержат одинаковые наборы элементов. Равенство множеств, как в&nbsp;случае с&nbsp;числами и&nbsp;строками, обозначается оператором <var>==</var>.</p>
<p>Неравенство множеств обозначается оператором <var>!=</var>. Он&nbsp;работает противоположно оператору <var>==</var>.</p>
</section>
<pre><code class="language-python">if set1 == set2:
    print('Множества равны')
else:
    print('Множества не равны')
</code></pre>
<p>Обратите внимание на&nbsp;то, что у&nbsp;двух равных множеств могут быть разные порядки обхода, например, из-за того, что элементы в&nbsp;каждое из&nbsp;них добавлялись в&nbsp;разном порядке.</p>
<p>Теперь перейдем к&nbsp;операторам <var>&lt;=</var>, <var>&gt;=</var>. Они означают &laquo;является подмножеством&raquo; и&nbsp;&laquo;является надмножеством&raquo;.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Подмножество и&nbsp;надмножество</strong></p>
<p>Подмножество&nbsp;&mdash; некоторая выборка элементов множества, которая может быть как меньше множества, так и&nbsp;совпадать с&nbsp;ним, на&nbsp;что указывают символы &laquo;&lt;&raquo; и &laquo;=&raquo; в&nbsp;операторе <var>&lt;=</var>. Наоборот, надмножество включает все элементы некоторого множества&nbsp;и, возможно, какие-то еще.</p>
</section>
<pre><code class="language-python">s1 = {'a', 'b', 'c'}
print(s1 &lt;= s1)  # True
 
s2 = {'a', 'b'}
print(s2 &lt;= s1)  # True
s3 = {'a'}
print(s3 &lt;= s1)  # True
s4 = {'a', 'z'}
print(s4 &lt;= s1)  # False
</code></pre>
<p>Операция&nbsp;<code>s1 &lt; s2</code>&nbsp;означает &laquo;<var>s1</var>&nbsp;является подмножеством&nbsp;<var>s2</var>, но&nbsp;целиком не&nbsp;совпадает с&nbsp;ним&raquo;. Операция <code>s1 &gt; s2</code>&nbsp;означает &laquo;<var>s1</var>&nbsp;является надмножеством&nbsp;<var>s2</var>, но&nbsp;целиком не&nbsp;совпадает с&nbsp;ним&raquo;.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>