<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | ООП. Наследование </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Наследование №1</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>ООП. Наследование</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Введение</a></li>
<li><a class="material__link" href="#2">Иерархия классов</a></li>
<li><a class="material__link" href="#3">Механизм наследования</a></li>
<li><a class="material__link" href="#4">Наследование на&nbsp;примере геометрических фигур</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Сегодня объясняется понятие наследования, показывается его связь с&nbsp;уже известными понятиями объектно-ориентированного программирования (инкапсуляцией и&nbsp;полиморфизмом), описывается синтаксис и&nbsp;семантика наследования в&nbsp;Python.</p>
</section>
<section class="material__chapter">
<h2 id="1">Введение</h2>
<p>На&nbsp;прошлых уроках мы&nbsp;познакомились с&nbsp;основами объектно-ориентированного программирования. Научились определять классы и&nbsp;создавать объекты. Узнали о&nbsp;том, что хорошо продуманный набор методов (иначе говоря, <strong>интерфейс</strong>) позволяет добиться <strong>инкапсуляции</strong> (т.&nbsp;е. скрытия информации о&nbsp;внутреннем устройстве объекта) и&nbsp;<strong>полиморфизма</strong> (т.&nbsp;е. возможности писать код, работающий одинаково с&nbsp;разными классами).</p>
<p>Часто бывает так, что классы в&nbsp;программе имеют не&nbsp;только общий интерфейс, но&nbsp;и&nbsp;похожую реализацию. Для примера рассмотрим несколько классов, представляющих геометрические фигуры: круг (<var>Circle</var>) и&nbsp;прямоугольник (<var>Rectangle</var>). Пусть интерфейс этих классов пока состоит из&nbsp;единственного метода <code>area()</code>, возвращающего площадь фигуры.</p>
<pre><code class="language-python">from math import pi


class Circle:
    def __init__(self, radius):
        self.r = radius

    def area(self):
        return pi * self.r ** 2


class Rectangle:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def area(self):
        return self.a * self.b
</code></pre>
<p>Допустим, теперь нам нужно реализовать класс для квадрата (<var>Square</var>). Конечно, мы&nbsp;можем сделать это непосредственно:</p>
<pre><code class="language-python">class Square:
    def __init__(self, a):
        self.a = a
        
    def area(self):
        return self.a * self.a
</code></pre>
<p>Но&nbsp;мы&nbsp;знаем, что квадрат&nbsp;&mdash; частный случай прямоугольника, у&nbsp;которого ширина равна высоте. Чем нам это может помочь?</p>
<p>Представьте, что мы&nbsp;хотим добавить в&nbsp;интерфейс наших классов еще один метод <code>perimeter()</code> для вычисления периметра. Сейчас нам нужно добавить его во&nbsp;все три класса, но&nbsp;это лишняя работа&nbsp;&mdash; ведь периметр квадрата вычисляется так&nbsp;же, как и&nbsp;периметр прямоугольника. А&nbsp;любая лишняя работа не&nbsp;только отнимает время у&nbsp;программиста, но&nbsp;и&nbsp;увеличивает вероятность допустить ошибку. Конечно, вы&nbsp;вряд&nbsp;ли ошибетесь в&nbsp;написании метода <code>perimeter()</code> для квадрата (ведь это займет одну строку), но&nbsp;в&nbsp;реальности методы классов могут занимать десятки, иногда даже сотни строк, а&nbsp;логика работы этих методов гораздо сложнее.</p>
<p>Резюмируем наши наблюдения:</p>
<ul>
<li>Класс <var>Square</var> является частным случаем класса <var>Rectangle</var></li>
<li>Если&nbsp;бы имелся способ явно запрограммировать это отношение, наш код получился более коротким&nbsp;и, что важно, <strong>согласованным</strong> (если периметр прямоугольника вычисляется правильно, периметр квадрата <strong>автоматически</strong> вычисляется правильно)</li>
</ul>
<p>Такой способ, конечно, существует, он&nbsp;называется &laquo;наследование&raquo;.</p>
<p>Итак, дадим определение:</p>
<section class="material__note">
<p class="material__note-heading"><strong>Наследование</strong></p>
<p>Наследование&nbsp;&mdash; механизм, позволяющий запрограммировать отношение вида &laquo;класс&nbsp;<var>B</var> является частным случаем класса <var>A</var>&raquo;. В&nbsp;этом случае класс&nbsp;<var>A</var> также называется <strong>базовым</strong> классом, а&nbsp;<var>B</var>&nbsp;&mdash; <strong>производным</strong> классом.</p>
<p>Наследование является способом переиспользования кода между классами без необходимости нарушения инкапсуляции. Это достигается за&nbsp;счет того, что производный класс может пользоваться атрибутами и&nbsp;методами базового класса (иными словами, производный класс наследует атрибуты и&nbsp;методы базового класса).</p>
</section>
<p>Наследование&nbsp;&mdash; важная концепция объектно-ориентированного программирования наряду с&nbsp;инкапсуляцией и&nbsp;полиморфизмом.</p>
</section>
<section class="material__chapter">
<h2 id="2">Иерархия классов</h2>
<p>Используя отношение &laquo;частный случай&raquo;, можно строить иерархии классов. Добавим к&nbsp;нашим классам еще один, представляющий произвольную геометрическую фигуру (<var>Shape</var>):</p>
<pre><code class="language-python">class Shape:
    pass
</code></pre>
<p>Тогда иерархия классов будет выглядеть так:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-33/inheritance.svg" width="680" height="auto" /></div>
<p>В&nbsp;этом и&nbsp;следующем уроках мы&nbsp;узнаем, как отразить эту иерархию в&nbsp;коде.</p>
<p>Чтобы наследовать класс&nbsp;<var>B</var> от&nbsp;класса&nbsp;<var>A</var> (то&nbsp;есть запрограммировать отношение &laquo;класс&nbsp;<var>B</var> является частным случаем класса&nbsp;<var>A</var>&raquo;), нужно написать так:</p>
<pre><code class="language-python">class A:
    pass


class B(A):
    pass
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Механизм наследования</h2>
<p><strong>Вопрос:</strong> Что происходит, когда класс&nbsp;<var>B</var> наследуется от&nbsp;класса&nbsp;<var>A</var> (т.&nbsp;е. когда мы&nbsp;пишем <code>class B(A)</code>)?</p>
<p><strong>Ответ:</strong> Меняется процедура поиска методов и&nbsp;атрибутов в&nbsp;классе&nbsp;<var>B</var>.</p>
<p>Разберем, как именно.</p>
<p>Мы&nbsp;знаем, что у&nbsp;&laquo;простого&raquo; объекта (который ни&nbsp;от&nbsp;кого не&nbsp;наследуется, а&nbsp;вернее, наследуется от&nbsp;<var>object</var>) нельзя вызвать несуществующий метод или прочитать несуществующий атрибут:</p>
<pre><code class="language-python">class C:
    def foo(self):
        print('foo')


c = C()
c.foo()  # ok
c.bar()  # error
</code></pre>
<pre><samp>foo

------------------------------------------------------------------

AttributeError                   Traceback (most recent call last)

&lt;ipython-input-4-de63cbd4e47c&gt; in &lt;module&gt;()
      6 c = C()
      7 c.foo()  # ok
----&gt; 8 c.bar()  # not ok
    

    AttributeError: 'C' object has no attribute 'bar'</samp></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Если класс наследован от&nbsp;другого класса, проверка существования метода (или атрибута) осуществляется так:</p>
<ul>
<li>Сперва метод ищется в&nbsp;исходном (производном) классе</li>
<li>Если его там нет, он&nbsp;ищется в&nbsp;базовом классе</li>
<li>Предыдущие шаги повторяются до&nbsp;тех пор, пока метод не&nbsp;будет найден или пока процедура не&nbsp;дойдет до&nbsp;класса, который ни&nbsp;от&nbsp;кого не&nbsp;наследуется</li>
</ul>
</section>
<p>А&nbsp;это означает, что производному классу доступны не&nbsp;только собственные методы, но&nbsp;и&nbsp;методы базового класса. В&nbsp;этом случае говорят, что производный класс наследует методы базового класса.</p>
<pre><code class="language-python">class BaseC:
    def bar(self):
        print('bar')


class C(BaseC):
    def foo(self):
        print('foo')
        

c = C()
c.foo()  # ok    -- этот метод есть в производном классе
c.bar()  # ok    -- этот метод есть в базовом классе
c.baz()  # error -- этого метода нет ни в производном, ни в базовом классе
</code></pre>
<p>Как видим, в&nbsp;производные классы можно не&nbsp;только добавлять новые методы, но&nbsp;и&nbsp;пользоваться методами базового класса. В&nbsp;этом и&nbsp;состоит польза наследования методов: оно позволяет обойтись без дублирования кода и&nbsp;при этом не&nbsp;нарушает инкапсуляцию.</p>
</section>
<section class="material__chapter">
<h2 id="4">Наследование на&nbsp;примере геометрических фигур</h2>
<p>Рассмотрим механизм наследования подробнее на&nbsp;примере нашей иерархии геометрических фигур.</p>
<p>Для начала исследуем, как производные классы могут пользоваться методами базового класса. Для этого реализуем в&nbsp;классе <var>Shape</var> метод <var>describe</var>, который будет печатать название собственного класса:</p>
<pre><code class="language-python">class Shape:
    def describe(self):
        # Атрибут __class__ содержит класс или тип объекта self
        # Атрибут __name__ содержит строку, 
        # в которой написано название класса или типа
        print(f"Класс: {self.__class__.__name__}")
</code></pre>
<p>Унаследуем от&nbsp;<var>Shape</var> классы <var>Circle</var> и&nbsp;<var>Rectangle</var> и&nbsp;убедимся, что метод <var>describe</var> работает и&nbsp;для них тоже:</p>
<pre><code class="language-python">from math import pi


class Circle(Shape):
    def __init__(self, radius):
        self.r = radius

    def area(self):
        return pi * self.r ** 2


class Rectangle(Shape):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def area(self):
        return self.a * self.b


shape = Shape()
shape.describe()

circle = Circle(1)
circle.describe()

rectangle = Rectangle(1, 2)
rectangle.describe()
</code></pre>
<pre><samp>Класс: Shape
Класс: Circle
Класс: Rectangle</samp></pre>
<p>Теперь рассмотрим, как добавить в&nbsp;производный класс новый метод, которого нет в&nbsp;базовом классе.</p>
<p>Добавим в&nbsp;класс <var>Circle</var> метод <var>square</var>, который решает знаменитую задачу <strong>квадратуры круга: </strong>возвращает квадрат (в&nbsp;нашем случае&nbsp;&mdash; объект <var>Rectangle</var> с&nbsp;равными сторонами), который по&nbsp;площади равен площади исходного круга.</p>
<p>Математики много столетий бились над задачей квадратуры круга и&nbsp;в&nbsp;итоге доказали, что такое построение нельзя выполнить с&nbsp;помощью циркуля и&nbsp;линейки.</p>
<p>Зато это можно сделать с&nbsp;помощью Python:</p>
<pre><code class="language-python">class Circle(Shape):
    def __init__(self, radius):
        self.r = radius

    def area(self):
        return pi * self.r ** 2

    def square(self):
        side = pi ** 0.5 * self.r
        return Rectangle(side, side)


circle = Circle(1)
square = circle.square()

print(f"Площадь круга:    {circle.area()}")
print(f"Площадь квадрата: {square.area()}")
print(f"Радиус круга: {circle.r}")
print(f"Длина стороны квадрата: {square.a}")
</code></pre>
<pre><samp>Площадь круга:    3.141592653589793
Площадь квадрата: 3.1415926535897927
Радиус круга: 1
Длина стороны квадрата: 1.7724538509055159</samp></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>