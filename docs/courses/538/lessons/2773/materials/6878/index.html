<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Рекурсия </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Рекурсия</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Рекурсия</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Факториал и&nbsp;число сочетаний</a></li>
<li><a class="material__link" href="#2">Определение рекурсии, принцип работы</a></li>
<li><a class="material__link" href="#3">Опасность использования рекурсивных алгоритмов или что может пойти не&nbsp;так</a></li>
<li><a class="material__link" href="#4">Красота требует жертв?</a></li>
<li><a class="material__link" href="#5">Несколько рекурсивных веток. Деревья</a></li>
<li><a class="material__link" href="#6">Бонус. Решаем судоку</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Сегодня мы&nbsp;познакомимся с&nbsp;понятием рекурсии, покажем ее&nbsp;связь с&nbsp;уже известными нам конструкциями (циклами и&nbsp;функциями). Разберем наиболее часто встречающиеся ошибки и&nbsp;классические примеры.</p>
</section>
<section class="material__chapter">
<h2 id="1">Факториал и&nbsp;число сочетаний</h2>
<p>Задача на&nbsp;сочетания&nbsp;&mdash; простейшая комбинаторная задача на&nbsp;сочетания без повторений: сколькими способами можно из&nbsp;данных n&nbsp;предметов выбрать некоторые k&nbsp;предметов, если порядок их&nbsp;выбора не&nbsp;важен?</p>
<p>Ответом на&nbsp;эту задачу является величина:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/recurs/recurs-1.png" width="155" height="auto" /></div>
<p>называемая числом сочетаний из&nbsp;n&nbsp;элементов по&nbsp;k.</p>
<p>Запись&nbsp;n! обозначает произведение 1 &middot; 2 &middot; 3 &middot; ... &middot; n, называемое факториалом числа&nbsp;n (мы&nbsp;уже неоднократно сталкивались с&nbsp;данным понятием), при этом считается, что 0! = 1. Приведем &laquo;красивое&raquo; математическое определение факториала:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/recurs/recurs-2.png" width="299" height="auto" /></div>
<p>Давайте напишем функцию, вычисляющую факториал числа n&nbsp;классическим способом, и&nbsp;проверим ее&nbsp;работу.</p>
<pre><code class="language-python"># Вычисление факториала
def factorial(number):
    result = 1
    for index in range(2, number + 1):
        result *= index
    return result


for i in range(10):
    print(i, factorial(i))
</code></pre>
<p>Обратите внимание на&nbsp;красивый способ вычисления факториала в&nbsp;стиле языка Python:</p>
<pre><code class="language-python">from functools import reduce

def cool_factorial(number):
    return reduce(lambda x, y: x * y, range(2, number + 1), 1)

for i in range(10):
    print(i, cool_factorial(i))
</code></pre>
</section>
<section class="material__chapter">
<h2 id="2">Определение рекурсии, принцип работы</h2>
<p>Однако задачу вычисления факториала можно решить иначе. В&nbsp;математике очень часто для упрощения вычислений исходную задачу сводят к&nbsp;более простым.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Рекурсия</strong></p>
<p>В&nbsp;итоге можно прийти к&nbsp;тому, что будет вызвана первоначальная задача, но&nbsp;в&nbsp;несколько упрощенной форме. Такой прием называется рекурсией (от&nbsp;лат. recurcio&nbsp;&mdash; &laquo;возвращение&raquo;).</p>
<p>Итак, <strong>рекурсия</strong> в&nbsp;программировании&nbsp;&mdash; прием, когда функция может вызывать сама себя прямо либо косвенно (через другую функцию, при этом обе функции являются рекурсивными).</p>
</section>
<p>Давайте еще раз посмотрим на&nbsp;определение факториала и&nbsp;обратим внимание на&nbsp;выделенный жирным фрагмент:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/recurs/recurs-3.png" width="311" height="auto" /></div>
<p>Можно увидеть, что <strong>1 &middot; 2 &middot; 3 &middot; ... &middot; (n&nbsp;&minus; 1)</strong>, не&nbsp;что иное, как факториал числа n&nbsp;&minus; 1. Поэтому определение факториала можно записать в&nbsp;сокращенном виде:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/recurs/recurs-4.png" width="201" height="auto" /></div>
<p>Вернемся к&nbsp;нашей задаче и&nbsp;рассмотрим функцию вычисления факториала с&nbsp;несколько другой стороны, постараемся применить рекурсию. Известно, что 0! = 1, 1! = 1. А&nbsp;как вычислить величину&nbsp;n! для большого&nbsp;n? Если&nbsp;бы мы&nbsp;могли вычислить величину (n&nbsp;&minus; 1)!, тогда мы&nbsp;легко вычислим&nbsp;n!, поскольку&nbsp;n! = n &middot; (n&nbsp;&minus; 1)!. Но&nbsp;как вычислить (n&nbsp;&minus; 1)!? Если&nbsp;бы мы&nbsp;вычислили (n&nbsp;&minus; 2)!, мы&nbsp;сможем вычислить&nbsp;и (n&nbsp;&minus; 1)! = (n&nbsp;&minus; 1) &middot; (n&nbsp;&minus; 2)!. А&nbsp;как вычислить (n&nbsp;&minus; 2)!? Если&nbsp;бы... В&nbsp;конце концов, мы&nbsp;дойдем до&nbsp;величины&nbsp;0!, которая равна 1. Таким образом, для вычисления факториала мы&nbsp;можем использовать значение факториала для меньшего числа.</p>
<p>Давайте напишем соответствующую функцию:</p>
<pre><code class="language-python"># Рекурсивное вычисление факториала
def rec_factorial(number):
    if number == 0:
        return 1
    else:
        return number * rec_factorial(number - 1)
</code></pre>
<p>Логическая сложность рекурсивных функций заключается в&nbsp;изменении параметров и&nbsp;особенностях получения промежуточных результатов при последовательном обращении подпрограммы к&nbsp;себе. Выполняется две серии шагов. Первая серия&nbsp;&mdash; шаги рекурсивного погружения подпрограмм в&nbsp;себя до&nbsp;тех пор, пока выбранный параметр не&nbsp;достигнет граничного значения (<strong>глубина рекурсии</strong>). Вторая серия&nbsp;&mdash; шаги рекурсивного выхода до&nbsp;тех пор, пока значение выбранного параметра не&nbsp;достигнет начального. Она, как правило, и&nbsp;обеспечивает получение промежуточных и&nbsp;конечных результатов.</p>
<p>Вот так работает рекурсивная функция вычисления факториала:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/recurs/factorial%20-%20new.svg" width="680" height="auto" /></div>
<p>В&nbsp;общем случае рекурсия тяготеет к&nbsp;<span style="text-decoration: underline; color: #0000ff;"><a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://ru.wikipedia.org/wiki/Декларативное_программирование" target="_blank" rel="noopener noreferrer">декларативному</a></span> стилю программированию. Если в&nbsp;двух словах: когда мы&nbsp;пишем императивную функцию (как делали все время до&nbsp;этого), отвечаем на&nbsp;вопрос, <strong>как</strong> достигнуть необходимого результата, а&nbsp;когда создаем декларативную&nbsp;&mdash; на&nbsp;вопрос, <strong>что</strong> такое наш результат.</p>
<p>Поэтому в&nbsp;<strong>любой</strong> рекурсивной функции должно быть как минимум <strong>две</strong> ветки развития &laquo;сюжета&raquo;:</p>
<ol>
<li>Основная.</li>
<li>Точка выхода.</li>
</ol>
<p>Сама функция при этом получается <strong>декларативной</strong>: она повторяет практически один в&nbsp;один определение факториала.</p>
</section>
<section class="material__chapter">
<h2 id="3">Опасность использования рекурсивных алгоритмов или что может пойти не&nbsp;так</h2>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Наиболее распространенной ошибкой при использовании рекурсии является бесконечная рекурсия, когда цепочка вызовов функций никогда не&nbsp;завершается и&nbsp;продолжается, пока не&nbsp;кончится свободная память в&nbsp;компьютере.</p>
</section>
<p>Определим две наиболее распространенные причины для бесконечной рекурсии на&nbsp;примере некорректно написанной функции нахождения факториала числа.</p>
<pre><code class="language-python">def rec_factorial(number):
    return number * rec_factorial(number - 1)
</code></pre>
<pre><code class="language-python">def rec_factorial(number):
    if number == 0:
        return 1
    else:
        return number * rec_factorial(number)
</code></pre>
<p>Итак, при разработке рекурсивной функции необходимо прежде всего оформлять условия завершения рекурсии и&nbsp;думать, почему рекурсия когда-либо завершит работу.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Еще одна проблема, связанная с&nbsp;использованием рекурсивных функций,&nbsp;&mdash; нетривиальность задачи оценки сложности и&nbsp;эффективности алгоритма. Сложность этих алгоритмов зависит не&nbsp;только от&nbsp;сложности внутренних циклов, но&nbsp;и&nbsp;от&nbsp;количества итераций рекурсии. Рекурсивная процедура может выглядеть достаточно простой, но&nbsp;она может серьезно усложнить программу, многократно вызывая себя.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="4">Красота требует жертв?</h2>
<p>Напишем функцию перевода числа из&nbsp;десятичной системы счисления в&nbsp;двоичную (а&nbsp;на&nbsp;самом деле и&nbsp;в&nbsp;любую другую позиционную систему).</p>
<p>Для начала вспомним базовый алгоритм перевода:</p>
<p><strong>Шаг 1.</strong> Разделить число на&nbsp;основание системы счисления, в&nbsp;которую осуществляется перевод (в&nbsp;нашем случае&nbsp;&mdash; два). Записать остаток.</p>
<p><strong>Шаг 2.</strong> Если результат деления больше двух или равен двум, продолжать делить его на&nbsp;два&nbsp;до&nbsp;тех пор, пока результат деления не&nbsp;станет равен&nbsp;единице.</p>
<p><strong>Шаг 3.</strong> Выписать результат последнего деления и&nbsp;все остатки от&nbsp;деления в&nbsp;обратном порядке в&nbsp;одну строку.</p>
<p>Рассмотрим на&nbsp;примере перевода числа 136&nbsp;в двоичную систему счисления:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/recurs/Sistemy.svg" width="680" height="auto" /></div>
<p>136<sub>10</sub> = 10001000<sub>2</sub></p>
<p>Декларативное описание этой функции звучит так:</p>
<ol>
<li>Если число <var>a</var> больше единицы, напечатаем перевод в&nbsp;двоичную систему числа, равного целой части от&nbsp;деления <var>a</var> на&nbsp;два.</li>
<li>В&nbsp;противном случае напечатаем остаток от&nbsp;деления <var>a</var> на&nbsp;два.</li>
</ol>
<p>С&nbsp;помощью рекурсии реализовать этот алгоритм можно очень красивым и&nbsp;лаконичным кодом.</p>
<pre><code class="language-python">def bin(a):
  if a &gt; 1:
    bin(a // 2)
  print(a % 2, end="")
</code></pre>
<p>Теперь напишем функцию, которая вычисляет НОД (наибольший общий делитель) пары чисел&nbsp;А и&nbsp;B.</p>
<p>Определение:</p>
<ol>
<li>Если число <var>b</var> равно&nbsp;0, вернем число <var>a</var>.</li>
<li>В&nbsp;противном случае вернем значение функции (рекурсия) от&nbsp;числа <var>b</var> и&nbsp;остатка от&nbsp;деления числа <var>a</var> на&nbsp;число <var>b</var>.</li>
</ol>
<pre><code class="language-python">def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

print(gcd(16, 24))
</code></pre>
<p>И&nbsp;последний пример: функция, которая удаляет из&nbsp;строки <var>s</var>&nbsp;все вхождения символа&nbsp;<var>e</var>.</p>
<pre><code class="language-python">def del_all_e(s, e):
    if not s:
        return s
    elif e == s[0]:
        return del_all_e(s[1:], e)
    else:
        return s[0] + del_all_e(s[1:], e)
    
    
print(del_all_e("мама мыла раму", "а"))
</code></pre>
</section>
<section class="material__chapter">
<h2 id="5">Несколько рекурсивных веток. Деревья</h2>
<p>Рассмотрим в&nbsp;качестве примера функцию, вычисляющую числа Фибоначчи.</p>
<p>Числа Фибоначчи&nbsp;&mdash; ряд чисел: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89..., в&nbsp;котором два первых элемента равны&nbsp;1, а&nbsp;каждый следующий&nbsp;&mdash; сумме двух предыдущих. Удивительно, что отношение двух соседних чисел Фибоначчи стремится к&nbsp;числу золотого сечения: 1,6180339887.</p>
<p>Составим рекурсивное определение этих чисел и&nbsp;сразу запишем его в&nbsp;виде функции:</p>
<pre><code class="language-python">def rec_fib(n):
    if 0 &lt; n &lt;= 2:
        return 1
    else:
        return rec_fib(n - 1) + rec_fib(n - 2)
</code></pre>
<p>Это удивительно, но&nbsp;программа почти слово в&nbsp;слово совпадает с&nbsp;определением чисел Фибоначчи!</p>
<p>Однако в&nbsp;этом примере мы&nbsp;столкнулись с&nbsp;новым типом рекурсии, в&nbsp;котором функция порождает целых <strong>две</strong> рекурсивные ветки. Неявно во&nbsp;время выполнения программы мы&nbsp;обходим дерево в&nbsp;глубину. Проиллюстрируем это на&nbsp;примере <code>fib(6)</code>:</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/recurs/fib6%20-%20new.svg" width="680" height="auto" /></div>
<p>Важно понимать, что экземпляры функции выполняются не&nbsp;параллельно, а&nbsp;в&nbsp;детерминированной (то&nbsp;есть определенной) последовательности: сначала левое поддерево, а&nbsp;потом все правое поддерево из&nbsp;любой вершины.</p>
<p>Интересно и&nbsp;то, что дерево очень быстро разрастается при росте номера числа Фибоначчи, что влечет замедление программы и&nbsp;трату памяти.</p>
<p>Кстати, следующее число Фибоначчи вычисляется ровно в&nbsp;золотое сечение раз медленнее, чем предыдущее. Таким образом, <code>fib(500)</code> будет получено уже после того, как исчезнет Солнечная система.</p>
<p>Следующий пример демонстрирует этот факт. Запустите его и&nbsp;убедитесь:</p>
<pre><code class="language-python">from time import time

for i in range(30, 35):
    s = time()
    print(i, rec_fib(i), "%.03f" % (time() - s))
</code></pre>
<p>А&nbsp;теперь запустите простой императивный вариант:</p>
<pre><code class="language-python">from time import time

def fib(n):
    a, b = 1, 1
    for _ in range(n - 2):
        a, b = b, a + b
    return b


for i in range(30, 35):
    s = time()
    print(i, fib(i), "%.03f" % (time() - s))
</code></pre>
<p>Второй вариант работает существенно быстрее.</p>
<p>А&nbsp;все потому, что в&nbsp;рекурсивном случае мы&nbsp;много раз вычисляем одно и&nbsp;то&nbsp;же&nbsp;число Фибоначчи. Никакого <strong>кеширования</strong> (запоминания предыдущих вычислений) не&nbsp;происходит. Кстати, оптимизации типа кеширования присутствуют по&nbsp;умолчанию в&nbsp;функциональных языках (LISP, Haskell). В&nbsp;Python включать такой функционал надо вручную.</p>
<p>В&nbsp;следующем примере запоминаются последние 1000 вызовов функции <var>fib</var>.</p>
<pre><code class="language-python">from time import time
from functools import lru_cache


@lru_cache(maxsize=1000)
def rec_fib(n):
    if 0 &lt; n &lt;= 2:
        return 1
    else:
        return rec_fib(n - 1) + rec_fib(n - 2)


for i in range(30, 35):
    s = time()
    print(i, rec_fib(i), "%.03f" % (time() - s))
</code></pre>
<p>Ну&nbsp;вот, теперь все работает быстро.</p>
<p>Перейдем к главному выводу.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Рекурсивный метод обеспечивает удобный обход списка, дерева или графа, при этом контролируя перемещение по&nbsp;элементам и&nbsp;возвращение к&nbsp;предыдущим состояниям. Этим можно пользоваться во&nbsp;многих математических и&nbsp;прикладных задачах.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="6">Бонус. Решаем судоку</h2>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/image/sudoku.png" width="400" height="auto" /></div>
<p>Вы&nbsp;уже могли сталкиваться с&nbsp;этой задачей раньше. Вспомните, как мы&nbsp;ее&nbsp;решали? Попробуем теперь предложить иной способ.</p>
<p>Предположим, что нам нужно сделать программу, которая разгадывает судоку. Пусть поле моделируется списком списков с&nbsp;целыми числами:</p>
<pre><code class="language-python">field = [
    [0,0,0,0,0,0,0,0,0],
    [0,1,0,0,2,0,0,3,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,4,0,0,5,0,0,6,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,7,0,0,8,0,0,9,0],
    [0,0,0,0,0,0,0,0,0],
]
</code></pre>
<p>Сформулируем рекурсивный алгоритм решения судоку.</p>
<ul>
<li>Если на&nbsp;поле судоку нет пустых клеток, оно уже решено и&nbsp;надо просто вернуть поле в&nbsp;качестве решения</li>
<li>Если есть пустые клетки, надо вычислить какую-либо пустую клетку, для которой количество возможных вариантов минимально. Попробовать по&nbsp;очереди проверять эти варианты, и, если будет найдено решение, вернуть его</li>
</ul>
<p>Сама функция будет не&nbsp;сильно больше данного описания:</p>
<pre><code class="language-python">from pprint import pprint
from copy import deepcopy
from random import shuffle
from time import clock

"""
Для всех клеток на основе ограничений 
возвращает список возможных чисел, например:
(0, 0, {2, 3, 4, 5, 6, 7, 8, 9})
(0, 1, {2, 3, 5, 6, 8, 9})
(0, 2, {2, 3, 4, 5, 6, 7, 8, 9})
(0, 3, {1, 3, 4, 5, 6, 7, 8, 9})
(0, 4, {1, 3, 4, 6, 7, 9})
(0, 5, {1, 3, 4, 5, 6, 7, 8, 9})
(0, 6, {1, 2, 4, 5, 6, 7, 8, 9})
(0, 7, {1, 2, 4, 5, 7, 8})
(0, 8, {1, 2, 4, 5, 6, 7, 8, 9})
(1, 0, {4, 5, 6, 7, 8, 9})
"""


def get_variants(sudoku):
    variants = []
    for i, row in enumerate(sudoku):
        for j, value in enumerate(row):
            if not value:
                # значения в строке
                row_values = set(row)
                # значения в столбце
                column_values = set([sudoku[k][j] for k in range(9)])
                # в каком квадрате 3x3 находится клетка? 
                # Координаты этого квадрата
                sq_y = i // 3
                sq_x = j // 3
                square3x3_values = set([
                    sudoku[m][n]
                    for m in range(sq_y * 3, sq_y * 3 + 3)
                    for n in range(sq_x * 3, sq_x * 3 + 3)
                ])
                exists = row_values | column_values | square3x3_values
                # какие значения остались?
                values = set(range(1, 10)) - exists
                variants.append((i, j, values))

    return variants


def solve(sudoku):
    # Если судоку заполнено, это ответ
    if all([k for row in sudoku for k in row]):
        return sudoku

    # Иначе посмотрим все варианты
    variants = get_variants(sudoku)

    # Выберем тот, у которого меньше всего возможностей.
    x, y, values = min(variants, key=lambda x: len(x[2]))

    # Попробуем все по очереди
    for v in values:
        # deepcopy создает полную копию списка с учетом всех вложенностей
        new_sudoku = deepcopy(sudoku)
        new_sudoku[x][y] = v
        # Если оно решилось, возвратим ответ.
        s = solve(new_sudoku)
        if s:
            return s
    return None


s = clock()
pprint(
    solve([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 2, 0, 0, 3, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 4, 0, 0, 5, 0, 0, 6, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 7, 0, 0, 8, 0, 0, 9, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]))
print('Затраченное время:', clock() - s, 'сек')
</code></pre>
<p>А&nbsp;вот еще один пример рекурсивного решения задачи. Он&nbsp;гораздо короче, но&nbsp;в&nbsp;нем есть <strong>питоновские</strong> штуки.</p>
<pre><code class="language-python">from random import shuffle
from copy import deepcopy
from pprint import pprint


def make_assumptions(sudoku):
    for i, row in enumerate(sudoku):
        for j, value in enumerate(row):
            if not value:
                values = set(row) \
                         | set([sudoku[k][j] for k in range(9)]) \
                         | set([sudoku[m][n] for m in range((i // 3) * 3, (i // 3) * 3 + 3)
                                for n in range((j // 3) * 3, (j // 3) * 3 + 3)])
                yield i, j, list(set(range(1, 10)) - values)


def solve(sudoku):
    if all([k for row in sudoku for k in row]):
        return sudoku
    assumptions = list(make_assumptions(sudoku))
    shuffle(assumptions)

    x, y, values = min(assumptions, key=lambda x: len(x[2]))

    for v in values:
        new_sudoku = deepcopy(sudoku)
        new_sudoku[x][y] = v
        s = solve(new_sudoku)
        if s:
            return s
    return None


pprint(solve(field))
</code></pre>
<p>Два предыдущих примера демонстрируют преимущество рекурсии&nbsp;&mdash; написание коротких и&nbsp;легко читаемых программ.</p>
<p>Попробуйте сравнить эти программы с&nbsp;императивным вариантом (без использования рекурсии).</p>
<p>С&nbsp;рекурсией вы&nbsp;еще встретитесь много раз. Помните: это <strong>не&nbsp;панацея</strong>, но&nbsp;позволяет элегантно и&nbsp;эффективно решать широкий круг задач.</p>
<p>А&nbsp;пока&nbsp;&mdash; все, переходите к&nbsp;задачам!</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>