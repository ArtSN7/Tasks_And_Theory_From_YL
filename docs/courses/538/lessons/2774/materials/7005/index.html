<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Итераторы и коллекции </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Итераторы</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Итераторы и&nbsp;коллекции</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Итерируемые объекты: итераторы и&nbsp;коллекции</a></li>
<li><a class="material__link" href="#2">Встроенные итераторы. Комбинирование итераторов</a></li>
<li><a class="material__link" href="#3">Совместные действия над коллекциями. Функция zip</a></li>
<li><a class="material__link" href="#4">Модуль itertools</a></li>
<li><a class="material__link" href="#5">Свертка итератора. Функция reduce</a></li>
<li><a class="material__link" href="#6">Группировка элементов. Функция groupby</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Дополнительные материалы посвящены более подробному изучению темы итераторов и&nbsp;их&nbsp;отличий от&nbsp;коллекций. Мы&nbsp;поговорим, как при помощи итераторов выполнять ленивые вычисления, позволяющие работать даже с&nbsp;бесконечными коллекциями объектов.</p>
<p>Хотя мы&nbsp;не&nbsp;собираемся рассматривать все возможности итераторов Python, мы&nbsp;начнем знакомство с&nbsp;модулем itertools. И&nbsp;разберем функцию свертки и&nbsp;группировки итераторов.</p>
</section>
<section class="material__chapter">
<h2 id="1">Итерируемые объекты: итераторы и&nbsp;коллекции</h2>
<p>Если подходить более формально, существует два типа итерируемых объектов. Первые называются итераторами.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Итератор</strong></p>
<p>Итератор&nbsp;&mdash; специальный объект, который позволяет поочередно перебирать элементы. Его можно представить как стрелочку, которая указывает на&nbsp;какой-то элемент коллекции и&nbsp;постепенно двигается по&nbsp;ней.</p>
</section>
<p>Если итератор передать в&nbsp;функцию <var>next</var>, функция вернет в&nbsp;качестве результата следующий элемент. При этом сам итератор тоже &laquo;сдвинется&raquo; на&nbsp;следующий элемент. При следующем вызове функция <var>next</var> вернет очередной элемент, и&nbsp;&laquo;стрелочка&raquo; снова сдвинется.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/iter_next%20-%20new.svg" width="680" height="auto" /></div>
<section class="material__note">
<p class="material__note-heading"><strong>Коллекции</strong></p>
<p>Второй тип итерируемых объектов&nbsp;&mdash; коллекции. Они не&nbsp;итераторы сами по&nbsp;себе, но&nbsp;позволяют создать итератор.</p>
<p>Чтобы это сделать, достаточно вызвать функцию <var>iter</var> и&nbsp;передать ей&nbsp;список в&nbsp;качестве аргумента. Бывает и&nbsp;так, что объект&nbsp;&mdash; сам себе итератор (например, поток ввода <var>stdin</var>).</p>
</section>
<p>Так, список не&nbsp;является итератором, зато для одного и&nbsp;того&nbsp;же списка можно создать сколько угодно итераторов-стрелочек, каждая из&nbsp;которых будет перебирать элементы от&nbsp;первого до&nbsp;последнего.</p>
<p><em>Напомним, что, так как большинство функций, которые работают с&nbsp;итераторами, умеют работать и&nbsp;с&nbsp;коллекциями, слова &laquo;итерируемый объект&raquo; и&nbsp;&laquo;итератор&raquo; мы&nbsp;будем использовать как синонимы.</em></p>
<p>Цикл <var>for</var> применяется к&nbsp;объектам второго типа. Внутри интерпретатора Python цикл <var>for</var> делает следующее:</p>
<ol>
<li>По&nbsp;объекту создает итератор.</li>
<li>Получает из&nbsp;итератора объекты по&nbsp;одному и&nbsp;каждый раз передает полученный объект в&nbsp;выполняемый блок кода.</li>
</ol>
<p>Благодаря этому в&nbsp;цикл <var>for</var> можно передать и&nbsp;список, и&nbsp;кортеж, и&nbsp;строку, и&nbsp;интервал <var>range</var>, и&nbsp;еще многие другие объекты, которые имеют свои итераторы. Впрочем, эти детали не&nbsp;так важны. Их&nbsp;полезно понимать, но&nbsp;пользоваться ими случается редко.</p>
<p>Итераторы позволяют очень разным объектам &laquo;притворяться одинаковыми&raquo;. Казалось&nbsp;бы, между строками и&nbsp;интервалами нет ничего общего, однако их&nbsp;можно итерировать, а&nbsp;значит, любой из&nbsp;этих объектов можно использовать в&nbsp;цикле <var>for</var>, функциях <code>filter/map</code> и&nbsp;мн.&nbsp;др.</p>
<p>Как уже говорилось, итератор может использовать любой алгоритм выдачи значения. Элементарный итератор просто перебирает значения в&nbsp;списке с&nbsp;первого до&nbsp;последнего. Еще один итератор&nbsp;&mdash; <var>range</var>&nbsp;&mdash; перебирает числа с&nbsp;шагом&nbsp;1.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Заметьте, что <var>range</var> не&nbsp;хранит весь набор чисел, которые будет перебирать. Он&nbsp;создает новое число только тогда, когда оно потребуется (а&nbsp;старые значения не&nbsp;хранит). Размер <var>range</var> и&nbsp;подобных итераторов не&nbsp;зависит от&nbsp;количества чисел, которые предполагается перебрать, ведь им&nbsp;нужно помнить только начало промежутка, его конец и&nbsp;текущий элемент. Это позволяет сделать итератор, который будет перебирать бесконечное число значений, не&nbsp;занимая много дополнительной памяти.</p>
</section>
<p>Например, итератор может перебирать все натуральные числа. Или все простые числа. Или перебирать элементы, количество которых заранее неизвестно. Если вы&nbsp;пробовали посчитать количество элементов, которые вернул <var>filter</var>, могли заметить, что вызов <code>len(filter(condition, collection))</code> не&nbsp;работает. Теперь понятно почему: <var>filter</var> возвращает не&nbsp;список, а&nbsp;итерируемый объект.</p>
<p>Функция <var>len</var> не&nbsp;работает с&nbsp;большей частью итерируемых объектов, ведь длина набора может быть очень большой или даже бесконечной. Для некоторых итераторов длину можно посчитать мгновенно, не&nbsp;перебирая элементы. Например, итератор <var>range</var> имеет заранее известное число объектов. Но&nbsp;для других итераторов невозможно посчитать длину, не&nbsp;проитерировав список полностью (например, невозможно узнать число четных элементов в&nbsp;списке, не&nbsp;проверив каждое число). Для итераторов, про которые заранее неизвестно, бесконечные они или нет, все еще хуже: функция <var>len</var> могла&nbsp;бы работать не&nbsp;просто долго, а&nbsp;вечно. От&nbsp;<var>len</var> такого не&nbsp;ожидаешь.</p>
<p>Если все-таки требуется получить все элементы, для этого есть уже встречавшаяся вам функция <var>list</var>. Она проходит по&nbsp;всем элементам итератора и&nbsp;собирает их&nbsp;в&nbsp;один список, который возвращает пользователю. Но&nbsp;<var>list</var> создаст промежуточный список. Есть более эффективный способ посчитать число элементов, возвращенных итератором, не&nbsp;создавая промежуточный список.</p>
<p>Как вы&nbsp;думаете, что вычисляет этот код?</p>
<pre><code class="language-python">sum(1 for value in filter(lambda x: x % 2 == 0, range(50 * 1000 * 1000)))
# =&gt; 25000000
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Мы&nbsp;использовали списочное выражение как аргумент функции <var>sum</var>, но&nbsp;не&nbsp;заключали его в&nbsp;квадратные скобки. Мы&nbsp;не&nbsp;используем значение, которое вернул итератор, а&nbsp;просто добавляем единицу к&nbsp;числу элементов.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="2">Встроенные итераторы. Комбинирование итераторов</h2>
<p>У&nbsp;итераторов есть замечательная особенность: их&nbsp;можно комбинировать. Это позволяет вместо огромных циклов с&nbsp;перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с&nbsp;другом. В&nbsp;заданиях прошлого урока вам уже приходилось комбинировать итераторы, возвращаемые функциями <var>filter</var> и&nbsp;<var>map</var>. В&nbsp;этот раз вы&nbsp;узнаете еще много способов комбинировать итераторы.</p>
<p>Начнем с&nbsp;итератора <var>enumerate</var>. Он&nbsp;решает такую задачу: представьте, что вы&nbsp;перебираете элементы списка при помощи итератора, но&nbsp;при этом хотите знать не&nbsp;только элемент, но&nbsp;и&nbsp;его номер. Можно завести вспомогательную переменную и&nbsp;изменять ее&nbsp;в&nbsp;цикле, перебирающем элементы. Однако для лямбда-функций, передаваемых в&nbsp;функции высшего порядка, этот способ уже не&nbsp;работает.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Enumerate</strong></p>
<p><var>Enumerate</var> вместо элементов исходного итератора возвращает кортежи, состоящие из&nbsp;номера элемента по&nbsp;порядку и&nbsp;самого элемента.</p>
<p>В&nbsp;следующем примере формируется список из&nbsp;подобных кортежей с&nbsp;использованием списочного выражения:</p>
<pre><code class="language-python">arr = ['This', 'is', 'third', 'word']
print([pair for pair in enumerate(arr)])
# =&gt; [(0, 'This'), (1, 'is'), (2, 'third'), (3, 'word')]
</code></pre>
</section>
<p>Обратите внимание на&nbsp;следующий пример: аргумент со&nbsp;звездочкой может быть не&nbsp;только списком, но&nbsp;и&nbsp;итератором (как сделано в&nbsp;примере у&nbsp;функции <var>print</var>). Если перед итератором поставить звездочку, его элементы станут аргументами функции:</p>
<pre><code class="language-python">arr = ['This', 'is', 'third', 'word']
print(*enumerate(arr))
# =&gt; (0, 'This') (1, 'is') (2, 'third') (3, 'word')
</code></pre>
<p>Давайте теперь найдем номера строк, имеющих лишь две буквы. Если&nbsp;бы мы&nbsp;запустили обычный <var>filter</var>, нашли&nbsp;бы только сами слова без номеров. <var>Enumerate</var>&nbsp;же передаст нам еще и&nbsp;номера:</p>
<pre><code class="language-python">filtered_values = filter(lambda index_value: len(index_value[1]) == 2, 
                         enumerate(arr))
print(*filtered_values)
# =&gt; (1, 'is')
</code></pre>
<p>Теперь достаточно преобразовать пары номер-элемент в&nbsp;номера. Это делается тривиально:</p>
<pre><code class="language-python">map(lambda index_value: index_value[0], 
    filter(lambda index_value: len(index_value[1]) == 2, enumerate(arr)))
</code></pre>
<p>Если у&nbsp;<var>enumerate</var> указать второй аргумент, отсчет начнется не&nbsp;с&nbsp;нуля, а&nbsp;с&nbsp;этого числа. Примеры можно посмотреть в&nbsp;<span style="text-decoration: underline; color: #0000ff;"><a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://docs.python.org/3/library/functions.html#enumerate" target="_blank" rel="noopener noreferrer">документации</a></span>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Всегда стоит следить за&nbsp;тем, какие данные приходят в&nbsp;функцию преобразования и&nbsp;какие выходят. От&nbsp;порядка, в&nbsp;котором комбинируются функции, зависит результат.</p>
</section>
<p>Рассмотрим два варианта. Вам передается набор строк, которые вы&nbsp;должны пронумеровать и&nbsp;выбросить пустые строки. В&nbsp;одном случае пустые строки следует учитывать в&nbsp;нумерации, а&nbsp;в&nbsp;другом&nbsp;&mdash; пропускать.</p>
<pre><code class="language-python"># Вариант 1: сначала пронумеровали все строки, а потом отбросили пустые
lines = ['Занумеруем', '', '', 'строки']
results = filter(lambda indexed_line: indexed_line[1], enumerate(lines, 1))
print(*results)
# =&gt; (1, 'Занумеруем') (4, 'строки')

# Вариант 2: сначала отбросили пустые строки,
# а потом пронумеровали оставшиеся
lines = ['Занумеруем', '', '', 'строки']
results = enumerate(filter(lambda line: line, lines), 1)
print(*results)
# =&gt; (1, 'Занумеруем') (2, 'строки')
</code></pre>
<p>Разберем еще одну задачу. При разборе мы&nbsp;будем выписывать, какие данные и&nbsp;в&nbsp;какой форме получаются на&nbsp;каждом этапе.</p>
<p>Рассмотрим пример:</p>
<p><em>Какие по&nbsp;счету високосные годы, начиная с&nbsp;1582 года до&nbsp;2017, имели сумму цифр, равную 9? Високосный год&nbsp;&mdash; год, который делится на&nbsp;4, но&nbsp;при этом не&nbsp;делится на&nbsp;100 либо делится на&nbsp;400.</em></p>
<p>Прежде чем писать программу, давайте разберемся, как можно было&nbsp;бы решить задачу, имея только лист бумаги и&nbsp;ручку.</p>
<ul>
<li>На&nbsp;первом этапе мы&nbsp;выпишем все годы от&nbsp;1582 до&nbsp;2017</li>
<li>Затем выберем из&nbsp;них високосные</li>
<li>Пронумеруем их</li>
<li>Выберем те (уже пронумерованные), сумма цифр которых равна&nbsp;9</li>
<li>Оставим от&nbsp;нумерованных годов только нумерацию. Готово!</li>
</ul>
<p>Теперь дословно запишем это в&nbsp;коде. Мы&nbsp;напишем отдельную функцию для вычисления суммы цифр, а&nbsp;все остальное запишем в&nbsp;форме комбинации итераторов.</p>
<pre><code class="language-python">def sum_digits(number):
    sum = 0
    while number != 0:
        sum += number % 10
        number //= 10
    return sum

years_range = range(1582, 2018)

is_leap_year = lambda year: (year % 4 == 0 and year % 100 != 0 or
                             year % 400 == 0)
leap_years = filter(is_leap_year, years_range)

indexed_years = enumerate(leap_years)
selected_indexed_years = filter(
    lambda index_and_year: sum_digits(index_and_year[1]) == 9, indexed_years)
year_indices = [index_and_year[0] for index_and_year in selected_indexed_years]
print(year_indices)
# =&gt; [9, 105]
</code></pre>
<p>Выполните этот код, после каждого шага выводя получившееся значение. Если вам приходится выводить итератор, перед этим превратите его в&nbsp;список, чтобы иметь возможность изучить &laquo;содержимое&raquo; получившегося итератора.</p>
<p>После того как поймете и&nbsp;проследите каждый этап, можно немного упростить эти выражения. Хотя всю программу можно записать одной строчкой, мы&nbsp;так делать не&nbsp;будем: код будет почти невозможно прочитать.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>До&nbsp;какой степени объединять код, чтобы вам было удобно его читать, зависит от&nbsp;субъективных факторов. С&nbsp;одной стороны, очень длинная команда может с&nbsp;трудом восприниматься. С&nbsp;другой&nbsp;&mdash; когда в&nbsp;программе результат каждого этапа вычислений вынесен в&nbsp;отдельную переменную, тяжело следить уже за&nbsp;этими переменными.</p>
</section>
<p>Таким образом, исходную задачу можно очень компактно решить только средствами итераторов:</p>
<pre><code class="language-python">leap_years = filter(lambda year: (year % 4 == 0 and year % 100 != 0 or 
                                  year % 400 == 0), range(1582, 2018))
selected_indexed_years = filter(lambda index_and_year: sum(
    map(int, str(index_and_year[1]))) == 9, enumerate(leap_years))
print([index_and_year[0] for index_and_year in selected_indexed_years])
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Совместные действия над коллекциями. Функция zip</h2>
<p>В&nbsp;рассмотренных примерах мы&nbsp;обходились данными из&nbsp;одного источника. Но&nbsp;бывают вычисления, в&nbsp;которых приходится оперировать несколькими коллекциями значений.</p>
<p>Например, научимся вычислять скалярное произведение двух векторов.</p>
<p>Каждый вектор мы&nbsp;можем написать в&nbsp;виде набора (списка) координат. Для вектора на&nbsp;плоскости координат две, для вектора в&nbsp;пространстве&nbsp;&mdash; три. В&nbsp;математических вычислениях часто приходится работать с&nbsp;векторами в&nbsp;многомерном (N-мерном) пространстве, в&nbsp;котором вектор описывается набором из&nbsp;N чисел. Скалярное произведение двух векторов вычисляется как сумма произведений соответствующих координат. Например, в&nbsp;двухмерном пространстве вектора с&nbsp;координатами (a<sub>1</sub>, a<sub>2</sub>) и&nbsp;(b<sub>1</sub>, b<sub>2</sub>) дают скалярное произведение a<sub>1</sub>b<sub>1</sub> + a<sub>2</sub>b<sub>2</sub>.</p>
<p>Один способ решить задачу&nbsp;&mdash; перебрать все&nbsp;N измерений и&nbsp;для каждого измерения посчитать произведение элемента из&nbsp;первого списка на&nbsp;элемент из&nbsp;второго списка. Затем просуммировать получившиеся координаты:</p>
<pre><code class="language-python"># рассмотрим параллелепипед со сторонами 2 x 2 x 1
# и вычислим скалярное произведение между
# вектором длинной диагонали и короткой "двумерной" диагонали
# в квадратном основании

a = [2,2,1]
b = [2,2,0]
N = len(a) # или len(b), они должны быть равны
sum(map(lambda i: a[i] * b[i], range(N))) # =&gt; 8
</code></pre>
<p>Есть и&nbsp;другой способ, который вообще не&nbsp;использует индексы элементов. Давайте выпишем два списка рядом. Пусть элементы списков <var>a</var>&nbsp;и&nbsp;<var>b</var>&nbsp;сгруппированы в&nbsp;два вертикальных набора. Если мы&nbsp;теперь начнем &laquo;зачитывать&raquo; элементы по&nbsp;горизонтали, получим как раз&nbsp;N пар чисел&nbsp;&mdash; координаты пары векторов вдоль соответствующей оси. Для того чтобы так &laquo;перевернуть&raquo; порядок чтения, используется функция <var>zip</var>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функция zip</strong></p>
<p>Функция <code>zip(a, b)</code> создает объект-итератор, из&nbsp;которого при каждом шаге извлекается кортеж, состоящий из&nbsp;двух элементов: первый берется из&nbsp;списка&nbsp;<var>a</var>, второй&nbsp;&mdash; из&nbsp;<var>b</var>. Итератор останавливается, когда исчерпывается самая короткая последовательность.</p>
<pre><code>a    b    zip(a, b)
--------------------
 2    2     (2, 2)
 2    2     (2, 2)
 1    0     (1, 0)
</code></pre>
</section>
<p>Чтобы научиться работать с&nbsp;функцией <var>zip</var>, посчитаем с&nbsp;ее&nbsp;помощью скалярное произведение:</p>
<pre><code class="language-python">sum(map(lambda coords: coords[0] * coords[1], zip(a, b)))
# =&gt; 8
</code></pre>
<p>Функция <var>zip</var> вернула нам итератор, который возвращает кортежи из&nbsp;пар соответствующих координат. Чтобы убедиться в&nbsp;этом, распечатайте результат применения функции <var>zip</var> к&nbsp;двум спискам (не&nbsp;забудьте сделать из&nbsp;итератора список).</p>
<p>Функция <var>zip</var> может принимать несколько параметров. В&nbsp;этом случае итератор вернет сначала кортеж из&nbsp;первых элементов всех переданных коллекций, затем&nbsp;&mdash; из&nbsp;вторых элементов всех коллекций и&nbsp;т.&nbsp;д. Часто коллекции, которые вы&nbsp;хотите скомбинировать таким образом, сами находятся в&nbsp;отдельном списке (например, матрица&nbsp;&mdash; список коллекций, представляющих значения строки). Чтобы передать все строки матрицы в&nbsp;функцию <var>zip</var> как отдельные строки, можно воспользоваться уже известным вам оператором &laquo;звездочка&raquo;. Проведите эксперимент и&nbsp;передайте в&nbsp;функцию <var>zip</var> матрицу, написав звездочку и&nbsp;опустив&nbsp;ее. Изучите, в&nbsp;чем заключаются отличия возвращаемых итератором <var>zip</var> элементов для этих случаев?</p>
</section>
<section class="material__chapter">
<h2 id="4">Модуль itertools</h2>
<p>Мы&nbsp;рассмотрели пока лишь мизерную часть возможностей Python, связанных с&nbsp;итераторами и&nbsp;их&nbsp;комбинированием. В&nbsp;стандартной библиотеке Python есть модуль itertools, содержащий 18&nbsp;функций, которые мы&nbsp;еще не&nbsp;изучали. Сейчас рассматривать все доступные функции незачем (это может занять не&nbsp;одну неделю), поэтому покажем лишь некоторые возможности. Рекомендуем время от&nbsp;времени перечитывать список функций на&nbsp;странице <span style="text-decoration: underline; color: #0000ff;"> <a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://docs.python.org/3/library/itertools.html" target="_blank" rel="noopener noreferrer">документации</a></span>.</p>
<p>Помимо встроенных функций, на&nbsp;этой странице описано множество рецептов их&nbsp;применения. Со&nbsp;временем вы&nbsp;увидите, что многие задачи можно удобно переписать, используя итераторы.</p>
<p>Для того чтобы работать с&nbsp;функциями из&nbsp;модуля itertools, вы&nbsp;должны в&nbsp;начале программы написать строку</p>
<pre><code class="language-python">import itertools
</code></pre>
<p>Это позволит вызывать любую функцию из&nbsp;этого модуля, используя ее&nbsp;полное имя: <code>itertools.&lt;имя функции&gt;</code>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>itertools.chain</strong></p>
<p>Первым делом освоим сцепление нескольких итераторов. Мы&nbsp;берем несколько итераторов и&nbsp;делаем новый, который сначала перебирает все элементы из&nbsp;первого итератора, затем из&nbsp;второго, из&nbsp;третьего и&nbsp;т.&nbsp;д., пока не&nbsp;закончатся значения в&nbsp;последнем итераторе. Для этого служит функция <code>itertools.chain(iter_1, iter_2, ...)</code>.</p>
</section>
<p>Применим этот итератор, чтобы получить список всех дат года. Склеим этот итератор из&nbsp;итераторов по&nbsp;числам месяца, которые легко сделать методом <var>range</var>.</p>
<pre><code class="language-python">month_lengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
day_numbers = itertools.chain(*map(lambda length: range(1, length + 1),
                                   month_lengths))
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>itertools.cycle, itertools.repeat</strong></p>
<p>В&nbsp;некоторых ситуациях требуется &laquo;зациклить&raquo; один итератор. Сделаем итератор часовой стрелки, который после 23&nbsp;возвращается к&nbsp;нулю и&nbsp;начинает отсчет заново. Для этой цели предназначен <var>itertools.cycle</var>. Если&nbsp;же вам нужно просто повторять какое-то значение несколько раз, можно использовать итератор <var>itertools.repeat</var>.</p>
</section>
<pre><code class="language-python">hours = itertools.cycle(range(24))
 
# Используем repeat, чтобы на протяжении 31 дня января повторять,
# что это первый месяц года и т.д.
month_lengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
month_numbers = itertools.chain(
    *map(lambda month_and_length: itertools.repeat(month_and_length[0],
                                                   month_and_length[1]),
         enumerate(month_lengths, 1)))
</code></pre>
<p>Когда вы&nbsp;начинаете работать с&nbsp;бесконечными списками, возникает проблема: их&nbsp;работа никогда не&nbsp;завершается. Обычно это не&nbsp;то, чего мы&nbsp;добиваемся. Бесконечные списки часто используются как промежуточный этап работы. Для превращения бесконечного итератора в&nbsp;конечный существует функция <var>islice</var>, делающая &laquo;срез&raquo; итератора. Она принимает итератор и&nbsp;три параметра, определяющих начало, конец и&nbsp;шаг среза. Если в&nbsp;качестве конца среза указан None, срез имеет начало, но&nbsp;не&nbsp;ограничен с&nbsp;конца. Срезы, конечно, можно делать не&nbsp;только для бесконечных итераторов, но&nbsp;и&nbsp;для конечных. Посмотрите в&nbsp;документации синтаксис функции <var>islice</var> и&nbsp;пример написания функции <var>take</var> из&nbsp;списка <span style="text-decoration: underline; color: #0000ff;"><a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://docs.python.org/3/library/itertools.html#itertools-recipes" target="_blank" rel="noopener noreferrer">рецептов</a></span>, которая позволяет взять из&nbsp;итератора первые n&nbsp;элементов.</p>
<p>Есть большой класс итераторов, которые возвращают &laquo;комбинаторные&raquo; значения. Например, так работает итератор <var>itertools.product</var>. Результатом его работы является так называемое декартово произведение итераторов: для каждого значения первого итератора перебираются все значения второго. Наш итератор каждый час будет пробегать 60&nbsp;минут, а&nbsp;затем зацикливать сутки:</p>
<pre><code class="language-python">itertools.cycle(itertools.product(range(24), range(60)))
</code></pre>
<p>Попробуйте зациклить отдельно минуты и&nbsp;отдельно часы, прежде чем перемножать&nbsp;их. Что получается в&nbsp;итоге?</p>
<p>Декартово произведение&nbsp;&mdash; самый простой комбинаторный итератор. Разберем еще один: <var>itertools.combinations</var>. Он&nbsp;берет итератор и&nbsp;некоторое число&nbsp;<var>r</var>, а&nbsp;затем выдает набор всех возможных комбинаций из&nbsp;<var>r</var>&nbsp;элементов (пришедших из&nbsp;переданного итератора). Например, <code>itertools.combinations(range(10), 2)</code> переберет все возможные пары различных цифр. При этом кортежи с&nbsp;переставленными элементами не&nbsp;появляются в&nbsp;результатах. Например, мы&nbsp;получим элемент (2, 7), но&nbsp;не&nbsp;получим элемент (7, 2), так как это та&nbsp;же самая комбинация элементов итератора.</p>
<p>На&nbsp;следующем занятии мы&nbsp;обсудим еще один тип итераторов, позволяющий сгруппировать элементы по&nbsp;некоторому признаку. И&nbsp;немного поговорим о&nbsp;функциях, которые могут и&nbsp;не&nbsp;могут работать в&nbsp;потоковом режиме.</p>
</section>
<section class="material__chapter">
<h2 id="5">Свертка итератора. Функция reduce</h2>
<p>Функция <var>reduce</var> расположена не&nbsp;в&nbsp;модуле itertools, а&nbsp;в&nbsp;модуле functools. Значит, чтобы ею&nbsp;воспользоваться, необходимо в&nbsp;вашей программе написать <code>import functools</code>. То, что она не&nbsp;находится в&nbsp;itertools,&nbsp;&mdash; неслучайно, так как она не&nbsp;возвращает итератор. Напротив, она принимает итератор&nbsp;и, некоторым образом скомбинировав элементы, которые выдает этот итератор, возвращает одно единственное значение.</p>
<p>Итераторы сделаны &laquo;стыкующимися&raquo; так, что преобразования итераторов образуют длинные цепочки. А&nbsp;функция <var>reduce</var> обычно завершает цепочку итераторов и&nbsp;возвращает итоговый результат (если только вызов <var>reduce</var> не&nbsp;возвращает итерируемый ответ, что возможно, но&nbsp;отнюдь не&nbsp;обязательно).</p>
<p>Разберемся наконец, что такое свертка итератора.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Свертка итератора</strong></p>
<p>Свертка&nbsp;&mdash; функция высшего порядка, которая принимает начальное значение, итератор и&nbsp;некоторую бинарную операцию, а&nbsp;возвращает результат многократного применения этой операции к&nbsp;элементам итератора. Операция применяется, а&nbsp;результат вычисления передается как аргумент в&nbsp;эту&nbsp;же самую операцию.</p>
</section>
<p>Функция <var>reduce</var> обновляет некоторую величину шаг за&nbsp;шагом, начиная с&nbsp;некоторого начального значения. Эта величина обновляется при получении каждого следующего элемента из&nbsp;итератора, когда элементы закончились, эта величина возвращается как результат работы функции.</p>
<p>Пусть наш итератор <var>iterator</var> возвращает элементы&nbsp;a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ..., a<sub>n</sub>. Передадим <var>reduce</var> в&nbsp;качестве операции функцию двух аргументов <code>func(result, element)</code>. В&nbsp;качестве начального значения возьмем <var>init</var>. Последим за&nbsp;тем, как будет обновляться промежуточный результат:</p>
<pre><code class="language-python">functools.reduce(func, iterator, init)
</code></pre>
<p>До&nbsp;получения элементов из&nbsp;итератора промежуточный результат <var>result</var> равен <var>init</var>. После того как <var>reduce</var> получил первый элемент, промежуточный результат становится равен:</p>
<pre><code class="language-python">func(result, a1) = func(init, a1)
</code></pre>
<p>На&nbsp;следующем шаге:</p>
<pre><code class="language-python">result = func(result, a2) = func(func(init, a1), a2)
</code></pre>
<p>В&nbsp;итоге после того как <var>reduce</var> получил последний элемент:</p>
<pre><code class="language-python">result = func(result, an) = func(...(func(func(init, a1), a2), ...), an)
</code></pre>
<p>Проще всего показать работу этой функции на&nbsp;примере. Давайте передадим в&nbsp;качестве операции функцию, прибавляющую очередной элемент к&nbsp;результату. В&nbsp;качестве исходного значения передадим ноль.</p>
<pre><code class="language-python">functools.reduce(lambda result, element: result + element, range(10), 0)
# =&gt; 45
</code></pre>
<p>Если вы&nbsp;попробуете проделать все вычисления, увидите, что мы&nbsp;просто посчитали сумму элементов итератора: начали с&nbsp;нуля и&nbsp;на&nbsp;каждом шаге прибавляли значение очередного элемента к&nbsp;результату. Оказывается, сумма&nbsp;&mdash; частный случай применения операции свертки.</p>
<p>Совершенно аналогично можно посчитать произведение элементов, передав в&nbsp;<var>reduce</var> функцию <code>lambda result, element: result * element</code> (а&nbsp;в&nbsp;качестве начального элемента возьмем&nbsp;1).</p>
<p>Начальный элемент указывать необязательно. Если его не&nbsp;указать, начальным значением будет первое значение итератора, а&nbsp;применение операции начнется со&nbsp;второго элемента. Для функций суммы и&nbsp;произведения это будет работать как положено. Получается, что выражение <code>func(...(func(func(init, a1), a2), ...), an)</code> превращается в&nbsp;<code>func(func(...func(a1, a2), ...), an)</code>.</p>
<p>Сумма&nbsp;&mdash; не&nbsp;единственная свертка, которую вы&nbsp;уже знаете. Многие другие операции можно превратить в&nbsp;свертку. Например, метод <var>join</var>:</p>
<pre><code class="language-python">values = ["картину", "корзину", "картонку"]
functools.reduce(lambda result, element: result + ", " + element, values)
# =&gt; 'картину, корзину, картонку'
</code></pre>
<p>Функцию <var>map</var> можно переписать, используя <var>reduce</var>:</p>
<pre><code class="language-python">values = ["картину", "корзину", "картонку"]
functools.reduce(lambda result, element: result + 
                                         [element.upper()], values, [])
# =&gt; ['КАРТИНУ', 'КОРЗИНУ', 'КАРТОНКУ']
</code></pre>
<p>Аналогично можно написать функции <var>any</var> и&nbsp;<var>all</var>, если не&nbsp;касаться бесконечных итераторов.</p>
<p>Возьмем список, в&nbsp;котором часть элементов может помечена как отсутствующая (в&nbsp;списке элементы заменены на&nbsp;None), и&nbsp;попробуем с&nbsp;помощью <var>reduce</var> узнать, есть&nbsp;ли отсутствующие элементы в&nbsp;списке:</p>
<pre><code class="language-python">values = ["картину", "корзину", "картонку", None]

# all(values) -- значит, что все элементы истинны, т.е. не None и не False
# Мы используем конструкцию not not element.
# Она равна False, когда element ложный (False или None),
# в других случаях она равна True
functools.reduce(lambda result, element: result and (not not element), 
                 values, True)
# =&gt; False

# any(values) -- значит, что хотя бы один элемент истинный
functools.reduce(lambda result, element: result or (not not element), 
                 values, False)
# =&gt; True
</code></pre>
<p>Для всех приведенных примеров, конечно, лучше использовать специализированные функции, а&nbsp;не&nbsp;пытаться выразить их&nbsp;через <var>reduce</var>. Операция свертки хороша в&nbsp;первую очередь своей универсальностью, вы&nbsp;можете выразить с&nbsp;ее&nbsp;помощью огромное число различных вычислений.</p>
<p>Функцию <var>reduce</var> может быть действительно полезно использовать, когда функцию от&nbsp;списка значений можно записать как комбинацию более простых вызовов существующей функции пары значений. Например, если у&nbsp;вас есть функция, позволяющая найти пересечение двух множеств (в&nbsp;Python есть такая функция, см. <span style="text-decoration: underline; color: #0000ff;"><a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://docs.python.org/3/library/stdtypes.html#set" target="_blank" rel="noopener noreferrer">документацию</a></span> типа <span style="text-decoration: underline; color: #0000ff;"><a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://docs.python.org/3/tutorial/datastructures.html#sets" target="_blank" rel="noopener noreferrer">set</a></span>), с&nbsp;помощью <var>reduce</var> вы&nbsp;сможете пересечь сколько угодно множеств.</p>
</section>
<section class="material__chapter">
<h2 id="6">Группировка элементов. Функция groupby</h2>
<p>Еще одна функция, о&nbsp;которой мы&nbsp;будем говорить, <var>itertools.groupby</var>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функция groupby</strong></p>
<p>Функция <var>groupby</var> принимает итератор и&nbsp;группирует последовательные значения итератора, одинаковые по&nbsp;значению какого-либо признака. Возвращает она также итератор, который перебирает не&nbsp;отдельные элементы, а&nbsp;получившиеся группы элементов.</p>
</section>
<p>Это позволит нам решать задачи, которые работают не&nbsp;с&nbsp;единичным элементом, а&nbsp;с&nbsp;поднаборами коллекции. Например, мы&nbsp;можем взять список записей в&nbsp;телефонной книге и&nbsp;посчитать, каких имен в&nbsp;ней больше всего. Для этого нам будет достаточно сгруппировать все записи по&nbsp;имени и&nbsp;найти самую большую группу. Мы&nbsp;вскоре покажем, как решать эту задачу, но&nbsp;перед этим нам придется поговорить о&nbsp;том, что такое группа и&nbsp;почему группируются именно последовательные значения итератора.</p>
<p>Как мы&nbsp;уже много раз говорили, итераторы работают, последовательно перебирая элементы. Все функции, работающие с&nbsp;итераторами, с&nbsp;которыми вы&nbsp;имели дело, как только получают элемент, обрабатывают его&nbsp;и, если требуется, сразу передают полученное значение дальше. Например, когда вы&nbsp;работаете с&nbsp;функцией <var>map</var>, она берет из&nbsp;итератора одно значение и&nbsp;тут&nbsp;же &laquo;кладет&raquo; его в&nbsp;возвращаемый итератор. За&nbsp;счет этого функция, которая работает с&nbsp;результатом функции <var>map</var>, может не&nbsp;ждать, пока та&nbsp;обработает все элементы, она получает значения из&nbsp;<var>map</var> по&nbsp;мере их&nbsp;вычисления. Это такой вариант потоковой обработкой данных: входящие данные (поток) обрабатываются набором последовательных преобразований, причем алгоритму обработки не&nbsp;требуется знать, что в&nbsp;потоке будет дальше. В&nbsp;идеальном случае необходимо знать лишь текущий элемент, в&nbsp;других&nbsp;же случаях достаточно знать текущий и&nbsp;предыдущие элементы.</p>
<p>Давайте теперь рассмотрим другой крайний случай&nbsp;&mdash; функцию <var>sorted</var>. Эта функция может получать значения из&nbsp;итератора, но&nbsp;возвращает все равно список. Почему? Дело в&nbsp;том, что возвращать итератор из&nbsp;функции <var>sorted</var> было&nbsp;бы совершенно бессмысленно: мы&nbsp;не&nbsp;можем выдать ни&nbsp;одного значения, пока не&nbsp;будут прочитаны все значения итератора. Представьте, что вы&nbsp;хотите отсортировать список, который уже отсортирован в&nbsp;обратном порядке. Значит, первый элемент, который должен попасть в&nbsp;результат, во&nbsp;входящем наборе значений находится в&nbsp;самом конце. Таким образом, потоковая обработка элементов без длительной задержки невозможна. Кроме того, для сортировки набора значений из&nbsp;потока требуется их&nbsp;все запомнить, что в&nbsp;общем случае занимает памяти как минимум столько, сколько данных было в&nbsp;потоке. Как вы&nbsp;понимаете, операция сортировки &laquo;дорого&raquo; обходится программе, но&nbsp;это неизбежно.</p>
<p>Группировка значений в&nbsp;потоке занимает промежуточную нишу. Если вы&nbsp;хотите из&nbsp;некоторого произвольного множества получить все значения, которые относятся к&nbsp;группе (для простоты будем считать, что группа содержит одинаковые значения), вам придется прочитать все элементы до&nbsp;единого. Но&nbsp;зачастую во&nbsp;входящем потоке данных элементы расположены неслучайно, а&nbsp;заранее отсортированы. В&nbsp;таком случае элементы группы идут подряд, и, чтобы их&nbsp;получить, достаточно взять элементы от&nbsp;начала группы до&nbsp;ее&nbsp;конца. Раз так, мы&nbsp;можем сделать итератор, который перебирает группы и&nbsp;выдает их&nbsp;по&nbsp;одной. Мы&nbsp;можем выдать группу элементов как только прочитали ее&nbsp;до&nbsp;конца, т.&nbsp;е.&nbsp;в&nbsp;тот момент, когда началась другая группа.</p>
<p>На&nbsp;этом месте можно было&nbsp;бы остановиться, но&nbsp;проблема заключается в&nbsp;том, что группа может быть сколь угодно большой&nbsp;и, таким образом, итератор может застопориться. В&nbsp;то&nbsp;же время мы&nbsp;не&nbsp;можем выдать группу, пока не&nbsp;прочитали ее&nbsp;целиком.</p>
<p>Чтобы разрешить эту проблему, мы&nbsp;прибегнем к&nbsp;следующему трюку: будем перебирать элементы потока.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>В момент, когда в&nbsp;потоке начинается новая группа, мы&nbsp;передаем группу в&nbsp;результирующий итератор. Но, так как мы&nbsp;не&nbsp;можем передать группу, которая еще только началась, вместо ее&nbsp;элементов мы&nbsp;передадим итератор. Этот итератор будет перебирать элементы, пока не&nbsp;кончится одна группа, после чего вы&nbsp;получите новый итератор на&nbsp;следующую группу. Так работает <var>groupby</var>: он&nbsp;создает итератор, состоящий из&nbsp;итераторов.</p>
</section>
<p>Если быть точнее, <var>groupby</var> выдает поток кортежей, каждый кортеж состоит из&nbsp;значения, которое характеризует группу (соответствует всем элементам) в&nbsp;группе и&nbsp;итератора, проходящего по&nbsp;самим элементам группы.</p>
<p>Пример:</p>
<pre><code class="language-python">values = [1, 1, 1, 10, 10, 12, 10, 10, 10]
 
# Список кортежей (значение элементов группы, итератор группы)
print(list(itertools.groupby(values) ))
# =&gt; [(1, &lt;itertools._grouper object at 0x...&gt;),
# (10, &lt;itertools._grouper object at 0x...&gt;),
# (12, &lt;itertools._grouper object at 0x...&gt;),
# (10, &lt;itertools._grouper object at 0x...&gt;)]
 
# Выведем элементы каждого из внутренних итераторов
print([list(group[1]) for group in itertools.groupby(values)])
# =&gt; [[1, 1, 1], [10, 10], [12], [10, 10, 10]]
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/groupby%20-%20new.svg" width="680" height="auto" /></div>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Поскольку мы&nbsp;передали несортированный список, у&nbsp;нас получились две отдельные группы десяток. Группой является множество <strong>одинаковых</strong> и&nbsp;притом <strong>смежных</strong> элементов. Если&nbsp;бы&nbsp;мы&nbsp;хотели получить группы, в&nbsp;которые включены все соответствующие элементы, нам&nbsp;бы&nbsp;пришлось сначала отсортировать список:</p>
<pre><code class="language-python">print([list(group[1]) for group in itertools.groupby(sorted(values))])
# =&gt; [[1, 1, 1], [10, 10, 10, 10, 10], [12]]
</code></pre>
</section>
<p>Конечно, нам редко требуется группировать абсолютно одинаковые элементы, обычно мы&nbsp;группируем элементы по&nbsp;какому-либо признаку. Функцию, которая вычисляет по&nbsp;элементу значение группирующего признака, мы&nbsp;передаем в&nbsp;качестве необязательного аргумента в&nbsp;функцию <var>groupby</var>.</p>
<p>Давайте вернемся к&nbsp;примеру, с&nbsp;которого начинали. Пусть у&nbsp;нас есть список записей в&nbsp;телефонной книге и&nbsp;мы&nbsp;хотим найти самое частое имя. Значит, первым делом мы&nbsp;должны сгруппировать записи по&nbsp;имени, а&nbsp;затем посчитать размер групп. Записи будем представлять кортежами (имя, фамилия, телефон).</p>
<pre><code class="language-python">address_book = [('Андрей', 'Веселов', '235780'),
                ('Александр', 'Копылов', '122112'),
                ('Андрей', 'Тихий', '998877')
               ]
 
# Итак, отсортируем список по интересующему нас признаку
# и сгруппируем по нему.
# Признак - имя - является нулевым элементом записи. 
# Так как он понадобится нам дважды, запишем его в переменную
key_func = lambda record: record[0]
groups = itertools.groupby(sorted(address_book, key=key_func), key_func)
 
# Найдем среди групп максимальную по длине группы.
# group[0] - это имя, а group[1] - это итератор
# по всем записям с таким именем
# sum(1 for element in iterator), как мы говорили в прошлом уроке -
# число элементов итератора
name, group_iterator = max(groups,
                           key=lambda group: sum(1 for record in group[1]))
print(name) # =&gt; 'Андрей'
 
# Но будьте осторожны! Мы присвоили значение group_iterator только для того, 
# чтобы более наглядно показать значения в итоговом кортеже.
# После того, как max перебрал все элементы, group_iterator остался пустым:
print(list(group_iterator)) # =&gt; []
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>