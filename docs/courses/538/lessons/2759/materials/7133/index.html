<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Обработка коллекций. Потоковый ввод sys.stdin </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок sys.stdin</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Обработка коллекций. Потоковый ввод sys.stdin</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Итерируемые объекты. Почему filter и&nbsp;map возвращают не&nbsp;список</a></li>
<li><a class="material__link" href="#2">Функции max/min/sorted и&nbsp;использование ключа сортировки</a></li>
<li><a class="material__link" href="#3">Проверка коллекций: all, any</a></li>
<li><a class="material__link" href="#4">Потоковый ввод stdin</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;Python встроено множество функций, которые помогают перебирать и&nbsp;комбинировать данные любыми способами. На&nbsp;прошлом уроке мы&nbsp;познакомились с&nbsp;функциями высшего порядка и&nbsp;даже попробовали их&nbsp;комбинировать. В&nbsp;Python нередко можно сложное вычисление свести к&nbsp;одной строке, если правильно подобрать порядок преобразования данных. В&nbsp;этом уроке мы&nbsp;будем изучать арсенал имеющихся инструментов и&nbsp;учиться их&nbsp;использовать.</p>
</section>
<section class="material__chapter">
<h2 id="1">Итерируемые объекты. Почему filter и&nbsp;map возвращают не&nbsp;список</h2>
<p>Прежде чем обсуждать новые функции, нужно немного поговорить об&nbsp;уже изученных функциях <var>map</var> и&nbsp;<var>filter</var>. Вы, возможно, помните, что эти функции принимают любую коллекцию (список, кортеж, строку символов и&nbsp;т.&nbsp;д.). Возвращают эти функции уже не&nbsp;список, а&nbsp;специальный объект, который можно затем передать в&nbsp;список, в&nbsp;цикл <var>for</var> и&nbsp;в&nbsp;некоторые другие функции. Давайте разберемся, как это работает и&nbsp;почему так сделано.</p>
<p>Для начала поймем, почему эти функции возвращают не&nbsp;список. Представьте, что вы&nbsp;работаете с&nbsp;очень большим списком. Например, списком из&nbsp;миллиарда чисел (он&nbsp;занимает не&nbsp;меньше 4&nbsp;гигабайтов памяти). Если вам требуется как-то обработать набор квадратов этих чисел, есть несколько вариантов.</p>
<p>Первый&nbsp;&mdash; перебирать элементы обычным циклом <var>for</var> и&nbsp;отказаться от&nbsp;комбинирования операций, которое вы&nbsp;научились делать при помощи <var>map</var> и&nbsp;<var>filter</var>. Этот вариант, наверное, самый простой, но&nbsp;не&nbsp;слишком удобный. Особенно учитывая, что, помимо <var>map</var> и&nbsp;<var>filter</var>, вы&nbsp;познакомитесь со&nbsp;множеством других удобных функций, работающих аналогично.</p>
<p>Второй вариант&nbsp;&mdash; сделать список квадратов, затем работать уже с&nbsp;ним. Это удобно, но&nbsp;придется потратить еще несколько гигабайтов оперативной памяти. Даже если чисел меньше миллиарда, вы&nbsp;вряд&nbsp;ли захотите, чтобы программа тратила лишнюю память.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Итерируемые объекты</strong></p>
<p>Функция <var>map</var> использует гибридный метод. Ее&nbsp;результат позволяет перебирать не&nbsp;числа, а&nbsp;их&nbsp;квадраты&nbsp;&mdash; как мы&nbsp;и&nbsp;хотели. При этом квадраты чисел нигде не&nbsp;хранятся и&nbsp;не&nbsp;занимают память! Объекты, которые возвращают функции <var>map</var>, <var>filter</var> и&nbsp;подобные, называются <strong>итерируемыми объектами</strong>. Это означает, что они позволяют перебирать значения по&nbsp;очереди и&nbsp;последовательно.</p>
</section>
<p>В&nbsp;нашем примере функция <var>map</var> в&nbsp;любой момент времени хранит только то&nbsp;единственное число, с&nbsp;которым работает, а&nbsp;не&nbsp;весь миллиард квадратов исходных чисел. Вы&nbsp;не&nbsp;создаете огромный промежуточный список и&nbsp;не&nbsp;тратите лишнюю память.</p>
<p>Эффект легко увидеть своими глазами. Откройте диспетчер задач и&nbsp;следите за&nbsp;потреблением памяти интерпретатором Python при запуске двух разных команд:</p>
<pre><code class="language-python"># Версия, создающая промежуточный список.
# Осторожно: при запуске этой команды, Python сначала 
# занимает несколько сотен мегабайт оперативной памяти,
# а затем, когда список становится не нужен - освобождает память.

sum([x ** 2 for x in range(50 * 1000 * 1000)])
# =&gt; 41666665416666675000000

# Версия, работающая при помощи итератора, который
# не хранит промежуточный список.
# Она занимает минимум дополнительной памяти.

sum(map(lambda x: x ** 2, range(50 * 1000 * 1000)))
# =&gt; 41666665416666675000000
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Упрощенно говоря, есть два типа итерируемых объектов:</p>
<ul>
<li>Итераторы, которые позволяют перебирать элементы. Они не&nbsp;хранят все значения элементов, им&nbsp;нужно помнить только начало промежутка, его конец и&nbsp;текущий элемент</li>
<li>Коллекции (списки, строки, словари и&nbsp;т.&nbsp;д.), которые позволяют создать итератор по&nbsp;своим элементам</li>
</ul>
<p>Подробнее об&nbsp;итераторах и&nbsp;их&nbsp;отличиях от&nbsp;коллекций вы&nbsp;можете прочитать в&nbsp;дополнительном уроке &laquo;Итераторы и&nbsp;коллекции&raquo;.</p>
</section>
<p>Большинство функций Python, которые работают с&nbsp;итераторами, умеют работать и&nbsp;с&nbsp;коллекциями. Поэтому слова &laquo;итерируемый объект&raquo; и&nbsp;&laquo;итератор&raquo; мы&nbsp;будем использовать как синонимы. Кроме того, за&nbsp;неимением лучшего названия, мы&nbsp;часто будем называть итераторами функции, которые возвращают итератор (такие как <var>range</var>, <var>map</var>, <var>filter</var> и&nbsp;мн.&nbsp;др.).</p>
</section>
<section class="material__chapter">
<h2 id="2">Функции max/min/sorted и&nbsp;использование ключа сортировки</h2>
<p>Рассмотрим еще один полезный специальный синтаксис в&nbsp;Python, позволяющий избавиться от&nbsp;промежуточных итераторов, которые исходно нам не&nbsp;даны и&nbsp;не&nbsp;нужны в&nbsp;итоговом результате. Так мы&nbsp;сможем сократить число неуклюжих конструкций, в&nbsp;которых сначала создается сложная структура, а&nbsp;потом эта структура упрощается обратно.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Параметр key</strong></p>
<p>У&nbsp;функций вроде <code>min/max/sorted</code> есть опциональный (необязательный) параметр <var>key</var>. Параметр <var>key</var> принимает функцию, по&nbsp;значению которой будут сравниваться элементы.</p>
</section>
<p>Например, пусть у&nbsp;нас есть набор слов, который мы&nbsp;хотим отсортировать:</p>
<pre><code class="language-python">words = ['мир', 'и', 'война']
</code></pre>
<p>Отсортировать слова можно различными способами. Если мы&nbsp;применим функцию <var>sorted</var> без аргумента <var>key</var>, слова будут отсортированы как в&nbsp;словаре (это называется <strong>лексикографически</strong>):</p>
<pre><code class="language-python">sorted(words)   # =&gt; ['война', 'и', 'мир']
</code></pre>
<p>Теперь давайте вызовем функцию <var>sorted</var> следующим образом:</p>
<pre><code class="language-python">sorted(words, key=lambda s: len(s))
# =&gt; ['и', 'мир', 'война']
</code></pre>
<p>Мы&nbsp;указали, что в&nbsp;качестве ключа для сортировки должны использоваться не&nbsp;сами строки (встроенное в&nbsp;Python сравнение строк&nbsp;&mdash; лексикографическое), а&nbsp;их&nbsp;длины. Таким образом, мы&nbsp;получаем список, отсортированный по&nbsp;возрастанию длины слова.</p>
<p>Очень удобно использовать ключ сортировки, если нам надо отсортировать список упорядоченных коллекций (списков, кортежей, строк). Например, у&nbsp;нас есть список, элементами которого тоже являются списки, которые содержат название фильма, его возрастное ограничение и&nbsp;рейтинг по&nbsp;отзывам критиков. И&nbsp;мы&nbsp;хотим отсортировать его сначала по&nbsp;возрастному ограничению, затем по&nbsp;оценке критиков (по&nbsp;убыванию) и&nbsp;только в&nbsp;конце по&nbsp;названию. В&nbsp;этом случае нам поможет вот такой код:</p>
<pre><code class="language-python">li = [
    ['Crawl', 'R', 61],
    ['Stuber', 'R', 42],
    ['Midsommar', 'R', 73],
    ['Yesterday', 'PG-13', 56],
    ['Annabelle Comes Home', 'R', 53],
    ["Child's Play", 'R', 48],
    ['Anna', 'R', 40],
    ['Toy Story 4', 'G', 84],
    ['Shaft', 'R', 40],
    ['Men in Black: International', 'PG-13', 38]
]
print(*sorted(li, key=lambda x: (x[1], -x[2], x[0])), sep='\n')
</code></pre>
<pre><samp>['Toy Story 4', 'G', 84]
['Yesterday', 'PG-13', 56]
['Men in Black: International', 'PG-13', 38]
['Midsommar', 'R', 73]
['Crawl', 'R', 61]
['Annabelle Comes Home', 'R', 53]
["Child's Play", 'R', 48]
['Stuber', 'R', 42]
['Anna', 'R', 40]
['Shaft', 'R', 40]</samp></pre>
<p>Помимо функции <var>sorted</var>, параметр <var>key</var> принимают функции <var>max</var> и&nbsp;<var>min</var>. Вызов <code>max(values, key)</code> позволяет найти значение из&nbsp;набора <var>values</var>, наибольшее по&nbsp;ключу <var>key</var>.</p>
</section>
<section class="material__chapter">
<h2 id="3">Проверка коллекций: all, any</h2>
<p>При работе с&nbsp;коллекциями часто приходится определять, выполняется&nbsp;ли некоторое условие одновременно для всех элементов коллекции или хотя&nbsp;бы для одного.</p>
<section class="material__note">
<p class="material__note-heading"><strong>all и any</strong></p>
<p>Для этих целей существуют две встроенные функции: <var>all</var> и&nbsp;<var>any</var>. Первая проверяет, что все элементы переданного ей&nbsp;итерируемого набора значений истинны (приводятся к&nbsp;True). Вторая проверяет, что есть хотя&nbsp;бы один такой элемент. В&nbsp;терминах математической логики эти функции&nbsp;&mdash; кванторы общности и&nbsp;существования.</p>
</section>
<p>В&nbsp;качестве единственного аргумента <var>all</var> и&nbsp;<var>any</var> принимают что-нибудь перечисляемое&nbsp;&mdash; например, список, кортеж или итератор.</p>
<p>Итак, <var>all</var> вернет True в&nbsp;том случае, если все элементы аргумента True или приводятся к&nbsp;True (или если коллекция пустая):</p>
<pre><code class="language-python">print(all([1, 2, 3, 4, 5, 6, 7, 8, 9]))
# True - так как все элементы ненулевые

print(all([1, 2, 3, 4, 5, 6, 7, 8, 0]))
# False - есть ноль

print(all([1, 2, 3, 4, 5, 6, [], set()]))
# False - есть пустые вложенные коллекции

print(all([]))  # True
</code></pre>
<p>Функция <var>any</var> вернет True, если истинен хотя&nbsp;бы один элемент аргумента. <var>any</var> возвращает False для пустых коллекций:</p>
<pre><code class="language-python">print(any((set(), [], {}, 0, True)))
# True - есть True среди элементов

print(any([set(), [], {}, 0, [1, 2, 3]]))
# True - непустой список приводится к True

print(any([set(), [], {}, 0, False]))
# False - все элементы приводятся к False

print(any([]))  # False
</code></pre>
<p>Функции <var>all</var> и&nbsp;<var>any</var> могут быть особенно полезны в&nbsp;комбинации с&nbsp;функцией <var>map</var>, которая для каждого элемента коллекции проверит некоторое условие и&nbsp;вернет итератор, в&nbsp;котором будут перечисляться результаты этих проверок. Так, например, можно проверить, все&nbsp;ли числа в&nbsp;списке четные:</p>
<pre><code class="language-python">data = [1, 2, 3, 4, 5]
print(all(x % 2 == 0 for x in data))
</code></pre>
<pre><samp>False</samp></pre>
<p>А&nbsp;так&nbsp;&mdash; узнать, есть&nbsp;ли среди слов хотя&nbsp;бы одно, длиной 5&nbsp;букв или более:</p>
<pre><code class="language-python">words = "Ехал грека через реку".split()
print(any(map(lambda w: len(w) &gt;= 5, words)))
</code></pre>
<pre><samp>True</samp></pre>
</section>
<section class="material__chapter">
<h2 id="4">Потоковый ввод stdin</h2>
<p>В&nbsp;Python есть очень полезный встроенный итерируемый объект: <var>sys.stdin</var>. Это&nbsp;&mdash; итератор так называемого потока ввода.</p>
<p>Поток ввода (stdin)&nbsp;&mdash; специальный объект в&nbsp;программе, куда попадает весь текст, который ввел пользователь. Потоком его называют потому, что данные хранятся там до&nbsp;тех пор, пока программа их&nbsp;не&nbsp;считала. Данные поступают в&nbsp;программу и&nbsp;временно &laquo;складируются&raquo; в&nbsp;потоке ввода, а&nbsp;программа может &laquo;забрать&raquo; их&nbsp;оттуда, например, при помощи функции <code>input()</code>. В&nbsp;момент прочтения они пропадают из&nbsp;потока ввода: он&nbsp;хранит данные &laquo;до&nbsp;востребования&raquo;.</p>
<section class="material__note">
<p class="material__note-heading"><strong>sys.stdin</strong></p>
<p><var>sys.stdin</var>&nbsp;&mdash; пример итератора, который невозможно перезапустить. Как и&nbsp;любой итератор, он&nbsp;может двигаться только вперед. Но&nbsp;если для списка можно сделать второй итератор, который начнет чтение с&nbsp;начала списка, то&nbsp;с&nbsp;потоком ввода такое не&nbsp;пройдет. Как только данные прочитаны, они удаляются из&nbsp;потока ввода безвозвратно.</p>
</section>
<p>Элементы, которые выдает этот итератор,&nbsp;&mdash; строки, введенные пользователем. Если пользовательский ввод закончен, итератор тоже прекращает работу. Пока пользователь не&nbsp;ввел последнюю строку, мы&nbsp;не&nbsp;знаем, сколько элементов в&nbsp;итераторе.</p>
<p>Хочется обратить ваше внимание на&nbsp;один интересный факт: допустим, вы&nbsp;написали программу, которая дважды вызывает функцию <code>input()</code>, и&nbsp;отправили ее&nbsp;на&nbsp;проверку в&nbsp;тестовую систему. Но&nbsp;тестовая система передает лишь одну строку. В&nbsp;этом случае выполнение программы завершится с&nbsp;ошибкой, поскольку функция <code>input()</code> не&nbsp;смогла ничего прочитать.</p>
<p>Поэтому, если вы&nbsp;не&nbsp;знаете, в&nbsp;какой момент надо прекратить ввод, воспользоваться функцией <code>input()</code> не&nbsp;удастся. В&nbsp;таких случаях остается только работать с&nbsp;<var>sys.stdin</var>.</p>
<p>Чтобы работать с&nbsp;<var>sys.stdin</var>, прежде всего необходимо подключить модуль <var>sys</var> командой <code>import sys</code>. Напишем небольшую программу, которая печатает каждую введенную пользователем строку:</p>
<pre><code class="language-python">import sys
for line in sys.stdin:
    # rstrip('\n') "отрезает" от строки line идущий справа символ
    # перевода строки, ведь print сам переводит строку
    print(line.rstrip('\n'))
</code></pre>
<p>Что происходит?</p>
<p>Пока есть данные в&nbsp;потоке <var>sys.stdin</var> (то&nbsp;есть пока пользователь их&nbsp;вводит), программа будет получать вводимые строки в&nbsp;переменную <var>line</var>, убирать справа символы перевода строки и&nbsp;выводить их&nbsp;на&nbsp;печать.</p>
<p>Но&nbsp;если вы&nbsp;запустите эту программу, она будет работать вечно. Чтобы показать, что ввод закончен, пользователю недостаточно нажать Enter&nbsp;&mdash; компьютер не&nbsp;знает, завершил пользователь работу или будет еще что-то вводить (при этом Enter превратится в&nbsp;пустую строку). Вместо этого вы&nbsp;должны нажать Ctrl + D (если работаете в&nbsp;консоли Linux или IDE PyCharm) либо Ctrl + Z, затем Enter (если работаете в&nbsp;консоли Windows).</p>
<p>Если вы&nbsp;работаете в&nbsp;IDE Wing, кликните правой кнопкой мыши и&nbsp;выберите Send EOF, затем нажмите Enter. Это запишет в&nbsp;поток ввода специальный символ EOF (end of&nbsp;file), который отмечает конец ввода.</p>
<p>Мы&nbsp;обещали показать, что функция <var>input</var> выдает ошибку, если не&nbsp;получает ввод. Напишите простую программу:</p>
<pre><code class="language-python">x, y = input(), input()
</code></pre>
<p>Запустите программу и&nbsp;введите одну строку (не&nbsp;забудьте нажать Enter). Вместо второй строки введите EOF тем способом, которым это делается в&nbsp;вашей системе. Вы&nbsp;увидите ошибку EOFError&nbsp;&mdash; это означает, что <var>input</var> пытается считать данные из&nbsp;потока, который закончился.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Ввод в&nbsp;одну строку</strong></p>
<p>С&nbsp;помощью <var>sys.stdin</var> можно в&nbsp;одну строку прочитать весь ввод (о&nbsp;количестве строк которого мы&nbsp;ничего не&nbsp;знаем) в&nbsp;список. Реализуется это, например, так:</p>
<pre><code class="language-python">data = list(map(str.strip, sys.stdin))
</code></pre>
</section>
<p>Кроме того, можно считать все строки (с&nbsp;сохранением символов перевода строки) в&nbsp;список вот таким образом:</p>
<pre><code class="language-python">data = sys.stdin.readlines()
</code></pre>
<p>А&nbsp;считать многострочный текст из&nbsp;стандартного потока ввода в&nbsp;текстовую переменную можно вот так:</p>
<pre><code class="language-python">str_data = sys.stdin.read()
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>