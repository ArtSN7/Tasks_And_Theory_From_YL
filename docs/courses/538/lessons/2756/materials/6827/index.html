<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Функции: передача параметров </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Параметры</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Функции. Передача параметров</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Функции (повторение)</a></li>
<li><a class="material__link" href="#2">Отличие между переменной и&nbsp;значением</a></li>
<li><a class="material__link" href="#3">Функции, изменяющие значение аргумента</a></li>
<li><a class="material__link" href="#4">Объекты: одни и&nbsp;те&nbsp;же или одинаковые?</a></li>
<li><a class="material__link" href="#5">Изменяемость и&nbsp;неизменяемость объектов</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Нам необходимо разобраться, чем отличаются понятия &laquo;переменная&raquo; и&nbsp;&laquo;значение&raquo;, ведь при вызове функций одно постоянно превращается в&nbsp;другое. Мы&nbsp;обсудим, почему аргумент, переданный в&nbsp;функцию, нельзя перезаписать, но&nbsp;иногда можно изменить его содержимое. Обсудим, какие объекты изменить можно, а&nbsp;какие не&nbsp;получится. Разберемся, почему равенство объектов неэквивалентно их&nbsp;идентичности.</p>
</section>
<section class="material__chapter">
<h2 id="1">Функции (повторение)</h2>
<p>На&nbsp;прошлых занятиях мы&nbsp;начали разбирать, как работают функции и&nbsp;как с&nbsp;их&nbsp;помощью структурировать код. Напомним, как определяется функция:</p>
<pre><code class="language-python">def &lt;имя функции&gt;([названия аргументов]):
    &lt;тело функции&gt;
    &lt;...&gt;
</code></pre>
<p>И&nbsp;как она вызывается:</p>
<pre><code class="language-python">&lt;имя функции&gt;([значения аргументов])
</code></pre>
<p>Мы&nbsp;успели рассмотреть неочевидный вопрос о&nbsp;том, какими переменными функция может оперировать, а&nbsp;какие переменные ей&nbsp;недоступны. Как вы&nbsp;уже знаете, для того чтобы провести эту границу, в&nbsp;языке Python существует понятие об&nbsp;областях видимости, которые делят переменные на&nbsp;внешние и&nbsp;локальные. Они позволяют переменным с&nbsp;одинаковыми именами не&nbsp;мешать друг другу, а&nbsp;главное&nbsp;&mdash; разделяют программу на&nbsp;независимые друг от&nbsp;друга блоки. Вы&nbsp;узнали, что внутренние переменные функции недоступны снаружи, а&nbsp;внешние переменные, наоборот, можно беспрепятственно читать.</p>
<p>Когда вы&nbsp;внутри функции выполняете присваивание, появляется новая внутренняя (локальная) переменная&nbsp;и, если ее&nbsp;имя совпадает с&nbsp;именем внешней, она перекрывает переменную из&nbsp;внешней (глобальной) области видимости&nbsp;&mdash; и&nbsp;внешняя переменная остается неизменной, таким образом, внешние переменные защищены от&nbsp;случайной порчи. Если вы&nbsp;все&nbsp;же хотите изменить внешнюю переменную, вы&nbsp;должны описать переменную внутри функцию ключевым словом <var>global</var>. Но&nbsp;злоупотреблять этим не&nbsp;рекомендуется, поскольку отдельные части программы начинают зависеть друг от&nbsp;друга, что может привести ко&nbsp;множеству ошибок.</p>
</section>
<section class="material__chapter">
<h2 id="2">Отличие между переменной и&nbsp;значением</h2>
<p>Хотя мы&nbsp;много времени уделили изучению работы переменных с&nbsp;функциями, это еще не&nbsp;все, что нужно знать о&nbsp;переменных. На&nbsp;этом занятии вы&nbsp;поймете, чем <strong>переменная</strong> отличается от&nbsp;<strong>значения переменной</strong>.</p>
<p>Ранее мы&nbsp;рассмотрели такую программу:</p>
<pre><code class="language-python">name = 'Петя'


def greet(name):
    print("Привет,", name)


greet('Вася')
</code></pre>
<p>которая выдает &laquo;Привет, Вася&raquo;.</p>
<p>Как мы&nbsp;выяснили, аргумент функции <var>name</var> является локальной переменной и&nbsp;перекрывает переменную <var>name</var> из&nbsp;внешней области видимости.</p>
<p>А&nbsp;теперь давайте разберем такую программу:</p>
<pre><code class="language-python">name = 'Петя'


def greet(name):
    print("Привет,", name)
    name = 'товарищ'
    print("Здравствуй,", name)


greet(name)
print("Name:", name)
</code></pre>
<p>Чему, по&nbsp;вашему мнению, будет равно имя в&nbsp;конце программы и&nbsp;почему?</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Внешняя переменная <var>name</var>, конечно, не&nbsp;изменится. <strong>В&nbsp;функцию вообще не&nbsp;передается переменная!</strong> Туда передается значение, которое она хранила.</p>
</section>
<p>В&nbsp;языке Python имя переменной связывается со&nbsp;значением. В&nbsp;тот момент, когда мы&nbsp;присваиваем переменной новое значение, старое значение никуда не&nbsp;исчезает. Оно просто теряет связь с&nbsp;прежним именем. В&nbsp;нашем примере на&nbsp;старое значение все еще указывает имя внешней переменной. Это имя недоступно изнутри функции (поскольку внутренняя переменная называется так&nbsp;же, как внешняя), но, выйдя из&nbsp;функции, мы&nbsp;снова получаем возможность пользоваться этим именем.</p>
<p>Имена локальных переменных и&nbsp;имена аргументов можно менять как угодно, это не&nbsp;влияет на&nbsp;работу программы. Например, приведенную выше программу совершенно безопасно можно было&nbsp;бы переписать так:</p>
<pre><code class="language-python">name = 'Петя'


def greet(person):
    print("Привет,", person)
    person = 'товарищ'
    print("Здравствуй,", person)


greet(name)
print("Name:", name)
</code></pre>
<p>Схема ниже демонстрирует, как изменяется <strong>связь &laquo;имя переменной&nbsp;&mdash; значение&raquo;</strong> во&nbsp;время выполнения программы.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-21/21%20-%20Functions%20-%20var.svg" width="680" height="auto" /></div>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Стоит отметить, что, <strong>прежде чем функция будет вызвана, все ее&nbsp;аргументы должны быть вычислены</strong>. Таким образом, сначала выполняются инструкции, которые вычисляют значение переменной (аргументы вычисляются всегда слева-направо), и&nbsp;лишь затем полученные значения передаются в&nbsp;функцию, только после этого начинает выполняться код функции.</p>
</section>
<p><strong>Задача.</strong> Вам даны функции <code>print_goodbye(arg)</code>, <code>print_cruel(arg)</code> и&nbsp;<code>print_world(arg)</code>, выводящие "Goodbye", "cruel" и "world". Каждая из&nbsp;этих функций просто игнорирует аргумент. Скомбинируйте эти три функции в&nbsp;одну команду так, чтобы она выводила "Goodbye cruel world".</p>
<pre><code class="language-python">def print_goodbye(arg):
    print('Goodbye', end=' ')


def print_cruel(arg):
    print('cruel', end=' ')


def print_world(arg):
    print('world', end=' ')
</code></pre>
</section>
<section class="material__chapter">
<h2 id="3">Функции, изменяющие значение аргумента</h2>
<p>Как&nbsp;же быть, если вам хочется изменить значение объекта? Один из&nbsp;способов&nbsp;&mdash; использовать глобальные переменные, но&nbsp;мы&nbsp;уже объяснили, чем он&nbsp;плох.</p>
<p>Оказывается, есть еще несколько способов. Вариант, который мы&nbsp;рассмотрим сейчас, тоже неидеален, но&nbsp;все&nbsp;же гораздо лучше, чем использование глобальных переменных.</p>
<p>Давайте напишем функцию, которая принимает список чисел и&nbsp;возводит каждое число в&nbsp;квадрат.</p>
<pre><code class="language-python">def convert_to_squares(array):
    for i in range(len(array)):
        array[i] = array[i] ** 2


list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
convert_to_squares(list)
print(list)
</code></pre>
<p>Эта программа выведет список квадратов чисел от&nbsp;1&nbsp;до&nbsp;9. Заметьте, мы&nbsp;не&nbsp;присваивали ничего переменной <var>array</var>, это все тот&nbsp;же объект, что был. Но&nbsp;его содержимое поменялось. Ключевой момент: объект тот&nbsp;же, а&nbsp;его наполнение другое.</p>
<p><strong>Вопрос на&nbsp;понимание.</strong> Если мы&nbsp;напишем такую функцию:</p>
<pre><code class="language-python">def list_of_squares(array):
    new_array = []
    for i in range(len(array)):
        new_array.append(array[i] ** 2)
    array = new_array


list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
list_of_squares(list)
print(list)
</code></pre>
<p>она будет выводить на&nbsp;экран не&nbsp;квадраты чисел, а&nbsp;просто числа от&nbsp;одного до&nbsp;девяти. Объясните, почему это так.</p>
</section>
<section class="material__chapter">
<h2 id="4">Объекты: одни и&nbsp;те&nbsp;же или одинаковые?</h2>
<p>Представьте теперь, что у&nbsp;вас есть задача заполнить холодильник едой. В&nbsp;первом случае вы&nbsp;покупаете еду и&nbsp;кладете ее&nbsp;в&nbsp;свой холодильник. Холодильник с&nbsp;едой&nbsp;&mdash; это тот&nbsp;же холодильник, что у&nbsp;вас был. Это ровно тот&nbsp;же объект.</p>
<p>Другой способ решения проблемы&nbsp;&mdash; купить новый холодильник, уже заполненный едой. Но&nbsp;первый холодильник при этом так и&nbsp;остался незаполненным. Внешняя программа ничего не&nbsp;знает про новый холодильник, но&nbsp;знает, что старый вы&nbsp;не&nbsp;заполняли, и&nbsp;выводит вам пустое содержимое.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Итак, мы&nbsp;обнаружили, что есть два способа изменить значение переменной: присвоить переменной новый объект или оставить старый объект, но&nbsp;поменять его содержимое. Однако, оказывается, <strong>не&nbsp;у&nbsp;любого объекта можно поменять содержимое</strong>.</p>
</section>
<p>Когда вам кажется, что вы&nbsp;изменяете, например, число или строку, на&nbsp;самом деле вы&nbsp;создаете новое число или строку и&nbsp;связываете ее&nbsp;с&nbsp;переменной со&nbsp;старым именем.</p>
<p>Это легко проверить.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Оператор is</strong></p>
<p>Проверить, связаны&nbsp;ли две переменные с&nbsp;одним и&nbsp;тем&nbsp;же объектом, можно с&nbsp;помощью оператора&nbsp;<var>is</var>.</p>
<p><code>a&nbsp;is&nbsp;b</code>&nbsp;возвращает True, когда объект <var>a</var>&nbsp;и&nbsp;объект <var>b</var>&nbsp;&mdash; один и&nbsp;тот&nbsp;же объект. Кроме того, в&nbsp;Python есть встроенная функция&nbsp;<var>id</var>, которая выдает уникальный номер объекта. У&nbsp;двух разных объектов id&nbsp;разный, а&nbsp;у&nbsp;одного и&nbsp;того&nbsp;же объекта&nbsp;&mdash; одинаковый.</p>
</section>
<p>Давайте посмотрим, что происходит с&nbsp;переменными при попытке их&nbsp;изменить.</p>
</section>
<section class="material__chapter">
<h2 id="5">Изменяемость и&nbsp;неизменяемость объектов</h2>
<p>На&nbsp;самом деле в&nbsp;языке Python не&nbsp;так много встроенных объектов, которые можно поменять. Сейчас из&nbsp;<strong>изменяемых объектов</strong> вы&nbsp;знаете <strong>списки</strong>, <strong>множества</strong> и&nbsp;<strong>словари</strong>.</p>
<p>А&nbsp;<strong>числа</strong>, <strong>булевы значения</strong>, <strong>строки</strong> и&nbsp;даже <strong>кортежи</strong> менять нельзя. Их&nbsp;содержимое всегда неизменно с&nbsp;момента создания. Такие объекты называются <strong>иммутабельными</strong>, то&nbsp;есть <strong>неизменяемыми</strong>.</p>
<p><strong>Числа:</strong></p>
<pre><code class="language-python">a = 1
print(id(a)) # id объекта "число 1"
a += 1
print(id(a)) # id изменился, a - это объект другого числа
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-21/21%20-%20Functions%20-%20int.svg" width="680" height="auto" /></div>
<p><strong>Строки:</strong></p>
<pre><code class="language-python">s = 'Hello'
print(id(s)) # id строки "Hello"
s += ' world'
print(id(s)) # id другого объекта - строки "Hello world"
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-21/21%20-%20Functions%20-%20str.svg" width="680" height="auto" /></div>
<p><strong>Списки:</strong></p>
<pre><code class="language-python">s = [1, 2, 3]
print(id(s)) # id списка
s += [9, 8, 7]
print(id(s)) # тот же id для того же списка, но с измененным содержимым
</code></pre>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-21/21%20-%20Functions%20-%20list.svg" width="680" height="auto" /></div>
<p>Следует отметить еще один важный момент. Равенство объектов не&nbsp;означает, что это один и&nbsp;тот&nbsp;же объект (или, как еще говорят, объекты идентичны). Это особенно важно для изменяемых объектов-контейнеров, таких как списки. Но&nbsp;и&nbsp;с&nbsp;неизменяемыми кортежами, и&nbsp;со&nbsp;строками бывают ситуации, когда отличие между равенством и&nbsp;идентичностью оказывается важным.</p>
<p>Вернемся к&nbsp;аналогии с&nbsp;холодильниками. Если у&nbsp;вас в&nbsp;холодильнике те&nbsp;же продукты, что у&nbsp;вашего друга, это не&nbsp;значит, что у&nbsp;вас с&nbsp;ним один и&nbsp;тот&nbsp;же холодильник. Если вы&nbsp;что-нибудь добавите в&nbsp;свой холодильник, холодильник вашего друга автоматически никак не&nbsp;изменится.</p>
<pre><code class="language-python">my_fridge = ['молоко', 'яйца', 'овощи']
my_friends_fridge = ['молоко', 'яйца', 'овощи']
print(my_fridge == my_friends_fridge) 
print(id(my_fridge) == id(my_friends_fridge))
</code></pre>
<p>Содержимое холодильников одинаковое, что показывает сравнение списков при помощи оператора <code>==</code>. Но&nbsp;их&nbsp;уникальные id разные.</p>
<p>Совсем другая ситуация, когда у&nbsp;вас есть две переменные, ссылающиеся на&nbsp;один и&nbsp;тот&nbsp;же холодильник. Например, ваш холодильник является одновременно холодильником ваших родителей.</p>
<pre><code class="language-python">my_fridge = ['молоко', 'яйца', 'овощи']
my_parents_fridge = my_fridge
print(my_fridge == my_parents_fridge) 
print(id(my_fridge) == id(my_parents_fridge))
</code></pre>
<p>Строка <code>my_parents_fridge = my_fridge</code> сделала холодильник ваших родителей не&nbsp;просто таким&nbsp;же как ваш, а&nbsp;ровно тем&nbsp;же. Их&nbsp;id&nbsp;равны.</p>
<p>Теперь, если ваши родители положат что-то в&nbsp;свой холодильник, ваш холодильник тоже изменится, так как это тот&nbsp;же самый холодильник.</p>
<pre><code class="language-python">my_parents_fridge += ['мясо']
print(my_fridge)
</code></pre>
<p>Если вы&nbsp;раньше программировали на&nbsp;Паскале или&nbsp;СИ, обратите особое внимание на&nbsp;этот пример. Хотя вы&nbsp;никак не&nbsp;меняли переменную <var>my_fridge</var>, она изменилась. Вернее, изменился объект, на&nbsp;который она ссылается.</p>
<p>Бывают ситуации, когда такое поведение неудобно. Иногда нам хочется получить копию объекта, а&nbsp;не&nbsp;просто вторую ссылку на&nbsp;тот&nbsp;же объект. В&nbsp;общем случае это не&nbsp;так просто сделать, ведь объект (например, список) может содержать в&nbsp;себе другие объекты, которые тоже нужно скопировать. Если вы&nbsp;хотите узнать об&nbsp;этом подробно, вам лучше обратиться к&nbsp;<span style="text-decoration: underline; color: #0000ff;"><a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://docs.python.org/3/library/copy.html" target="_blank" rel="noopener noreferrer">документации</a></span>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Копирование одномерного списка</strong></p>
<p>Мы&nbsp;же&nbsp;напомним о&nbsp;самом распространенном случае. Для того чтобы сделать копию <strong>одномерного списка</strong> <var>arr</var>, можно сделать срез, содержащий все элементы:</p>
<pre><code class="language-python">arr = [1, 2, 3]
arrCopy = arr[:]
arrCopy[0] = 42
print(arr)     # =&gt; [1, 2, 3]
print(arrCopy) # =&gt; [42, 2, 3]
</code></pre>
</section>
<p>Но&nbsp;будьте аккуратны: ведь если список содержал вложенные списки, копия внешнего списка содержит те&nbsp;же самые вложенные списки, а&nbsp;не&nbsp;их&nbsp;копии. А&nbsp;значит, изменения одного списка отразятся на&nbsp;другом. Проще всего это увидеть на&nbsp;примере:</p>
<pre><code class="language-python">arr = [[1], [2], [3]]
arrCopy = arr[:]
arrCopy[0].append(42)
print(arr)     # =&gt; [[1, 42], [2], [3]]
print(arrCopy) # =&gt; [[1, 42], [2], [3]]
</code></pre>
<p>С&nbsp;кортежами дело обстоит аналогично.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Кортежи</strong></p>
<p>Кортеж&nbsp;&mdash; объект неизменяемый. В&nbsp;него нельзя, например, добавить элемент или заменить существующий элемент новым объектом. Но&nbsp;его элементы вполне могут быть изменяемыми; если среди элементов кортежа есть изменяемые элементы, поменяв их&nbsp;содержимое, вы&nbsp;фактически измените содержимое кортежа.</p>
</section>
<p>По&nbsp;этой причине иногда бывает недостаточно следить за&nbsp;типом переменной. Всегда думайте заодно о&nbsp;типах содержимого контейнеров (контейнер&nbsp;&mdash; объект, содержащий другие объекты).</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Напомним также, что в&nbsp;случае списков оператор <code>a1 += a2</code>&nbsp;ведет себя не&nbsp;совсем как <code>a1 = a1 + a2</code>. В&nbsp;первом случае изменяется сам список&nbsp;<var>a1</var> (к&nbsp;его концу дописываются все элементы списка&nbsp;<var>a2</var>), во&nbsp;втором&nbsp;&mdash; создается новый. В&nbsp;случае чисел, строк и&nbsp;кортежей, которые изменяться не&nbsp;могут, две эти формы записи полностью эквивалентны.</p>
</section>
<p><strong>Вопрос для самопроверки 1:</strong> что выведет на&nbsp;экран следующая программа и&nbsp;почему?</p>
<pre><code class="language-python">arr = [2, 90, 5]
print(arr, arr.sort(), arr, sep='\n')
</code></pre>
<p>Напоминаем, что метод <var>sort</var> сортирует элементы в&nbsp;списке (и&nbsp;ничего не&nbsp;возвращает).</p>
<p><strong>Вопрос для самопроверки 2:</strong> что выведет на&nbsp;экран следующая программа и&nbsp;почему?</p>
<pre><code class="language-python">x = 1


def double_x():
    global x
    x *= 2


print(x, double_x(), x, sep='\n')
</code></pre>
<p><strong>Вопрос для самопроверки 3:</strong> можете&nbsp;ли вы&nbsp;придумать три различных примера, которые продемонстрируют, что список и&nbsp;его полный срез&nbsp;&mdash; различные объекты?</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>