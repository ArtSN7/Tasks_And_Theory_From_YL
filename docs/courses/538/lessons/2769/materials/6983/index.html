<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | ООП. Наследование. Часть 2 </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Наследование №2</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>ООП. Наследование. Часть&nbsp;2</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Расширение методов</a></li>
<li><a class="material__link" href="#2">Использование методов наследников в&nbsp;базовом классе</a></li>
<li><a class="material__link" href="#3">Переопределение методов</a></li>
<li><a class="material__link" href="#4">Множественное наследование</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Этот урок посвящен приемам применения наследования: расширению и&nbsp;переопределению методов. Обсуждается и&nbsp;множественное наследование.</p>
</section>
<section class="material__chapter">
<h2 id="1">Расширение методов</h2>
<p>Вернемся к&nbsp;иерархии классов геометрических фигур. И&nbsp;заодно рассмотрим способ, как отразить эту иерархию, представленную в&nbsp;виде картинки, кодом на&nbsp;языке Python.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-33/inheritance.svg" width="680" height="auto" /></div>
<pre><code class="language-python">class Shape:
    def describe(self):
        # Атрибут __class__ содержит класс или тип объекта self
        # Атрибут __name__ содержит строку, 
        # в которой написано название класса или типа
        print(f"Класс: {self.__class__.__name__}")
</code></pre>
<pre><code class="language-python">from math import pi


class Circle(Shape):
    def __init__(self, radius):
        self.r = radius

    def area(self):
        return pi * self.r ** 2

    def perimeter(self):
        return 2 * pi * self.r


class Rectangle(Shape):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def area(self):
        return self.a * self.b

    def perimeter(self):
        return 2 * (self.a + self.b)
</code></pre>
<p>Давайте унаследуем класс <var>Square</var> от&nbsp;класса <var>Rectangle</var>.</p>
<pre><code class="language-python">class Square(Rectangle):
    pass


side = 5
sq = Square(side, side)
print(sq.area())
print(sq.perimeter())
</code></pre>
<pre><samp>25
20</samp></pre>
<p>Поскольку мы&nbsp;никак не&nbsp;&laquo;заполнили&raquo; код класса <var>Square</var>, он&nbsp;будет иметь те&nbsp;же самые методы, что были у&nbsp;класса <var>Rectangle</var>. Но&nbsp;это не&nbsp;очень удобно. Мы&nbsp;хотим, чтобы конструктор класса <var>Square</var> принимал на&nbsp;вход один аргумент (длину стороны). Однако конструктор класса <var>Rectangle</var> принимает на&nbsp;вход два аргумента (ширину и&nbsp;высоту). Как быть?</p>
<p>Пока что мы&nbsp;сделали эту логику вручную, с&nbsp;помощью переменной <var>side</var>. Но, коль скоро мы&nbsp;программируем в&nbsp;объектно-ориентированном стиле, давайте &laquo;спрячем&raquo; (инкапсулируем) эту логику внутрь класса. А&nbsp;именно: мы&nbsp;немного модифицируем конструктор класса <var>Square</var> так, чтобы он&nbsp;принимал на&nbsp;вход только одно число, которое будет передаваться в&nbsp;качестве первого и&nbsp;второго аргумента конструктору базового класса.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Расширение метода</strong></p>
<p>Такая процедура, когда метод производного класса дополняет аналогичный метод базового класса, называется <strong>расширением метода</strong>, а&nbsp;в&nbsp;коде это выглядит следующим образом:</p>
<pre><code class="language-python">class Square(Rectangle):
    def __init__(self, size):
        print('Создаем квадрат')
        super().__init__(size, size)
</code></pre>
</section>
<p>Функция <code>super()</code> возвращает специальный объект, который делегирует (&laquo;передает&raquo;) вызовы методов (в&nbsp;данном случае&nbsp;&mdash; метода <var>__init__</var>) от&nbsp;производного класса к&nbsp;базовому. Эту функцию можно вызывать в&nbsp;любом методе класса&nbsp;&mdash; в&nbsp;частности, в&nbsp;конструкторе.</p>
<p>Фактически фраза <code>super().__init__(size, size)</code> звучит так: &laquo;Вызови метод <var>__init__</var> у&nbsp;моего базового (родительского) класса&raquo;.</p>
<p>Давайте проверим, что произойдет, если мы&nbsp;создадим объект класса <var>Square</var> и&nbsp;вызовем методы <code>area()</code> и&nbsp;<code>perimeter()</code>:</p>
<pre><code class="language-python">sq = Square(2)
print(sq.area())
print(sq.perimeter())
print(sq.a)
</code></pre>
<pre><samp>Создаем квадрат
4
8
2</samp></pre>
<p>Как видим, методы <code>area()</code> и&nbsp;<code>perimeter()</code> отработали корректно, и&nbsp;нам не&nbsp;пришлось переписывать эти методы заново&nbsp;&mdash; они были полностью наследованы от&nbsp;базового класса, а&nbsp;при создании экземпляра класса была выведена строка, которая при создании элементов базового класса не&nbsp;выводится.</p>
<p>Кроме того, от&nbsp;базового класса унаследовались поля <var>a</var>&nbsp;и&nbsp;<var>b</var>.</p>
<p>Заметим, что расширение можно использовать для любого метода класса, а&nbsp;не&nbsp;только для конструктора <var>__init__</var>. Например:</p>
<pre><code class="language-python">import datetime


class Greeter:
    def greet(self):
        print("Good news, everyone")


class GreeterWithDate(Greeter):
    def greet(self):
        print(datetime.datetime.now())
        super().greet()


g = GreeterWithDate()
g.greet()
</code></pre>
</section>
<section class="material__chapter">
<h2 id="2">Использование методов наследников в&nbsp;базовом классе</h2>
<p>На&nbsp;протяжении этого урока нам пару раз потребовалось вывести на&nbsp;экран небольшое &laquo;описание&raquo; фигуры&nbsp;&mdash; ее&nbsp;периметр и&nbsp;площадь. Поскольку все фигуры имеют для этого общий интерфейс (методы <code>perimeter()</code> и&nbsp;<code>area()</code> соответственно), можно, например, написать универсальную (т.&nbsp;е. <strong>полиморфную</strong>) функцию для этого:</p>
<pre><code class="language-python">def describe_shape(shape):
    print(f"Периметр: {shape.perimeter()}\nПлощадь: {shape.area()}")


describe_shape(sq)
</code></pre>
<p>Но&nbsp;есть одно неудобство. Что, если на&nbsp;вход этой функции подать переменную неправильного типа? Программа завершится с&nbsp;ошибкой:</p>
<pre><code class="language-python">describe_shape(5)
</code></pre>
<pre><samp>-------------------------------------------------------------------

AttributeError                    Traceback (most recent call last)

&lt;ipython-input-12-398f18afe0b6&gt; in &lt;module&gt;()
----&gt; 1 describe_shape(5)
    

&lt;ipython-input-10-fafe33c63281&gt; in describe_shape(shape)
      1 def describe_shape(shape):
----&gt; 2     print(f"Периметр: {shape.perimeter()}\nПлощадь: {shape.area()}")
    

AttributeError: 'int' object has no attribute 'perimeter'</samp></pre>
<p>Конечно, внутри <var>describe_shape</var> можно добавить необходимые проверки, но&nbsp;есть более правильное решение&nbsp;&mdash; нужно добавить соответствующий метод в&nbsp;базовый класс. В&nbsp;нашем случае можно просто немного дополнить метод <var>describe</var> класса <var>Shape</var>:</p>
<pre><code class="language-python">class Shape:
    def describe(self):
        # Добавим еще и название класса
        print(f"Класс: {self.__class__.__name__}\n"
              f"Периметр: {self.perimeter()}\n"
              f"Площадь: {self.area()}")
</code></pre>
<p>Обратите внимание: у&nbsp;класса <var>Shape</var> нет методов <code>perimeter()</code> и&nbsp;<code>area()</code>, поэтому метод <code>describe()</code> не&nbsp;будет работать для объектов этого класса. Но&nbsp;у&nbsp;всех производных классов эти методы есть, поэтому для них все сработает правильно:</p>
<pre><code class="language-python">sq = Square(3)
sq.describe()
</code></pre>
<pre><samp>Создаем квадрат
Класс: Square
Периметр: 12
Площадь: 9</samp></pre>
</section>
<section class="material__chapter">
<h2 id="3">Переопределение методов</h2>
<p>Давайте &laquo;починим&raquo; метод <code>describe()</code> для класса <var>Shape</var>. Будем считать, что у&nbsp;&laquo;абстрактной&raquo; фигуры площадь и&nbsp;периметр не&nbsp;определены (т.&nbsp;е. равны None):</p>
<pre><code class="language-python">class Shape:
    def describe(self):
        print(f"Класс: {self.__class__.__name__}\n"
              f"Периметр: {self.perimeter()}\n"
              f"Площадь: {self.area()}")  

    def area(self):
        return None

    def perimeter(self):
        return None
</code></pre>
<p>А&nbsp;как теперь будет работать метод <code>describe()</code> для производных классов? У&nbsp;какого класса он&nbsp;будет вызывать методы <code>area()</code> и&nbsp;<code>perimeter()</code>&nbsp;&mdash; у&nbsp;производного или у&nbsp;базового?</p>
<p>Давайте вспомним, что по&nbsp;сути представляет собой наследование классов в&nbsp;Python: если мы&nbsp;вызовем метод у&nbsp;производного класса, сперва ищется метод этого класса, а&nbsp;если его там нет, такой&nbsp;же поиск выполняется в&nbsp;его базовом классе. Значит, поведение производных классов измениться не&nbsp;должно.</p>
<p>Давайте убедимся в&nbsp;этом:</p>
<pre><code class="language-python">shape = Shape()
circle = Circle(5)
rectangle = Rectangle(3, 4)
square = Square(5)

shape.describe()
circle.describe()
rectangle.describe()
square.describe()
</code></pre>
<pre><samp>Создаем квадрат
Класс: Shape
Периметр: None
Площадь: None
Класс: Circle
Периметр: 31.41592653589793
Площадь: 78.53981633974483
Класс: Rectangle
Периметр: 14
Площадь: 12
Класс: Square
Периметр: 20
Площадь: 25</samp></pre>
<p>Итак, методы <code>perimeter()</code> и&nbsp;<code>area()</code> есть в&nbsp;базовом классе, но&nbsp;в&nbsp;производных классах они реализованы по-другому.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Переопределение методов</strong></p>
<p>Это называется <strong>переопределением методов</strong>. В&nbsp;отличие от&nbsp;расширения методов, в&nbsp;данном случае метод <code>area()</code> базового класса <strong>не&nbsp;используется</strong> при реализации метода <code>area()</code> производного класса; то&nbsp;же самое относится и&nbsp;к&nbsp;методу <code>perimeter()</code>.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="4">Множественное наследование</h2>
<section class="material__note">
<p class="material__note-heading"><strong>Множественное наследование</strong></p>
<p>Python предоставляет возможность наследоваться сразу от&nbsp;нескольких классов. Такой механизм называется <strong>множественное наследование</strong>, и&nbsp;он&nbsp;позволяет вызывать в&nbsp;производном классе методы разных базовых классов.</p>
</section>
<p>Рассмотрим пример:</p>
<pre><code class="language-python">class Base1:
    def tic(self):
        print("tic")


class Base2:
    def tac(self):
        print("tac")


class Derived(Base1, Base2):
    pass


d = Derived()
d.tic()  # метод, наследованный от Base1
d.tac()  # метод, наследованный от Base2
</code></pre>
<p>Множественное наследование на&nbsp;практике используется достаточно редко (хотя все&nbsp;же используется), поскольку при его использовании возникают закономерные вопросы:</p>
<ul>
<li>Что, если названия каких-то методов в&nbsp;базовых классах совпадают?</li>
<li>Какой из&nbsp;них будет вызван из&nbsp;производного класса?</li>
</ul>
<p>Хотя в&nbsp;языке и&nbsp;зафиксирован порядок разрешения таких конфликтов (в&nbsp;общем случае классы просматриваются слева направо&nbsp;&mdash; подробнее в&nbsp;<span style="text-decoration: underline; color: #0000ff;"><a class="material__link" style="color: #0000ff; text-decoration: underline;" href="https://docs.python.org/3/tutorial/classes.html#multiple-inheritance" target="_blank" rel="noopener noreferrer">документации</a></span>), эта особенность все равно может привести к&nbsp;ошибкам при использовании множественного наследования.</p>
<p>В&nbsp;нашей иерархии классов геометрических фигур можно привести следующий пример множественного наследования. Мы&nbsp;знаем, что квадрат является не&nbsp;только прямоугольником, но&nbsp;и&nbsp;правильным многоугольником. В&nbsp;любой правильный многоугольник, например, можно вписать окружность, а&nbsp;в&nbsp;произвольный прямоугольник нельзя. Давайте напишем отдельный класс <var>RegularPolygon</var> для правильных многоугольников:</p>
<pre><code class="language-python">from math import tan, pi


class RegularPolygon:
    def __init__(self, side, n):
        self.side = side  # длина стороны
        self.n = n  # число сторон

    def inscribed_circle_radius(self):
        '''Радиус вписанной окружности'''
        return self.side / (2 * tan(pi / self.n))
</code></pre>
<p>Квадрат можно унаследовать от&nbsp;прямоугольника и&nbsp;правильного многоугольника. Обратите внимание на&nbsp;конструктор класса <var>Square</var>:</p>
<pre><code class="language-python">class Square(Rectangle, RegularPolygon):
    def __init__(self, a):
        # Приходится явно вызывать конструкторы базовых классов
        Rectangle.__init__(self, a, a)
        RegularPolygon.__init__(self, a, 4)
        

s = Square(5)
s.describe()                        # метод класса Rectangle
print(s.inscribed_circle_radius())  # метод класса RegularPolygon
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>