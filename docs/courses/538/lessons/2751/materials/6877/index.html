<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Знакомство со словарями </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Словари</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Знакомство со&nbsp;словарями</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Знакомство со&nbsp;словарями</a></li>
<li><a class="material__link" href="#2">Создание словаря</a></li>
<li><a class="material__link" href="#3">Обращение к&nbsp;элементу словаря</a></li>
<li><a class="material__link" href="#4">Добавление и&nbsp;удаление элементов</a></li>
<li><a class="material__link" href="#5">Проверка наличия элемента в&nbsp;словаре</a></li>
<li><a class="material__link" href="#6">Нестроковые ключи</a></li>
<li><a class="material__link" href="#7">Методы словарей</a></li>
<li><a class="material__link" href="#8">Допустимые типы ключей</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке рассказывается о&nbsp;словарях&nbsp;&mdash; встроенной в&nbsp;Python мощной структуре данных. В&nbsp;других языках аналогичная структура называется map, HashMap, Dictionary.</p>
<p>Базовые функции работы со&nbsp;словарями показаны на&nbsp;простых примерах хранения библиотеки знаний о&nbsp;фильмах и&nbsp;актерах.</p>
</section>
<section class="material__chapter">
<h2 id="1">Знакомство со&nbsp;словарями</h2>
<p>Списки&nbsp;&mdash; удобный и&nbsp;самый популярный способ сохранить большое количество данных в&nbsp;одной переменной. Списки индексируют все хранящиеся в&nbsp;них элементы. Первый элемент, как мы&nbsp;помним, лежит по&nbsp;индексу&nbsp;0, второй&nbsp;&mdash; по&nbsp;индексу 1&nbsp;и&nbsp;т.&nbsp;д. Такой способ хранения позволяет быстро обращаться к&nbsp;элементу списка, зная его индекс.</p>
<pre><code class="language-python">actors = ['Джонни Депп', 'Эмма Уотсон', 'Билли Пайпер']
print(actors[1])
</code></pre>
<p>Представим, что мы&nbsp;делаем свою онлайн-энциклопедию об&nbsp;актерах мирового кино (наподобие Википедии). Для каждого актера нужно сохранить текст статьи о&nbsp;нем. Ее название&nbsp;&mdash; строка, состоящая из&nbsp;фамилии и&nbsp;имени актера. Как правильно хранить такие данные?</p>
<p>Можно создать список кортежей. Каждый кортеж будет состоять из&nbsp;двух строк&nbsp;&mdash; названия и&nbsp;текста статьи.</p>
<pre><code class="language-python">actors = [('Джонни Депп', 'Джон Кристофер Депп Второй родился '
                          '9 июня 1963 года в Овенсборо, Кентукки...'),
 ('Сильвестр Сталлоне', 'Сильвестр Гарденцио Сталлоне родился в Нью-Йорке. '
                        'Его отец, парикмахер Фрэнк Сталлоне &mdash; иммигрант из Сицилии...'),
 ('Эмма Уотсон', 'Эмма Шарлотта Дуерр Уотсон родилась в семье английских адвокатов. '
                 'В пять лет переехала вместе с семьей из Парижа в Англию...'),
 # ...
 ]
</code></pre>
<p>Со&nbsp;временем количество статей значительно вырастет. Чтобы найти нужную статью по&nbsp;названию, нам придется написать цикл for, который пройдет по&nbsp;всем элементам списка <var>actors</var> и&nbsp;найдет в&nbsp;нем кортеж, первый элемент которого равен искомому названию. В&nbsp;приведенном выше примере, чтобы найти статью об&nbsp;Эмме Уотсон, нам придется в&nbsp;цикле пройти мимо Джонни Деппа и&nbsp;Сильвестра Сталлоне. Угадать заранее, что статья об&nbsp;Эмме Уотсон лежит после них, не&nbsp;получится.</p>
<p>Корень этой проблемы в&nbsp;том, что списки индексируются целыми числами. Мы&nbsp;же хотим находить информацию не&nbsp;по&nbsp;числу, а&nbsp;по&nbsp;строке&nbsp;&mdash; названию статьи. Было&nbsp;бы здорово, если&nbsp;бы индексами могли быть не&nbsp;числа, а&nbsp;строки. В&nbsp;списках это невозможно, однако возможно в&nbsp;словарях!</p>
<section class="material__note">
<p class="material__note-heading"><strong>Словарь</strong></p>
<p>Словарь (в&nbsp;Python он&nbsp;называется <var>dict</var>)&nbsp;&mdash; тип данных, позволяющий, как и&nbsp;список, хранить много данных. В&nbsp;отличие от&nbsp;списка, в&nbsp;словаре для каждого элемента можно самому определить &laquo;индекс&raquo;, по&nbsp;которому он&nbsp;будет доступен. Этот индекс называется <strong>ключом</strong>.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="2">Создание словаря</h2>
<p>Вот пример создания словаря для энциклопедии об&nbsp;актерах мирового кино:</p>
<pre><code class="language-python">actors = {
 'Джонни Депп': 'Джон Кристофер Депп Второй родился 9 июня 1963 года '
                'в Овенсборо, Кентукки...',
 'Сильвестр Сталлоне': 'Сильвестр Гарденцио Сталлоне родился в Нью-Йорке. '
                       'Его отец, парикмахер Фрэнк Сталлоне &mdash; иммигрант из Сицилии...',
 'Эмма Уотсон': 'Эмма Шарлотта Дуерр Уотсон родилась в семье английских адвокатов. '
                'В пять лет переехала вместе с семьей из Парижа в Англию...',
 # ...
 }
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Создание словаря</strong></p>
<p>Элементы словаря перечисляются в&nbsp;фигурных скобках (как и&nbsp;элементы множества!) и&nbsp;разделяются запятой. До&nbsp;двоеточия указывается ключ, а&nbsp;после двоеточия&nbsp;&mdash; значение, доступное в&nbsp;словаре по&nbsp;этому ключу.</p>
</section>
<p><strong>Пустой словарь</strong> можно создать двумя способами:</p>
<pre><code class="language-python">d = dict()
# или так
d = {}
</code></pre>
<p>Вспомните, что создать пустое множество можно, только используя функцию <code>set()</code>. Теперь понятно, почему это так&nbsp;&mdash; пустые фигурные скобки зарезервированы для создания словаря.</p>
</section>
<section class="material__chapter">
<h2 id="3">Обращение к&nbsp;элементу словаря</h2>
<p>После инициализации словаря мы&nbsp;можем быстро получать статью про конкретного актера:</p>
<pre><code class="language-python">print(actors['Эмма Уотсон'])
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Обращение к&nbsp;элементу словаря выглядит как обращение к&nbsp;элементу списка, только вместо целочисленного индекса используется ключ. В&nbsp;качестве ключа можно указать выражение: Python вычислит его значение, прежде чем обратится к&nbsp;искомому элементу.</p>
</section>
<pre><code class="language-python">first_name = 'Сильвестр'
last_name = 'Сталлоне'
print(actors[first_name + ' ' + last_name])
</code></pre>
<p>Если ключа в&nbsp;словаре нет, возникнет ошибка:</p>
<pre><code class="language-python">print(actors['Несуществующий ключ'])
</code></pre>
<pre><samp>KeyError: 'Несуществующий ключ'</samp></pre>
</section>
<section class="material__chapter">
<h2 id="4">Добавление и&nbsp;удаление элементов</h2>
<p>Важная особенность словаря&nbsp;&mdash; его динамичность. Мы&nbsp;можем добавлять новые элементы, изменять их&nbsp;или удалять. Изменяются элементы точно так&nbsp;же, как в&nbsp;списках, только вместо целочисленного индекса в&nbsp;квадратных скобках указывается ключ:</p>
<pre><code class="language-python">actors['Эмма Уотсон'] = 'Новый текст статьи об Эмме Уотсон'
</code></pre>
<p>Также в&nbsp;словари можно добавлять новые элементы и&nbsp;удалять существующие.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Добавление элемента</strong></p>
<p>Добавление синтаксически выглядит так&nbsp;же, как и&nbsp;изменение:</p>
<pre><code class="language-python">actors['Брэд Питт'] = 'Уильям Брэдли Питт, более известный как Брэд Питт &mdash; ' \
                      'американский актёр и продюсер. ' \
                      'Лауреат премии &laquo;Золотой глобус&raquo; за 1995 год, ...'
</code></pre>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Удаление элемента</strong></p>
<p>Для удаления можно использовать инструкцию <var>del</var> (как и&nbsp;в&nbsp;списках):</p>
<pre><code class="language-python">del actors['Джонни Депп']
# больше в словаре нет ни ключа 'Джонни Депп', 
# ни соответствующего ему значения

print(actors['Джонни Депп'])
</code></pre>
<pre><samp>KeyError: 'Джонни Депп'</samp></pre>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Удаление элемента</strong></p>
<p>Удалять элемент можно и&nbsp;по-другому:</p>
<pre><code class="language-python">actors.pop('Джонни Депп') 
</code></pre>
<p>Единственное отличие этого способа от&nbsp;вызова <var>del</var>&nbsp;&mdash; он&nbsp;возвращает удаленное значение. Можно написать так:</p>
<pre><code class="language-python">deleted_value = actors.pop('Джонни Депп')
</code></pre>
</section>
<p>В&nbsp;переменную <var>deleted_value</var> положится значение, которое хранилось в&nbsp;словаре по&nbsp;ключу 'Джонни Депп'. В&nbsp;остальном этот способ идентичен оператору <var>del</var>. В&nbsp;частности, если ключа 'Джонни Депп' в&nbsp;словаре нет, возникнет ошибка KeyError.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Чтобы ошибка не&nbsp;появлялась, этому методу можно передать второй аргумент. Он&nbsp;будет возвращен, если указанного ключа в&nbsp;словаре нет. Это позволяет реализовать безопасное удаление элемента из&nbsp;словаря:</p>
<pre><code class="language-python">deleted_value = actors.pop('Джонни Депп', None) 
</code></pre>
<p>Если ключа 'Джонни Депп' в&nbsp;словаре нет, в&nbsp;<var>deleted_value</var> попадет None.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="5">Проверка наличия элемента в&nbsp;словаре</h2>
<p>Оператор <var>in</var>&nbsp;позволяет проверить, есть&nbsp;ли ключ в&nbsp;словаре:</p>
<pre><code class="language-python">if 'Джонни Депп' in actors:
    print('У нас есть статья про Джонни Деппа')
</code></pre>
<p>Проверить, что ключа нет, можно с&nbsp;помощью аналогичного оператора <code>not&nbsp;in</code>:</p>
<pre><code class="language-python">if 'Сергей Безруков' not in actors:
    print('У нас нет статьи о Сергее Безрукове')
</code></pre>
</section>
<section class="material__chapter">
<h2 id="6">Нестроковые ключи</h2>
<p>Решим следующую задачу. Пусть дан длинный список целых чисел <var>numbers</var>. Мы&nbsp;знаем, что некоторые числа встречаются в&nbsp;этом списке несколько раз. Нужно узнать, сколько именно раз встречается каждое из&nbsp;чисел.</p>
<pre><code class="language-python">numbers = [1, 10, 1, 6, 4, 10, 4, 2, 2, 1, 10, 1]
counts = {}
for number in numbers:
    if number not in counts:
        counts[number] = 1
    else:
        counts[number] += 1
</code></pre>
<p>Просто так сделать <code>counts[number] += 1</code>&nbsp;нельзя: если ключа <var>number</var> в&nbsp;словаре нет, возникнет ошибка KeyError.</p>
<p>В&nbsp;результате работы этой программы все элементы из&nbsp;списка <var>numbers</var> окажутся ключами словаря <var>counts</var>. Значением <code>counts[x]</code> будет количество раз, которое число <var>x</var>&nbsp;встретилось в&nbsp;списке <var>numbers</var>. Как это работает?</p>
<p>Цикл <var>for</var> перебирает все элементы списка <var>numbers</var> и&nbsp;для каждого проверяет, присутствует&nbsp;ли он&nbsp;уже в&nbsp;качестве ключа в&nbsp;<var>counts</var>. Если нет&nbsp;&mdash; значит, число встретилось нам впервые и&nbsp;мы&nbsp;инициализируем значение <code>counts[numbers] = 1</code>. Иначе увеличим <code>counts[number]</code> на&nbsp;единицу, поскольку число <var>number</var> встретилось нам повторно.</p>
<p>Почему для этой задачи не&nbsp;стоит использовать список, хотя ключи&nbsp;&mdash; обычные целые числа? Потому что, используя словарь, мы&nbsp;можем решить эту задачу и&nbsp;для вещественных чисел, и&nbsp;для очень больших целых чисел, и&nbsp;вообще для любых объектов, которые можно сравнивать.</p>
</section>
<section class="material__chapter">
<h2 id="7">Методы словарей</h2>
<p>Взять значение в&nbsp;словаре можно не&nbsp;только с&nbsp;помощью квадратных скобок, но&nbsp;и&nbsp;с&nbsp;помощью метода <var>get</var>:</p>
<pre><code class="language-python">article = actors.get('Джонни Депп')
</code></pre>
<p>Преимущество метода в&nbsp;том, что, кроме ключа, он&nbsp;может принимать и&nbsp;второй аргумент&nbsp;&mdash; значение, которое вернется, если заданного ключа нет:</p>
<pre><code class="language-python">article = actors.get('Джонни Депп', 'Статья о Джонни Деппа не найдена')
</code></pre>
<p>Воспользуемся этим приемом для улучшения нашей программы в&nbsp;задаче о&nbsp;повторяющихся числах:</p>
<pre><code class="language-python">numbers = [1, 10, 1, 6, 4, 10, 4, 2, 2, 1, 10, 1]
counts = {}
for number in numbers:
    counts[number] = counts.get(number, 0) + 1
</code></pre>
<p>Попробуйте понять, почему это работает верно.</p>
<p>Все ключи словаря можно перебрать циклом <var>for</var>:</p>
<pre><code class="language-python">for actor_name in actors:
    print(actor_name, actors[actor_name])
</code></pre>
<p>Другой способ сделать то&nbsp;же&nbsp;самое&nbsp;&mdash; вызвать метод <code>.keys()</code>:</p>
<pre><code class="language-python">for actor_name in actors.keys():
    print(actor_name, actors[actor_name])
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Метод .keys()</strong></p>
<p>С&nbsp;помощью метода <code>.keys()</code> можно получить список всех ключей словаря:</p>
<pre><code class="language-python">actors_names = list(actors.keys())
</code></pre>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Метод .values()</strong></p>
<p>Есть и&nbsp;парный метод <code>.values()</code>, возвращающий все значения словаря:</p>
<pre><code class="language-python">all_articles = list(actors.values())
</code></pre>
</section>
<p>Он&nbsp;позволяет, например, проверить, есть&nbsp;ли какое-нибудь значение <var>value</var> среди значений словаря:</p>
<pre><code class="language-python">value in d.values()
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Метод .items()</strong></p>
<p>Если вы&nbsp;хотите перебрать элементы словаря <var>d</var>&nbsp;так, чтобы в&nbsp;переменной <var>key</var> оказывался ключ, а&nbsp;в&nbsp;<var>value</var>&nbsp;&mdash; соответствующее ему значение, это можно сделать с&nbsp;помощью метода <code>.items()</code> и&nbsp;цикла <var>for</var>.</p>
<pre><code class="language-python">for key, val in d.items():
</code></pre>
</section>
<p>Например:</p>
<pre><code class="language-python">for actor_name, article in actors.items():
    print(actor_name, article)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="8">Допустимые типы ключей</h2>
<p>Мы&nbsp;уже выяснили, что ключами в&nbsp;словарях могут быть строки и&nbsp;целые числа. Кроме этого, ключами могут быть вещественные числа и&nbsp;кортежи.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Ключи в словаре</strong></p>
<p>Ключами в&nbsp;словаре не&nbsp;могут быть другие словари. В&nbsp;принципе в&nbsp;одном словаре могут быть ключи разных типов, однако обычно принято использовать однотипные ключи.</p>
<p>Вообще, есть строгий способ определить, может&nbsp;ли объект быть ключом в&nbsp;словаре. Для этого объект должен быть <strong>неизменяемым</strong>. Неизменяемые объекты не&nbsp;могут поменять значение в&nbsp;себе во&nbsp;время выполнения программы. Неизменяемыми в&nbsp;Python являются числа, строки и&nbsp;кортежи. Именно их&nbsp;обычно и&nbsp;используют в&nbsp;качестве ключей словарей.</p>
</section>
<p>Вот как может выглядеть словарь с&nbsp;ключами-кортежами. В&nbsp;качестве ключа используются координаты, а&nbsp;в&nbsp;качестве значения&nbsp;&mdash; название города.</p>
<pre><code class="language-python">cities = {
    (55.75, 37.5): 'Москва', 
    (59.8, 30.3): 'Санкт-Петербург', 
    (54.32, 48.39): 'Ульяновск'
}
print(cities[(55.75, 37.5)])
cities[(53.2, 50.15)] = 'Самара'
</code></pre>
<p>Возможно, нам захочется развернуть этот словарь, то&nbsp;есть построить такой, в&nbsp;котором ключами будут города, а&nbsp;значениями&nbsp;&mdash; их&nbsp;координаты.</p>
<pre><code class="language-python">coordinates = {}
for coordinate, city in cities.items():
    coordinates[city] = coordinate
</code></pre>
<p>Если в&nbsp;исходном словаре были повторяющиеся значения, некоторые из&nbsp;них потеряются при разворачивании словаря. Это объясняется тем, что значения в&nbsp;словаре могут повторяться, а&nbsp;вот ключи обязаны быть уникальными.</p>
<p>Значениями в&nbsp;словаре, в&nbsp;отличие от&nbsp;ключей, могут быть объекты любого типа&nbsp;&mdash; числа, строки, кортежи, списки и&nbsp;даже другие словари. Вот, например, как можно сохранить список фильмов для каждого из&nbsp;актеров:</p>
<pre><code class="language-python">films = {
  'Джонни Депп': [
      'Эдвард Руки-Ножницы', 
      'Одинокий рейнджер', 
      'Чарли и шоколадная фабрика', 
      ..],
  'Эмма Уотсон': [
      'Гарри Поттер и философский камень', 
      'Красавица и Чудовище', 
      ..],
  # ...
}

# Вывести список фильмов, в которых снималась Эмма Уотсон
print(films['Эмма Уотсон'])

# Проверить, снимался ли Джонни Депп в фильме &laquo;Чарли и шоколадная фабрика&raquo;
if 'Чарли и шоколадная фабрика' in films['Джонни Депп']:
    print('Снимался!')
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>