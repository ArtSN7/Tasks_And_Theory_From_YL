<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Проектирование и разработка классов. Часть 1 </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Классы № 1</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Проектирование и&nbsp;разработка классов. Часть&nbsp;1</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Введение</a></li>
<li><a class="material__link" href="#2">Подготовительный этап</a></li>
<li><a class="material__link" href="#3">Движение фигуры по&nbsp;пустой доске</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>На&nbsp;этом занятии мы&nbsp;коснемся обширной темы проектирования программ. Чем больше и&nbsp;сложнее программа, тем важнее еще до&nbsp;написания кода понять, что она должна делать и&nbsp;какова будет ее&nbsp;внутренняя структура.</p>
</section>
<section class="material__chapter">
<h2 id="1">Введение</h2>
<section class="material__note">
<p class="material__note-heading"><strong>Проектирование</strong></p>
<p>Этап определения внутренней структуры программы, разнесения функциональности между модулями (а&nbsp;затем и&nbsp;внутри модулей&nbsp;&mdash; между функциями, классами и&nbsp;методами) называется <strong>проектированием</strong>. Чем сложнее программа, тем больше возможностей придется рассмотреть при проектировании и&nbsp;тем важнее выбрать подходящий вариант. Результат проектирования должен быть внутренне непротиворечив, хорошо отражать логику предметной области и&nbsp;допускать дальнейшее развитие программы без перепроектирования.</p>
</section>
<p>Мы&nbsp;разберем проектирование программы для игры в&nbsp;шахматы. Программа предназначена для двух игроков, которые за&nbsp;одним компьютером будут по&nbsp;очереди делать ходы. Программа должна принимать только допустимые ходы и&nbsp;отображать на&nbsp;экране положение фигур после каждого хода с&nbsp;помощью псевдографики. Никакого искусственного интеллекта и&nbsp;возможности самостоятельно делать ходы от&nbsp;программы не&nbsp;требуется.</p>
<p>Можно было&nbsp;бы просто выбрать готовый вариант проектирования и&nbsp;приступить к&nbsp;поэтапной реализации каждого класса и&nbsp;метода. Однако в&nbsp;этом случае мы&nbsp;не&nbsp;смогли&nbsp;бы рассмотреть варианты и&nbsp;увидеть, что бывает, когда программа спроектирована некорректно и&nbsp;ее&nbsp;приходится перепроектировать на&nbsp;лету. Такое случается, когда требования к&nbsp;программе изменяются и&nbsp;уточняются в&nbsp;ходе ее&nbsp;написания.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Этапы проектирования программы</strong></p>
<p>Поэтому мы&nbsp;будем проектировать программу и&nbsp;сразу писать код, делая это в&nbsp;несколько этапов:</p>
<ul>
<li><strong>Подготовительный этап</strong>&nbsp;&mdash; цвет фигур, доска</li>
<li><strong>Движение фигуры по&nbsp;пустой доске</strong>&nbsp;&mdash; реализация класса доски и&nbsp;классов пешки и&nbsp;ладьи</li>
<li><strong>Движение фигуры по&nbsp;доске с&nbsp;другими фигурами</strong>&nbsp;&mdash; ферзь, ладья, слон и&nbsp;пешка (при ходе на&nbsp;две клетки) не&nbsp;должны иметь препятствий на&nbsp;пути</li>
<li><strong>Взятие фигуры другой фигурой</strong></li>
</ul>
</section>
<p>Мы&nbsp;не&nbsp;будем реализовывать взятие на&nbsp;проходе, рокировку, превращение пешки, запрет хода королем под шах и&nbsp;прочие сложные правила.</p>
</section>
<section class="material__chapter">
<h2 id="2">Подготовительный этап</h2>
<p>Для начала опишем цвет фигуры. От&nbsp;цвета нам нужно три операции: задание цвета фигуры, проверка цвета (черный или белый) и&nbsp;получение противоположного цвета.</p>
<p>Простейший способ описать цвет&nbsp;&mdash; определить две константы WHITE и&nbsp;BLACK и&nbsp;функцию, которая будет возвращать цвет, противоположный переданному.</p>
<pre><code class="language-python">WHITE = 1
BLACK = 2
 

# Удобная функция для вычисления цвета противника
def opponent(color):
    if color == WHITE:
        return BLACK
    return WHITE
 

# Инициализация цвета
color = WHITE
# Проверка цвета
if color == BLACK:
    do_something()
# сравнение цветов
color == other_color
# Цвет противника
opponent_color = opponent(color)
</code></pre>
<p>Обратите внимание: используются именно константы, а&nbsp;не&nbsp;строки <code>"white"</code> и&nbsp;<code>"black"</code>. Если допустить в&nbsp;такой строке опечатку (например, whte вместо white), выражение всегда будет ложным. Однако в&nbsp;случае <code>color == "whte"</code> программа просто будет тихонько работать неправильно, и&nbsp;ошибку придется поискать. Если&nbsp;же написать <code>color == WHTE</code>, интерпретатор прекратит работу, встретив неизвестное имя WHTE, и&nbsp;сразу укажет, в&nbsp;какой строке ошибка.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Обозначение констант в Python</strong></p>
<p>Переменные <var>BLACK</var> и&nbsp;<var>WHITE</var> названы в&nbsp;верхнем регистре, чтобы показать, что они фактически будут константами, т.&nbsp;е. мы&nbsp;не&nbsp;собираемся их&nbsp;изменять. Настоящих констант в&nbsp;Python нет, и&nbsp;<var>WHITE</var>&nbsp;&mdash; такая&nbsp;же переменная, как и&nbsp;любая другая, однако такие стандартные обозначения помогают писать и&nbsp;читать программы.</p>
</section>
<p>На&nbsp;этом варианте кода с&nbsp;константами <var>WHITE</var> и&nbsp;<var>BLACK</var> мы&nbsp;и&nbsp;остановимся в&nbsp;итоге. И&nbsp;все&nbsp;же&nbsp;давайте попробуем еще пару вариантов.</p>
<pre><code class="language-python"># Не здравый пример лишнего класса для цвета:
WHITE = 1
BLACK = 2
 

class PieceColor():
    def __init__(self, color):
        self.color = color
 
    def opponent(self):
        if self.color == WHITE:
            return PieceColor(BLACK)
        return PieceColor(WHITE)
 
    def is_black(self):
        return self.color == BLACK
 
    def is_white(self):
        return self.color == WHITE
 
    def __eq__(self, other):
        return self.color == other.color
 

# Инициализация цвета
color = PieceColor(WHITE)
# Проверка цвета
if color.is_black():
    do_something()
# сравнение цветов
color == other_color
# Цвет противника
opponent_color = color.opponent()
</code></pre>
<pre><code class="language-python"># Пример с отдельным классом для каждого цвета
class Black():
    def __eq__(self, other):
        # истина, если другой операнд оператора ==
        # тоже является экземпляром (англ. instance) класса Black
        return isinstance(other, Black)
 
    def opponent(self):
        return White()
 
    def is_black(self):
        return True
 
    def is_white(self):
        return False
 

class White():
    def __eq__(self, other):
        return isinstance(other, White)
 
    def opponent(self):
        return Black()
 
    def is_black(self):
        return False
 
    def is_white(self):
        return True
 

# Инициализация цвета
color = White()
# Проверка цвета
color.is_black()
# сравнение цветов
color == other_color
# Цвет противника
opponent_color = color.opponent()
</code></pre>
<p>Видно, что во&nbsp;втором варианте реализации цветов мы&nbsp;не&nbsp;смогли избавиться от&nbsp;констант <var>WHITE</var> и&nbsp;<var>BLACK</var>. В&nbsp;третьем вместо двух констант получились два класса, а&nbsp;код их&nbsp;использования прост и&nbsp;близок к&nbsp;человеческому языку. Однако все портит излишняя сложность классов <var>White</var> и&nbsp;<var>Black</var>. Возможно, в&nbsp;какой-то другой программе это было&nbsp;бы оправданно, однако здесь мы&nbsp;точно знаем постановку задачи и&nbsp;не&nbsp;будем &laquo;навешивать&raquo; на&nbsp;цвета фигур дополнительной функциональности. Поэтому остановимся на&nbsp;самом первом варианте с&nbsp;двумя константами и&nbsp;функцией.</p>
</section>
<section class="material__chapter">
<h2 id="3">Движение фигуры по&nbsp;пустой доске</h2>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-35/chess.svg" width="680" height="auto" /></div>
<p>На&nbsp;картинке желтым цветом показаны обозначения клеток, принятые в&nbsp;шахматах, а&nbsp;черным&nbsp;&mdash; индексы, которые будем использовать&nbsp;мы.</p>
<p>Давайте спроектируем шахматную доску и&nbsp;позволим одной фигуре ходить по&nbsp;ней. Пока будем считать, что других фигур нет, и&nbsp;взаимодействия с&nbsp;ними учитывать не&nbsp;будем.</p>
<p>Пока не&nbsp;очень понятно, какие у&nbsp;нас будут классы и&nbsp;методы. Очевидно, что нужно определить класс <var>Board</var> для доски и&nbsp;по&nbsp;классу для каждого типа фигуры. Но, как распределить между ними функциональность и&nbsp;кто будет отвечать за&nbsp;ходы и&nbsp;взятия фигур, пока неясно.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Проектирование &laquo;сверху вниз&raquo; и&nbsp;&laquo;снизу вверх&raquo;</strong></p>
<p>Здесь можно пойти двумя путями: проектировать и&nbsp;программировать <strong>сверху вниз</strong> или <strong>снизу вверх</strong>.</p>
<p>Проектирование <strong>сверху вниз</strong> идет от&nbsp;общего к&nbsp;частному: от&nbsp;интерфейса (набора методов для взаимодействия с&nbsp;объектами)&nbsp;&mdash; к&nbsp;деталям реализации. При движении <strong>снизу вверх</strong> сначала проектируются простые независимые классы и&nbsp;функции, а&nbsp;потом, на&nbsp;их&nbsp;основе, создаются более сложные классы и&nbsp;функции.</p>
</section>
<p>В&nbsp;начале урока мы&nbsp;написали код для цвета фигур, программируя снизу вверх. Однако сейчас мы&nbsp;плохо представляем, какой интерфейс должен быть у&nbsp;доски и&nbsp;фигур. Если мы&nbsp;попробуем реализовать эти классы сразу, есть риск, что при объединении в&nbsp;интерфейс пользователя мы&nbsp;не&nbsp;сумеем совместить их&nbsp;оптимальным образом. Поэтому сначала напишем интерфейс пользователя, чтобы понять, какие интерфейсы нам нужны от&nbsp;доски и&nbsp;фигур:</p>
<pre><code class="language-python">def print_board(board): # Распечатать доску в текстовом виде (см. скриншот)
    print('     +----+----+----+----+----+----+----+----+')
    for row in range(7, -1, -1):
        print(' ', row, end='  ')
        for col in range(8):
            print('|', board.cell(row, col), end=' ')
        print('|')
        print('     +----+----+----+----+----+----+----+----+')
    print(end='        ')
    for col in range(8):
        print(col, end='    ')
    print()
 

def main():
    # Создаём шахматную доску
    board = Board()
    # Цикл ввода команд игроков
    while True:
        # Выводим положение фигур на доске
        print_board(board)
        # Подсказка по командам
        print('Команды:')
        print('    exit                               -- выход')
        print('    move &lt;row&gt; &lt;col&gt; &lt;row1&gt; &lt;col1&gt;     -- ход из клетки (row, col)')
        print('                                          в клетку (row1, col1)')
        # Выводим приглашение игроку нужного цвета
        if board.current_player_color() == WHITE:
            print('Ход белых:')
        else:
            print('Ход черных:')
        command = input()
        if command == 'exit':
            break
        move_type, row, col, row1, col1 = command.split()
        row, col, row1, col1 = int(row), int(col), int(row1), int(col1)
        if board.move_piece(row, col, row1, col1):
            print('Ход успешен')
        else:
            print('Координаты некорректы! Попробуйте другой ход!')
</code></pre>
<p>Пример работы текстового интерфейса:</p>
<div class="material__content-positioner"><img class="material__illustration material__screenshot" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-35/chess-interface.png" width="680" height="auto" /></div>
<p>Теперь понятно, что от&nbsp;доски нам понадобится достаточно простой интерфейс: инициализация без аргументов; возможность определять цвет фигур текущего игрока; метод <var>cell</var>, возвращающий двубуквенное представление фигуры в&nbsp;клетке; и&nbsp;метод <var>move_piece</var>, перемещающий фигуру из&nbsp;одной клетки в&nbsp;другую. При этом метод <var>move_piece</var> должен возвращать истину, если ход сделан, и&nbsp;ложь, если по&nbsp;каким-то причинам ход невозможен.</p>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-35/chessscheme.svg" width="680" height="auto" /></div>
<p>Схема движения ладьи и&nbsp;пешки. Ладья движется по&nbsp;вертикали или горизонтали на&nbsp;любое количество клеток. Пешка&nbsp;&mdash; на&nbsp;одну или две клетки вперед из&nbsp;начального положения и&nbsp;на&nbsp;одну клетку не&nbsp;из&nbsp;начального положения.</p>
<p>Давайте реализуем этот класс:</p>
<pre><code class="language-python">def correct_coords(row, col):
    """Функция проверяет, что координаты (row, col) лежат
    внутри доски"""
    return 0 &lt;= row &lt; 8 and 0 &lt;= col &lt; 8


class Board:
    def __init__(self):
        self.color = WHITE
        self.field = []
        for row in range(8):
            self.field.append([None] * 8)
        # Пешка белого цвета в клетке E2.
        self.field[1][4] = Pawn(1, 4, WHITE)  

    def current_player_color(self):
        return self.color

    def cell(self, row, col):
        """Возвращает строку из двух символов. Если в клетке (row, col)
        находится фигура, символы цвета и фигуры. Если клетка пуста,
        то два пробела."""
        piece = self.field[row][col]
        if piece is None:
            return '  '
        color = piece.get_color()
        c = 'w' if color == WHITE else 'b'
        return c + piece.char()

    def move_piece(self, row, col, row1, col1):
        """Переместить фигуру из точки (row, col) в точку (row1, col1).
        Если перемещение возможно, метод выполнит его и вернет True.
        Если нет --- вернет False"""

        if not correct_coords(row, col) or not correct_coords(row1, col1):
            return False
        if row == row1 and col == col1:
            return False  # нельзя пойти в ту же клетку
        piece = self.field[row][col]
        if piece is None:
            return False
        if piece.get_color() != self.color:
            return False
        if not piece.can_move(row1, col1):
            return False
        self.field[row][col] = None  # Снять фигуру.
        self.field[row1][col1] = piece  # Поставить на новое место.
        piece.set_position(row1, col1)
        self.color = opponent(self.color)
        return True
</code></pre>
<p>В&nbsp;этом фрагменте кода мы&nbsp;определили функцию <var>correct_coords</var>, которая нужна для проверки корректности клетки, и&nbsp;класс <var>Board</var>, который отвечает за&nbsp;выбор фигуры и&nbsp;ее&nbsp;движение. Понятно и&nbsp;то, что от&nbsp;каждого класса фигур нам понадобится инициализатор с&nbsp;аргументом&nbsp;&mdash; цветом фигуры, методы <var>current_player_color</var>, <var>can_move</var> и&nbsp;<var>char</var>. Метод <var>current_player_color</var> должен возвращать цвет фигур текущего игрока, <var>can_move</var>&nbsp;&mdash; определять, может&nbsp;ли фигура данного класса пойти в&nbsp;клетку с&nbsp;заданными координатами, <var>char</var>&nbsp;&mdash; возвращать букву, обозначающую фигуру. У&nbsp;каждого класса фигуры будет своя реализация <var>can_move</var>, поэтому будет задействован полиморфизм.</p>
<p>Давайте для примера напишем реализации классов пешки и&nbsp;ладьи.</p>
<p><strong>Класс &laquo;Пешка&raquo;</strong></p>
<pre><code class="language-python">class Pawn:
 
    def __init__(self, row, col, color):
        self.row = row
        self.col = col
        self.color = color
 
    def set_position(self, row, col):
        self.row = row
        self.col = col
 
    def char(self):
        return 'P'
 
    def get_color(self):
        return self.color
 
    def can_move(self, row, col):
        # Пешка может ходить только по вертикали
        # "взятие на проходе" не реализовано
        if self.col != col:
            return False
 
        # Пешка может сделать из начального положения ход на 2 клетки
        # вперёд, поэтому поместим индекс начального ряда в start_row.
        if self.color == WHITE:
            direction = 1
            start_row = 1
        else:
            direction = -1
            start_row = 6
 
        # ход на 1 клетку
        if self.row + direction == row:
            return True
 
        # ход на 2 клетки из начального положения
        if self.row == start_row and self.row + 2 * direction == row:
            return True
 
        return False
</code></pre>
<p><strong>Класс &laquo;Ладья&raquo;</strong></p>
<pre><code class="language-python">class Rook:
 
    def __init__(self, row, col, color):
        self.row = row
        self.col = col
        self.color = color
 
    def set_position(self, row, col):
        self.row = row
        self.col = col
 
    def char(self):
        return 'R'
 
    def get_color(self):
        return self.color
 
    def can_move(self, row, col):
        # Невозможно сделать ход в клетку, которая не лежит в том же ряду
        # или столбце клеток.
        if self.row != row and self.col != col:
            return False
 
        return True
</code></pre>
<p>Вы&nbsp;наверняка обратили внимание, что написанные нами классы для фигур, имеют очень много общего. Это должно навести нас на&nbsp;мысль, что можно эффективно применить механизм наследования. Попробуйте написать этот код самостоятельно.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>