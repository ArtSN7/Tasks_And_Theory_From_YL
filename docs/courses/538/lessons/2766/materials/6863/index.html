<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Введение в ООП. Полиморфизм </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Полиморфизм</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Введение в&nbsp;ООП. Полиморфизм</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Полиморфизм</a></li>
<li><a class="material__link" href="#2">Проверка типа объекта</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>Сегодня мы&nbsp;рассмотрим возможности предоставления одинаковых средств взаимодействия с&nbsp;объектами разной природы.</p>
</section>
<section class="material__chapter">
<h2 id="1">Полиморфизм</h2>
<p>После предыдущего занятия мы&nbsp;уже немного разбираемся в&nbsp;объектно-ориентированном программировании: освоили определение классов и&nbsp;методов, добавление атрибутов в&nbsp;объекты. Понятно, что классы, объекты, методы, атрибуты достаточно удобны и&nbsp;красивы, но&nbsp;в&nbsp;чем их&nbsp;преимущество перед функциями? Ведь некоторые объекты можно было&nbsp;бы передавать в&nbsp;функции и&nbsp;выполнять над ними те&nbsp;же действия, что и&nbsp;с&nbsp;помощью методов. Зачем вводить дополнительный синтаксис и&nbsp;правила? Основное преимущество в&nbsp;том, что объектно-ориентированный подход позволяет писать код, который будет работать с&nbsp;экземплярами различных классов. Иногда код может даже работать с&nbsp;классами, которые еще не&nbsp;созданы.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Полиморфизм</strong></p>
<p>Свойство кода работать с&nbsp;разными типами данных называют <strong>полиморфизмом</strong>.</p>
<p>Мы&nbsp;уже неоднократно пользовались этим свойством многих функций и&nbsp;операторов, не&nbsp;задумываясь о&nbsp;нем. Например, оператор <code>+</code> является полиморфным:</p>
<pre><code class="language-python">print(1 + 2)          # 3
print(1.5 + 0.2)      # 1.7
print("abc" + "def")  # abcdef
</code></pre>
</section>
<p>Внутренняя реализация оператора <code>+</code> существенно отличается для целых чисел, чисел с&nbsp;плавающей точкой и&nbsp;строк. То&nbsp;есть на&nbsp;самом деле это три разные операции&nbsp;&mdash; интерпретатор Python выбирает одну из&nbsp;них при выполнении в&nbsp;зависимости от&nbsp;операндов. Впрочем, в&nbsp;нашем случае выбор очевиден, потому что операнды&nbsp;&mdash; просто константы.</p>
<p>Усложним задачу:</p>
<pre><code class="language-python">def f(x, y):
    return x + y
 

print(f(1, 2))          # 3
print(f(1.5, 0.2))      # 1.7
print(f("abc", "def"))  # abcdef
</code></pre>
<p>Перехитрить интерпретатор не&nbsp;удалось, ведь Python&nbsp;&mdash; язык с&nbsp;динамической типизацией. В&nbsp;таких языках любое значение несет в&nbsp;себе информацию о&nbsp;типе&nbsp;&mdash; она и&nbsp;помогла интерпретатору выбрать правильную реализацию операции <code>+</code> (а&nbsp;заодно и&nbsp;правильное строковое представление для функции <var>print</var>). Но&nbsp;мы&nbsp;знаем, что тип данных в&nbsp;Python&nbsp;&mdash; класс объекта, и&nbsp;именно эта информация о&nbsp;классе объекта используется при выборе операции. На&nbsp;следующем занятии мы&nbsp;вернемся к&nbsp;оператору <code>+</code> и&nbsp;рассмотрим, как реализовать его для наших собственных классов.</p>
<p>Давайте теперь вспомним про метод <var>__init__</var>. Он&nbsp;выполняется при создании каждого нового экземпляра класса и&nbsp;инициализирует свойства нового экземпляра. Первый аргумент, <var>self</var>, он&nbsp;получает от&nbsp;интерпретатора, остальные передаются классу в&nbsp;круглых скобках при создании экземпляра.</p>
<pre><code class="language-python">class Book:
    def __init__(self, name, author):
        self.name = name
        self.author = author
 
    def get_name(self):
        return self.name
 
    def get_author(self):
        return self.author
 

book = Book('Война и мир', 'Толстой Л. Н.')
print(f"{book.get_name()}, {book.get_author()})
# Война и мир, Толстой Л. Н.
</code></pre>
<p>При исполнении кода <code>book = Book('Война и мир', 'Толстой Л. Н.')</code> будет создан объект, у&nbsp;которого до&nbsp;момента присваивания ссылки на&nbsp;него переменной вызовется метод <var>__init__</var>, создающий атрибуты <var>name</var>, <var>author</var> и&nbsp;задающий им&nbsp;значения. Читать свойства можно из&nbsp;объекта напрямую (например, <var>book.name</var>) или использовать определенные для этого методы. Второй способ лучше, так как позволяет оградить программистов&nbsp;&mdash; пользователей класса от&nbsp;возможных изменений в&nbsp;реализации класса.</p>
<p>Теперь мы&nbsp;готовы определить свои собственные классы, с&nbsp;помощью которых будем разбираться с&nbsp;полиморфизмом.</p>
<p>Посмотрим на&nbsp;реализацию классов &laquo;Круг&raquo; и&nbsp;&laquo;Квадрат&raquo; для подсчета площади и&nbsp;периметра:</p>
<pre><code class="language-python">from math import pi

 
class Circle:
    def __init__(self, radius):
        self.radius = radius
 
    def area(self):
        return pi * self.radius ** 2
 
    def perimeter(self):
        return 2 * pi * self.radius
 

class Square:
    def __init__(self, side):
        self.side = side
 
    def area(self):
        return self.side * self.side
 
    def perimeter(self):
        return 4 * self.side
</code></pre>
<p>Мы&nbsp;определили классы <var>Circle</var> и&nbsp;<var>Square</var>, экземпляры которых могут считать площадь и&nbsp;периметр окружностей и&nbsp;квадратов. Важно, что у&nbsp;обоих классов одинаковый интерфейс: методы для расчета площади называются <var>area</var>, а&nbsp;для расчета периметра&nbsp;&mdash; <var>perimeter</var>. Кроме того, у&nbsp;этих методов одинаковое количество параметров (в&nbsp;данном случае только <var>self</var>), и&nbsp;они оба возвращают в&nbsp;результате работы число, хотя оно и&nbsp;может быть разного типа (целое и&nbsp;вещественное).</p>
<p>Теперь мы&nbsp;можем определить полиморфную функцию <var>print_shape_info</var>, которая будет печатать данные о&nbsp;фигуре:</p>
<pre><code class="language-python">def print_shape_info(shape):
    print(f"Area = {shape.area()}, perimeter = {shape.perimeter()}.")


square = Square(10)
print_shape_info(square)
# Area = 100, perimeter = 40.

circle = Circle(10)
print_shape_info(circle)
# Area = 314.1592653589793, perimeter = 62.83185307179586.
</code></pre>
<p>Если аргумент функции <var>print_shape_info</var>&nbsp;&mdash; экземпляр класса <var>Square</var>, выполняются методы, определенные в&nbsp;этом классе, если экземпляр <var>Circle</var>&nbsp;&mdash; методы <var>Circle</var>.</p>
<pre><code class="language-python">print(dir(square))  # Свойства и спецметоды экземпляра.
 
print(dir(Square))  # Свойства и спецметоды класса.
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Утиная типизация</strong></p>
<p>Данный код использует тот факт, что в&nbsp;Python принята так называемая <strong>утиная типизация</strong>. Название происходит от&nbsp;шутливого выражения &laquo;Если нечто выглядит как утка, плавает как утка и&nbsp;крякает как утка, это, вероятно, утка и&nbsp;есть&raquo;.</p>
</section>
<div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-31/3.svg" width="680" height="auto" /></div>
<p>В&nbsp;программах на&nbsp;Python это означает, что если какой-то объект поддерживает все требуемые от&nbsp;него операции, с&nbsp;ним и&nbsp;будут работать с&nbsp;помощью этих операций, не&nbsp;заботясь о&nbsp;том, какого он&nbsp;на&nbsp;самом деле типа. Так и&nbsp;наша функция <var>print_shape_info</var> будет выводить информацию о&nbsp;любом объекте, у&nbsp;которого есть методы <var>area</var> и&nbsp;<var>perimeter</var> (и&nbsp;у&nbsp;которых в&nbsp;списке параметров также будет указан один параметр <var>self</var>).</p>
<p>В&nbsp;языках без утиной типизации нам&nbsp;бы пришлось добавлять в&nbsp;программу интерфейс как отдельную сущность на&nbsp;уровне описания на&nbsp;языке программирования и&nbsp;указывать, что наши классы относятся к&nbsp;этому интерфейсу. В&nbsp;программах на&nbsp;Python этого делать не&nbsp;нужно, однако интерфейсы все равно существуют.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Чтобы полиморфизм работал, за&nbsp;ними надо следить как <strong>на&nbsp;уровне синтаксиса</strong> (одинаковые имена методов и&nbsp;количество параметров), так и&nbsp;<strong>на&nbsp;уровне смысла</strong> (методы с&nbsp;одинаковыми именами делают похожие операции, параметры методов имеют тот&nbsp;же смысл).</p>
</section>
<p>Давайте определим еще один класс с&nbsp;таким&nbsp;же интерфейсом, как у&nbsp;<var>Circle</var> и&nbsp;<var>Square</var>,&nbsp;&mdash; например, <var>Rectangle</var> (прямоугольник). Если мы&nbsp;все сделаем правильно, функция <var>print_shape_info</var> сможет работать с&nbsp;его экземплярами:</p>
<pre><code class="language-python">class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
 
    def area(self):
        return self.width * self.height
 
    def perimeter(self):
        return 2 * (self.width + self.height)
 

rect = Rectangle(10, 15)
print_shape_info(rect)  # Area = 150, perimeter = 50.
</code></pre>
<p>Еще раз обратите внимание: утиная типизация позволяет заранее написать функцию, которая будет работать со&nbsp;всеми экземплярами любых классов&nbsp;&mdash; даже еще не&nbsp;существующих. Важно лишь, чтобы эти классы поддерживали необходимый функции интерфейс.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>И&nbsp;небольшое замечание об&nbsp;инкапсуляции. Дело в&nbsp;том, что с&nbsp;самого начала обычно есть не&nbsp;два класса, как в&nbsp;нашем примере, а&nbsp;один. Пусть это будет <var>square</var>. Если не&nbsp;инкапсулировать внутри него свойство <var>side</var> и&nbsp;не&nbsp;определить заранее интерфейс для расчета площади и&nbsp;периметра, никакого полиморфизма не&nbsp;получится. Важно помнить о&nbsp;том, что инкапсуляция определяет понятие интерфейса класса и&nbsp;создает базу для полиморфизма.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="2">Проверка типа объекта</h2>
<p>При работе с&nbsp;объектами бывает необходимо в&nbsp;зависимости от&nbsp;их&nbsp;типа выполнить те&nbsp;или иные операции. И&nbsp;с&nbsp;помощью встроенной функции <code>isinstance()</code> мы&nbsp;можем проверить тип объекта.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функция isinstance</strong></p>
<p>Эта функция принимает два параметра: <code>isinstance(object, type)</code></p>
<p>Первый параметр представляет объект, а&nbsp;второй&nbsp;&mdash; тип, на&nbsp;принадлежность к&nbsp;которому выполняется проверка. Если объект представляет указанный тип, функция возвращает True.</p>
</section>
<pre><code class="language-python">for person in people:
    if isinstance(person, Student):
        print(person.university)
    elif isinstance(person, Employee):
        print(person.company)
    else:
        print(person.name)
    print()
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>