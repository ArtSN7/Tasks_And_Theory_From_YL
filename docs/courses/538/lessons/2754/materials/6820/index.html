<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Функции. Возвращение значений из функций </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Функции: return</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Функции. Возвращение значений из&nbsp;функций</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Связь между математическими функциями и&nbsp;функциями в&nbsp;Python</a></li>
<li><a class="material__link" href="#2">Возвращаемые значения</a></li>
<li><a class="material__link" href="#3">Множественные точки возврата из&nbsp;функции</a></li>
<li><a class="material__link" href="#4">Возврат из&nbsp;глубины функции</a></li>
<li><a class="material__link" href="#5">Отладка</a></li>
<li><a class="material__link" href="#6">Что можно возвращать из&nbsp;функции</a></li>
<li><a class="material__link" href="#7">Возврат нескольких значений</a></li>
<li><a class="material__link" href="#8">Аннотации типов</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке мы&nbsp;обсудим, почему функции называются функциями, чем они похожи и&nbsp;чем отличаются от&nbsp;функций в&nbsp;математике. И&nbsp;главное: мы&nbsp;разберемся с&nbsp;основной целью вызова функций&nbsp;&mdash; возвратом во&nbsp;внешнюю программу результата вычисления.</p>
</section>
<section class="material__chapter">
<h2 id="1">Связь между математическими функциями и&nbsp;функциями в&nbsp;Python</h2>
<p>Функции, которые мы&nbsp;писали до&nbsp;сих пор, выводили значение на&nbsp;экран. Однако значение, выведенное на&nbsp;экран, полезно только для человека. Сама программа никак не&nbsp;может его использовать. Если&nbsp;бы функции могли выводить результаты своей работы только на&nbsp;экран, их&nbsp;было&nbsp;бы&nbsp;почти невозможно комбинировать.</p>
<p>Каждая функция может не&nbsp;только выполнять действия, но&nbsp;и&nbsp;выдавать какой-то результат, который потом можно использовать в&nbsp;программе&nbsp;&mdash; например, записать в&nbsp;переменную. Вы&nbsp;еще не&nbsp;делали таких функций, но&nbsp;уже не&nbsp;раз пользовались ими. Попробуйте вспомнить несколько примеров.</p>
<p>Если вы&nbsp;посмотрите примеры таких функций, вы&nbsp;увидите среди них много математических... функций.</p>
<p>Функция в&nbsp;математике&nbsp;&mdash; такое преобразование, которое из&nbsp;одного значения или набора значений делает другое значение. Например, функция квадратного корня делает из&nbsp;числа его корень. Функция f(a,b) = (a+b)^2 делает из&nbsp;двух чисел квадрат их&nbsp;суммы. Фактически единственное важное свойство математической функции заключается в&nbsp;том, что каждому набору аргументов она сопоставляет значение, и&nbsp;каждый раз вычисление функции на&nbsp;одних и&nbsp;тех&nbsp;же аргументах дает один и&nbsp;тот&nbsp;же результат. Сколько&nbsp;бы раз вы&nbsp;ни&nbsp;вычисляли корень из&nbsp;шестнадцати, каждый раз будете получать четыре.</p>
<p>Заметьте: математическая функция не&nbsp;обязана работать с&nbsp;числами. Например, в&nbsp;математике можно встретить такую функцию&nbsp;&mdash; число перестановок букв в&nbsp;слове. Это функция, которая принимает аргументом строку, а&nbsp;возвращает число. Или функцию пересечения множеств, которая берет в&nbsp;качестве аргументов два множества и&nbsp;возвращает тоже множество.</p>
<p>Чем функции в&nbsp;программировании похожи и&nbsp;чем отличаются от&nbsp;функций в&nbsp;математике?</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функция в&nbsp;языке Python</strong></p>
<p>Функция в&nbsp;языке Python&nbsp;&mdash; некий алгоритм, который выполняется каждый раз одинаково. Для большинства функций возвращаемое значение, как и&nbsp;в&nbsp;случае математической функции, зависит только от&nbsp;аргументов.</p>
</section>
<p>У&nbsp;функций в&nbsp;Python, как вы&nbsp;знаете, тоже есть список аргументов: иногда одно значение, иногда несколько, а&nbsp;иногда он и&nbsp;вовсе пустой, как у&nbsp;функции <var>input</var>. У&nbsp;функций также есть возвращаемое значение&nbsp;&mdash; значение всегда ровно одно.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Может показаться, что некоторые функции ничего не&nbsp;возвращают (как функция <var>print</var>), но&nbsp;на&nbsp;самом деле они тоже возвращают значение&nbsp;&mdash; None.</p>
</section>
<p>В&nbsp;некоторых других языках программирования существуют функции, которые могут не&nbsp;возвращать значения, их&nbsp;называют &laquo;процедуры&raquo;.</p>
<p>Их&nbsp;отличие от&nbsp;математических функций в&nbsp;том, что функция в&nbsp;Python может зависеть не&nbsp;только от&nbsp;аргументов, но&nbsp;и&nbsp;от&nbsp;внешних причин. Что для функции может быть внешними причинами? Например, действия пользователя.</p>
<p>Функция <var>input</var>, помимо пустого списка аргументов, получает ввод с&nbsp;клавиатуры пользователя. Некоторые функции читают файлы на&nbsp;жестком диске или в&nbsp;Интернете, а&nbsp;значит, их&nbsp;результат зависит от&nbsp;содержимого файла или веб-страницы. Есть функции, работа которых зависит от&nbsp;текущего времени. Есть функции, зависящие от&nbsp;датчика случайных чисел.</p>
<p>Кроме того, работа некоторых функций зависит от&nbsp;внешних (глобальных) переменных (об&nbsp;этом мы&nbsp;будем говорить на&nbsp;следующем занятии). Это еще одна особенность функций в&nbsp;Python: они могут изменять что-то снаружи функции&nbsp;&mdash; менять глобальные переменные, выводить текст на&nbsp;экран, записывать что-то в&nbsp;файлы.</p>
<p>Таким образом, функции можно разделить на&nbsp;функции с&nbsp;побочными эффектами и&nbsp;без них.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функции без побочных эффектов</strong></p>
<p>Функции без побочных эффектов и&nbsp;использования внешних источников данных (их&nbsp;еще называют &laquo;чистые функции&raquo;) ведут себя в&nbsp;точности как математические функции. Их&nbsp;результат зависит только от&nbsp;аргументов, а&nbsp;вызов таких функций никак не&nbsp;влияет на&nbsp;ход остальной программы.</p>
</section>
<p>Большая часть известных вам встроенных функций Python ведет себя так: <var>math.sqrt</var>, <var>math.cos</var>, <var>abs</var>, <var>int</var>, <var>str</var>, <var>len</var>, <var>min</var>, <var>max</var>.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Функции с&nbsp;побочными эффектами</strong></p>
<p>Функции с&nbsp;побочными эффектами&nbsp;&mdash; как правило, функции, предназначенные для общения с&nbsp;&laquo;внешним миром&raquo;: пользователем, файлами на&nbsp;жестком диске, другими программами или серверами в&nbsp;Интернете. Пока что вы&nbsp;знаете две такие функции, встроенные в&nbsp;язык: <var>input</var> и&nbsp;<var>print</var>.</p>
</section>
<p>Побочные эффекты часто используются для изменения аргумента&nbsp;&mdash; как в&nbsp;методах <var>sort</var> и&nbsp;<var>reverse</var>, которые изменяют данные в&nbsp;списке.</p>
<p>Любая функция, которая использует <code>input()</code> или <code>print()</code>, тоже имеет побочные эффекты. И&nbsp;любая функция, которая изменяет значения внешних переменных, тоже имеет побочные эффекты. На&nbsp;следующем занятии мы&nbsp;отдельно поговорим о&nbsp;том, как функции с&nbsp;побочными эффектами могут влиять на&nbsp;глобальные переменные, а&nbsp;как делать чистые функции и&nbsp;работать с&nbsp;ними, мы&nbsp;начнем говорить сейчас.</p>
</section>
<section class="material__chapter">
<h2 id="2">Возвращаемые значения</h2>
<p>Для того чтобы функция вернула значение, используется оператор <var>return</var>. Использовать его очень просто. Давайте напишем функцию <var>double_it</var>, которая удваивает значение:</p>
<pre><code class="language-python">def double_it(x):
    return x * 2
</code></pre>
<p>Эта функция получила число <var>x</var>&nbsp;в&nbsp;качестве аргумента, умножила его на&nbsp;2&nbsp;и&nbsp;вернула результат в&nbsp;основную программу. Значением, которое функция вернула, можно воспользоваться. Например, мы&nbsp;можем посчитать длину окружности с&nbsp;использованием этой функции:</p>
<pre><code class="language-python">radius = 3
length = double_it(3.14) * radius
</code></pre>
<p>Когда интерпретатор дойдет до&nbsp;<code>double_it(3.14)</code>, начнет исполняться код функции. Когда он&nbsp;дойдет до&nbsp;слова <var>return</var>, значение, которое указано после <var>return</var>, будет подставлено в&nbsp;программе вместо вызова функции. Можно сказать, что сразу после того как функция досчитается, вычисление превратится в&nbsp;такое:</p>
<pre><code class="language-python">length = 6.28 * radius
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Заметьте: функция <var>double_it</var> ничего не&nbsp;выводит на&nbsp;экран. Она выполняет вычисления и&nbsp;сообщает их&nbsp;не&nbsp;пользователю, как мы&nbsp;делали раньше, а&nbsp;другой части программы.</p>
</section>
<p>Если нам потребуется не&nbsp;просто вернуть удвоенное число, а&nbsp;еще и&nbsp;вывести его на&nbsp;экран, лучше не&nbsp;добавлять <var>print</var> внутрь функции. Ведь если вы&nbsp;добавите <var>print</var> в&nbsp;функцию, уже никак не&nbsp;сможете вызвать эту функцию в&nbsp;&laquo;тихом&raquo; режиме, чтобы она ничего не&nbsp;печатала. Вместо этого лучше сначала вернуть результат, а&nbsp;потом уже распечатать его во&nbsp;внешней программе. Вот так:</p>
<pre><code class="language-python">print(double_it(3.14))
</code></pre>
<p>Или, если вам нужно еще как-то использовать вычисленное значение, можно завести специальную переменную, хранящую результат вычисления.</p>
<pre><code class="language-python">double_pi = double_it(3.14)
print(double_pi)
length = double_pi * radius
</code></pre>
<p>Функция удваивания числа, конечно, совершенно бесполезна.</p>
<p>А&nbsp;теперь давайте рассмотрим чуть более сложный пример&nbsp;&mdash; вычисление суммы элементов списка:</p>
<pre><code class="language-python">def my_sum(arr):
    result = 0
    for element in arr:
        result += element
    return result


print(my_sum([1, 2, 3, 4]))
</code></pre>
<p>Здесь мы&nbsp;используем очень распространенный способ написания функций: создаем вспомогательную переменную, а&nbsp;затем возвращаем ее&nbsp;значение.</p>
<p>Но&nbsp;мы&nbsp;ведь недавно говорили, что локальные переменные живут только внутри функции. Если переменная <var>result</var> исчезнет, почему результат&nbsp;&mdash; число 10&nbsp;&mdash; никуда не&nbsp;пропадает?</p>
<p>Объект (значение) может существовать, даже когда нет переменной, в&nbsp;которой он&nbsp;хранится. Когда мы&nbsp;записываем число в&nbsp;<var>result</var>, мы&nbsp;фактически создаем объект числа и&nbsp;даем ему временное имя <var>result</var>. Потом, когда мы&nbsp;пишем <code>return result</code>, мы&nbsp;возвращаем не&nbsp;переменную. Как и&nbsp;в&nbsp;большинстве конструкций языка (кроме, пожалуй, присваивания), вместо переменной подставляется ее&nbsp;значение: таким образом, мы&nbsp;возвращаем объект &laquo;число 10&raquo;. У&nbsp;этого объекта нет имени, что не&nbsp;мешает функции <var>print</var> использовать его и&nbsp;напечатать 10&nbsp;на экране (подробнее об&nbsp;этом мы&nbsp;поговорим, когда будем рассматривать, как передаются параметры в&nbsp;функции).</p>
<p>Однако, если ни&nbsp;программист, ни&nbsp;программа не&nbsp;имеют возможности пользоваться объектом, этот объект становится не&nbsp;нужен. После того как функция <var>print</var> отработала, доступ к&nbsp;результату вычисления пропал, ведь мы&nbsp;никуда не&nbsp;сохранили этот результат. На&nbsp;объект &laquo;число&nbsp;10&raquo; нет ссылок, поэтому интерпретатор может его &laquo;выкинуть&raquo;.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Сборка мусора</strong></p>
<p>Это называется &laquo;сборка мусора&raquo;: Python автоматически избавляется от&nbsp;всех объектов, которые невозможно использовать.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="3">Множественные точки возврата из&nbsp;функции</h2>
<p>Часто бывают ситуации, когда в&nbsp;зависимости от&nbsp;входных данных нужно выполнить различные наборы команд. Например, когда мы&nbsp;считаем модуль, в&nbsp;случае отрицательного числа нужно взять число со&nbsp;знаком минус, а&nbsp;в&nbsp;случае неотрицательного числа (положительное или ноль) мы&nbsp;берем само число.</p>
<p>Давайте запишем это в&nbsp;виде функции <code>my_abs(x)</code>.</p>
<pre><code class="language-python">def my_abs(x):
    if x &gt;= 0:
        result = x
    else:
        result = -x
    return result
</code></pre>
<p>Но&nbsp;если вдуматься: зачем ждать конца функции, когда мы&nbsp;уже вычислили результат и&nbsp;совершили все необходимые действия? Давайте завершим функцию сразу, ведь <var>return</var> именно для этого создан: он&nbsp;не&nbsp;только возвращает значение функции, но&nbsp;и&nbsp;возвращает нас из&nbsp;функции в&nbsp;основную программу. После вызова оператора <var>return</var> выполнение кода функции заканчивается. Раз так, давайте немного упростим программу. Сначала мы&nbsp;перенесем <var>return</var> к&nbsp;тому месту, где результат получен:</p>
<pre><code class="language-python">def my_abs(x):
    if x &gt;= 0:
        result = x
        return result
    else:
        result = -x
        return result
</code></pre>
<p>А&nbsp;теперь можно заметить, что переменная <var>result</var> лишняя: когда вы&nbsp;подставляете значение <var>result</var>, вместо <var>result</var> вы&nbsp;легко можете подставить сразу результат.</p>
<pre><code class="language-python">def my_abs(x):
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre>
<p>Можно обратить внимание, что в&nbsp;последней записи <var>else</var>-часть становится нам вообще не&nbsp;нужна, и&nbsp;тогда сократить функцию до&nbsp;вот такой:</p>
<pre><code class="language-python">def my_abs(x):
    if x &gt;= 0:
        return x
    return -x
</code></pre>
<p>Заметьте, что любую функцию можно написать с&nbsp;одним-единственным оператором <var>return</var>, но&nbsp;часто использовать несколько точек выхода из&nbsp;функции просто удобно.</p>
</section>
<section class="material__chapter">
<h2 id="4">Возврат из&nbsp;глубины функции</h2>
<p>Множественные точки возврата из&nbsp;функции позволяют нам упростить обработку и&nbsp;более сложных структур, например, вложенных списков. Наша следующая программа будет проверять, есть&nbsp;ли в&nbsp;матрице элемент, отличающийся от&nbsp;искомого не&nbsp;больше чем на&nbsp;число <var>eps</var>.</p>
<p>Матрица записывается как список списков. Мы&nbsp;предполагаем, что наша функция будет работать с&nbsp;большими матрицами, поэтому нам не&nbsp;хочется тратить лишнее время на&nbsp;проверку. Мы&nbsp;будем прекращать поиск, как только нашли подходящий элемент. Давайте для начала разберемся, как&nbsp;бы мы&nbsp;действовали без множественных операторов <var>return</var>.</p>
<pre><code class="language-python">def matrix_has_close_value(matrix, value, eps):
    found = False
    for row in matrix:
        for cell in row:
            if abs(cell - value) &lt;= eps:
                found = True
                break
        if found:
            break
    if found:
        return True
    else:
        return False
</code></pre>
<p>Как видите, нам приходится прилагать некоторые усилия, чтобы выйти из&nbsp;нескольких уровней вложенности. Каждый уровень вложенности&nbsp;&mdash; дополнительное препятствие на&nbsp;пути к&nbsp;завершению функции. Ему мешают не&nbsp;только циклы, как в&nbsp;этом примере, но&nbsp;и&nbsp;условные операторы.</p>
<p>Перепишем теперь функцию с&nbsp;учетом того, что, как только мы&nbsp;нашли элемент, мы&nbsp;уже знаем, что ответ&nbsp;&mdash; True (т.&nbsp;е. элемент содержится в&nbsp;матрице). А&nbsp;если мы&nbsp;закончили перебор элементов и&nbsp;так и&nbsp;не&nbsp;нашли ни&nbsp;одного элемента, ответ False.</p>
<pre><code class="language-python">def matrix_has_close_value(matrix, value, eps):
    for row in matrix:
        for cell in row:
            if abs(cell - value) &lt;= eps:
                return True
    return False
</code></pre>
<p>Хотя <code>return False</code> не&nbsp;заключен ни&nbsp;в&nbsp;какое условие, выполняется он&nbsp;только тогда, когда элемент не&nbsp;найден. Если элемент найден, мы&nbsp;сразу выходим из&nbsp;функции и&nbsp;до&nbsp;этой строки просто не&nbsp;доходим. Оператор <var>return</var> очень удобен, когда нужно выйти из&nbsp;глубины функции.</p>
</section>
<section class="material__chapter">
<h2 id="5">Отладка</h2>
<p>В&nbsp;PyCharm процесс отладки аналогичен тому, как он&nbsp;происходил в&nbsp;Wing IDE. Для создания/удаления точки останова, надо кликнуть на&nbsp;левое поле рядом со&nbsp;строчкой кода, где мы&nbsp;хотим остановиться в&nbsp;режиме отладки. Запустить программу в&nbsp;режиме отладки можно несколькими способами:</p>
<ol>
<li>Из&nbsp;пункта меню Run&nbsp;&rarr;&nbsp;Debug &lt;имя файла с&nbsp;программой&gt;.</li>
<li>Из&nbsp;меню быстрых действий&nbsp;&mdash; кнопка с&nbsp;жуком над кодом в&nbsp;правом верхнем углу.</li>
<li>Кликнув правой кнопкой мышки в&nbsp;любом месте нашего файла и&nbsp;выбрав в&nbsp;выпадающем меню пункт Debug &lt;имя файла с&nbsp;программой&gt;.</li>
<li>Используя сочетание клавиш Shift + F9.</li>
</ol>
<p>После того как программа запустится в&nbsp;режиме отладки, в&nbsp;нижней части программы откроется уже привычная консоль, но&nbsp;только перед выводом самой программы в&nbsp;нее выведется надпись вроде</p>
<pre><code>pydev debugger: process 20924 is connecting
</code></pre>
<p>а&nbsp;затем</p>
<pre><code>#Connected to pydev debugger (build 191.7479.30)#
</code></pre>
<p>Эти надписи говорят, что отладчик сначала попытался &laquo;прицепиться&raquo; к&nbsp;нашей программе, а&nbsp;потом&nbsp;&mdash; что он&nbsp;преуспел в&nbsp;этом и&nbsp;готов работать.</p>
<p>После остановки на&nbsp;брейкпоинте и&nbsp;в&nbsp;процессе дальнейшей отладки вам, как и&nbsp;в&nbsp;Wing IDE, будет доступен просмотр текущих значений переменных во&nbsp;вкладке Debugger в&nbsp;нижней части окна PyCharm. Приятным отличием от&nbsp;Wing является&nbsp;то, что текущие значения переменных пишутся еще и&nbsp;в&nbsp;коде в&nbsp;том месте, где они были объявлены.</p>
<p>Давайте проследим последовательность выполнения команд в&nbsp;отладчике. Запустим следующий код:</p>
<pre><code class="language-python">def matrix_has_close_value(matrix, value, eps):
    for row in matrix:
        for cell in row:
            if abs(cell - value) &lt;= eps:
                return True
    return False


table = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
result = matrix_has_close_value(table, 3.75, 0.5)
print(result)
</code></pre>
<p>Будем выполнять инструкции по&nbsp;одной с&nbsp;помощью команды Step Into (F7). Сначала будет определена функция <var>matrix_has_close_value</var>. На&nbsp;этом шаге интерпретатор Python в&nbsp;нее еще не&nbsp;заходит. Затем мы&nbsp;определяем переменную <var>table</var>, и&nbsp;она появляется на&nbsp;вкладке Stack data в&nbsp;разделе глобальных переменных. Затем мы&nbsp;запускаем функцию и&nbsp;попадаем внутрь нее.</p>
<p>Обратите внимание: появились локальные переменные <var>matrix</var>, <var>value</var> и&nbsp;<var>eps</var>. Причем <var>matrix</var> указывает ровно туда&nbsp;же, куда указывает <var>table</var> (у&nbsp;них одинаковый идентификатор 0x&lt;...&gt;). На&nbsp;прошлых занятиях мы&nbsp;обсуждали, что объект, который был подставлен в&nbsp;аргумент получает новое имя&nbsp;&mdash; в&nbsp;нашем случае <var>matrix</var>, но&nbsp;старое имя тоже остается, потому что переменная <var>table</var> находится в&nbsp;глобальной области видимости.</p>
<p>Если продолжить выполнение, пройдет несколько итераций цикла, пока мы&nbsp;не&nbsp;дойдем до&nbsp;момента, когда элемент в&nbsp;ячейке (число&nbsp;4) c&nbsp;точностью до&nbsp;<code>eps(=0.5)</code> совпадет со&nbsp;значением <code>value(=3.75)</code>, которое мы&nbsp;ищем. На&nbsp;этом месте мы&nbsp;перейдем на&nbsp;строчку <code>return True</code> и&nbsp;следующим шагом выйдем из&nbsp;функции.</p>
<p>После того как мы&nbsp;вышли из&nbsp;функции, возвращенное значение True будет записано в&nbsp;переменную <var>result</var>, которая появится в&nbsp;списке глобальных. Затем эта переменная будет подставлена в&nbsp;функцию <var>print</var> и&nbsp;напечатана.</p>
<p>Что мы&nbsp;видим? Во-первых, у&nbsp;нас есть возможность пронаблюдать, что происходит с&nbsp;объектами и&nbsp;переменными. Во-вторых, слово <var>return</var> действительно моментально завершает функцию и&nbsp;перемещает нас к&nbsp;строке, в&nbsp;которой мы&nbsp;вызвали функцию. И, конечно, возвращает результат.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Step Into</strong></p>
<p>Для пошаговой отладки мы&nbsp;пользовались командой Step Into. Она так называется, поскольку заставляет отладчик зайти в&nbsp;функцию (если это возможно) и&nbsp;показывать мельчайшие детали исполнения кода функции.</p>
</section>
<p>Бывает, что заходить в&nbsp;функцию незачем: вы&nbsp;в&nbsp;ней уверены и&nbsp;ничего не&nbsp;собираетесь менять. Или в&nbsp;ней слишком много команд, которые не&nbsp;просмотреть. Или решили отложить ее&nbsp;отладку на&nbsp;будущее.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Step Over Statement</strong></p>
<p>На&nbsp;этот случай в&nbsp;отладчике предусмотрена команда Step Over Statement (F8). При ее&nbsp;применении функция все равно будет вызвана, но&nbsp;отладчик не&nbsp;покажет вам подробности исполнения. Он&nbsp;просто дождется, пока функция завершит свою работу, вернет результат и&nbsp;переведет вас на&nbsp;следующую строчку после вызова функции.</p>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Step Out</strong></p>
<p>Иногда бывает нужно также выйти из&nbsp;функции. Например, когда вы&nbsp;зашли в&nbsp;нее отладчиком случайно или когда вы&nbsp;все в&nbsp;ней уже понимаете. В&nbsp;таких случаях вам поможет команда Step Out (Shift + F8). Она продолжает выполнение, пока не&nbsp;встретит return, выполняет его и&nbsp;оказывается за&nbsp;пределами функции.</p>
</section>
<section class="material__note">
<p class="material__note-heading"><strong>Resume Program</strong></p>
<p>Если вы&nbsp;посмотрели то, что хотели, в&nbsp;режиме отладки и&nbsp;хотите, чтобы выполнение программы продолжилось далее в&nbsp;обычном режиме (или до&nbsp;следующего брейкпоинта), удобно воспользоваться командой Resume Program (F9).</p>
</section>
<p><strong>Задание.</strong> Поэкспериментируйте с&nbsp;отладчиком:</p>
<ul>
<li>С&nbsp;помощью пошаговой отладки узнайте, что произойдет, если вместо второго аргумента подставить значение, которого нет в&nbsp;матрице?</li>
</ul>
<ul>
<li>Сравните списки локальных и&nbsp;глобальных переменных до&nbsp;того, как мы&nbsp;входим в&nbsp;функцию. Что происходит со&nbsp;списком глобальных переменных, когда мы&nbsp;входим в&nbsp;функцию? Что происходит со&nbsp;списком локальных переменных?</li>
</ul>
<ul>
<li>Узнайте, как будут изменяться переменные при входе в&nbsp;функцию (следите за&nbsp;идентификаторами объектов), если завести еще одну глобальную переменную с&nbsp;именем <var>matrix</var>?</li>
</ul>
<ul>
<li>Что произойдет, если, находясь в&nbsp;функции, присвоить что-нибудь переменной <var>table</var>?</li>
</ul>
<ul>
<li>А&nbsp;что если, находясь в&nbsp;функции, попробовать изменить какой-нибудь элемент в&nbsp;<var>table</var>?</li>
</ul>
<ul>
<li>Разберитесь с&nbsp;отличиями между Step Into, Step Out и&nbsp;Step Over. В&nbsp;каких ситуациях они работают, а&nbsp;в&nbsp;каких нет?</li>
</ul>
<p>Не&nbsp;бойтесь испортить функцию! Изменяйте ее&nbsp;как угодно, лишь&nbsp;бы можно было понять, как ведет себя интерпретатор Python в&nbsp;сложных ситуациях.</p>
</section>
<section class="material__chapter">
<h2 id="6">Что можно возвращать из&nbsp;функции</h2>
<p>В&nbsp;функциях, которые не&nbsp;возвращают значение, тоже можно использовать <var>return</var>. Если написать <var>return</var> без аргументов, функция просто сразу завершит свою работу (без <var>return</var> функция завершает работу, когда выполнит последнюю команду).</p>
<p>Как мы&nbsp;уже упоминали, результат возвращает любая функция, даже если в&nbsp;ней нет слова <var>return</var>. Результатом такой функции будет None.</p>
<p>Если в&nbsp;функции использован <var>return</var> без аргументов, это фактически эквивалентно <code>return None</code>.</p>
</section>
<section class="material__chapter">
<h2 id="7">Возврат нескольких значений</h2>
<p>В&nbsp;задаче про корни квадратного уравнения у&nbsp;нас уже возникала необходимость вернуть несколько значений. Вы&nbsp;видели, что это можно сделать, вернув список значений.</p>
<p>То&nbsp;же самое можно сделать немного проще: если после <var>return</var> написать несколько значений через запятую, Python автоматически поместит эти значения в&nbsp;кортеж и&nbsp;вернет этот кортеж.</p>
<pre><code class="language-python">def get_coordinates():
    return 1, 2


print(get_coordinates())
# =&gt; (1, 2)
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Команда возврата нескольких значений</p>
<pre><code class="language-python">return 1, 2
</code></pre>
<p>практически идентична команде возврата кортежа с&nbsp;этими значениями</p>
<pre><code class="language-python">return (1, 2)
</code></pre>
</section>
<p>Вы&nbsp;можете пользоваться любой, как вам больше нравится.</p>
<p>Мы&nbsp;разобрались, как возвращать значения из&nbsp;функции. Но&nbsp;как программа их&nbsp;получает, когда значений несколько? Оказывается, есть несколько способов. Один вариант вы&nbsp;знаете, можно записать в&nbsp;переменную весь кортеж:</p>
<pre><code class="language-python">def get_coordinates():
    return 1, 2


result = get_coordinates()
print(result)
# =&gt; (1, 2)
</code></pre>
<p>Можно вместо этого воспользоваться множественным присваиванием, тогда значения автоматически будут распределены по&nbsp;разным переменным:</p>
<pre><code class="language-python">x, y = get_coordinates()
print(x) # =&gt; 1
print(y) # =&gt; 2
</code></pre>
<p>Обратите внимание: <var>get_coordinates</var> в&nbsp;обоих случаях&nbsp;&mdash; одна и&nbsp;та&nbsp;же функция, которая используется немного по-разному.</p>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Когда в&nbsp;функции используется несколько операторов <var>return</var>, позаботьтесь о&nbsp;том, чтобы каждый из&nbsp;операторов возвращал однотипные наборы значений. Ведь вызывающая функция заранее не&nbsp;знает, какой из&nbsp;операторов <var>return</var> выполнится, а&nbsp;значит, мы&nbsp;не&nbsp;сможем использовать множественное присваивание в&nbsp;полную силу.</p>
</section>
<p>В&nbsp;следующей функции (это, конечно, бесполезная функция, она нужна только для иллюстрации) мы&nbsp;не&nbsp;последовали этому совету и&nbsp;возвращаем координаты то&nbsp;на&nbsp;плоскости, то&nbsp;в&nbsp;трехмерном пространстве.</p>
<pre><code class="language-python">def get_coordinates(index):
    if index % 2 == 0:
        return 1.5, 2.5
    else:
        return 1.5, 2.5, 0
</code></pre>
<p>Теперь вызов&nbsp;<code>x, y = get_coordinates()</code> будет ломаться на&nbsp;нечетных индексах, а&nbsp;<code>x, y, z = get_coordinates()</code> &mdash; на&nbsp;четных индексах. В&nbsp;итоге мы&nbsp;не&nbsp;сможем записать ни&nbsp;один из&nbsp;вариантов так, чтобы он&nbsp;не&nbsp;сломался при каких-нибудь условиях.</p>
<p>Вы&nbsp;уже видели, как локальные переменные помогают интерпретатору Python не&nbsp;запутаться в&nbsp;именах переменных. Но&nbsp;не&nbsp;всегда бывает просто понять, что за&nbsp;переменная используется в&nbsp;функции: собственная локальная переменная или чужая&nbsp;&mdash; из&nbsp;внешней программы. Чтобы разобраться в&nbsp;этих тонкостях, на&nbsp;следующем занятии мы&nbsp;очень подробно обсудим, что такое область видимости переменных.</p>
</section>
<section class="material__chapter">
<h2 id="8">Аннотация типов</h2>
<p>Python&nbsp;&mdash; язык с&nbsp;динамической типизацией. Это означает, что типы связаны со&nbsp;значением переменной, а&nbsp;не&nbsp;с&nbsp;ней самой. Переменные могут принимать любое значение в&nbsp;любой момент и&nbsp;проверяются только перед выполнением операций над ними.</p>
<p>Однако, при написании кода, мы&nbsp;так или иначе предполагаем переменные каких типов будут использоваться (это может быть вызвано ограничением алгоритма или логики). Для корректной работы программы нам важно как можно раньше найти ошибки, связанные с&nbsp;передачей данных неверного типа.</p>
<p>Аннотации типов&nbsp;&mdash; это новая возможность, описанная в&nbsp;PEP484, которая позволяет добавлять подсказки о&nbsp;типах переменных. Они используются, чтобы информировать читателя кода, каким должен быть тип переменной.</p>
<p>Аннотации типов не&nbsp;влияют на&nbsp;время выполнения программы. Эти подсказки игнорируются интерпретатором и&nbsp;используются исключительно для повышения удобочитаемости для других программистов и&nbsp;вас самих. Аннотации типов поддерживаются многими IDE для Python, которые выделяют некорректный код или выдают подсказки в&nbsp;процессе набора текста.</p>
<p>Для создания аннотированных переменных можно использовать один из&nbsp;способов:</p>
<pre><code class="language-python">count = 5 # type: int
count: int; count = 5
count: int = 5
</code></pre>
<p>В&nbsp;первой строке тип переменной указываем в&nbsp;комментариях. В&nbsp;двух других строках тип переменной указываем в&nbsp;коде, через двоеточие от&nbsp;имени переменной и&nbsp;дальше двумя разными способами задаем значение переменной.</p>
<p>Для аннотирования списоков, кортежей, словарей и&nbsp;множеств используют имена классов.</p>
<pre><code class="language-python">my_list: list
my_tuple: tuple
my_dic: dict
my_set: set
</code></pre>
<p>Такое аннотирование не&nbsp;слишком информативно, поскольку не&nbsp;показывает, какого типа элементы содержатся внутри.</p>
<p>Что бы показать тип элементов его указывают внутри квадратных скобок:</p>
<pre><code class="language-python">my_list: list[int]
my_tuple: tuple[str, float, float]
my_dic: dict[str, int]
my_set: set[str]
</code></pre>
<p>Удобнее всего использовать аннотации типов при описании функции: можно указать типы аргументов и&nbsp;тип ожидаемого результата&nbsp;или что-то одно. Аргумент аннотируется через двоеточие после имени, а&nbsp;возвращаемое значение через -&gt; после имени и&nbsp;аргументов функции.</p>
<pre><code class="language-python">def double_it(x: int) -&gt; int:
    return x * 2


def get_coordinates() -&gt; tuple:
    return 1, 2


def greet_all(names: list[str]) -&gt; None:
    for name in names:
        print("Hello", name)
</code></pre>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>