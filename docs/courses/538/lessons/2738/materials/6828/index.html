<!-- Generated by https://github.com/rodion-gudz/YandexLyceumDocs -->

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Учебник | Знакомство с циклом while </title>
    <link rel="stylesheet" href="/css/client.css"/>
	<link rel="stylesheet" href="/css/material.css">
	<link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
	<div class="lesson-material">
		<div class="layout">
			<div class="layout__wrapper layout__wrapper_type_narrow layout__wrapper_fixed">
				<main class="layout__main">
					<div class="lesson-material__wrapper">
						<a class="nav-tab nav-tab_back nav-tab_view_button" href="../..">
						<span data-lego="react"
						      class="icon icon_type_arrow-short icon_direction_left icon_size_s nav-tab__arrow-icon"></span>
							<span class="nav-tab__inner">Урок Цикл while</span>
						</a>
						<section class="lesson-material__content">
							<article class="material"><h1>Знакомство с&nbsp;циклом while</h1>
<section class="material__plan"><nav>
<ol>
<li><a class="material__link" href="#1">Цикл while</a></li>
<li><a class="material__link" href="#2">Составной оператор присваивания</a></li>
<li><a class="material__link" href="#3">Сигнал остановки</a></li>
<li><a class="material__link" href="#4">Подсчет количества элементов, удовлетворяющих условию</a></li>
<li><a class="material__link" href="#5">Поиск максимума и&nbsp;минимума</a></li>
</ol>
</nav></section>
<section class="material__annotation">
<h2>Аннотация</h2>
<p>В&nbsp;этом уроке мы&nbsp;познакомимся с&nbsp;оператором цикла <var>while</var>. Цикл позволяет организовать многократное повторение одних и&nbsp;тех&nbsp;же действий. Кроме того, мы&nbsp; сделаем акцент вот на&nbsp;чем: в&nbsp;одной и&nbsp;той&nbsp;же строчке программы на&nbsp;разных итерациях цикла переменные могут иметь разное значение.</p>
</section>
<section class="material__chapter">
<h2 id="1">Цикл while</h2>
<p>Сегодня мы&nbsp;научимся повторять заданные действия несколько раз. Для этого существуют операторы циклов. Мы&nbsp;разберем оператор цикла <var>while</var>. Он&nbsp;выполняет блок кода, <strong>пока истинно</strong> какое-то условие.</p>
<p>Напомним, условный оператор <var>if</var>&nbsp;проверяет условие&nbsp;и, в&nbsp;зависимости от&nbsp;того, истинно оно или ложно, выполняет либо не&nbsp;выполняет следующий записанный с&nbsp;отступом блок. После этого программа в&nbsp;любом случае выполняется дальше (там еще может быть <var>elif</var> или <var>else</var>, но&nbsp;сути это не&nbsp;меняет).</p>
<section class="material__note">
<p class="material__note-heading"><strong>Цикл while</strong></p>
<p>Оператор <var>while</var> (&laquo;пока&raquo;) тоже проверяет условие и&nbsp;тоже, в&nbsp;случае его истинности, выполняет следующий блок кода (<strong>тело цикла</strong>). Однако после выполнения этого блока кода выполняется не&nbsp;то, что идет после него, а&nbsp;снова проверяется условие, записанное после <var>while</var>.</p>
</section>
<p>Ведь при выполнении тела цикла значения каких-то переменных могли измениться&nbsp;&mdash; в&nbsp;результате условие цикла может уже не&nbsp;быть истинным. Если условие все еще истинно, тело цикла выполняется снова. Как только условие цикла перестало выполняться (в&nbsp;том числе если оно с&nbsp;самого начала не&nbsp;было выполнено), программа идёт дальше&nbsp;&mdash; выполняются команды, записанные после тела цикла.</p>
<p>Условие цикла записывается как и&nbsp;для <var>if</var>: с&nbsp;помощью операций отношения (<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code>, <code>==</code>). Cложные условия можно составлять с&nbsp;помощью логических операций <var>not</var>, <var>and</var>, <var>or</var>.</p>
<p>Действия, расположенные в&nbsp;теле цикла (блок кода), записываются со&nbsp;смещением вправо на&nbsp;четыре пробела относительно начала слова <var>while</var>. Переменные, входящие в&nbsp;условие, должны на&nbsp;момент проверки условия цикла иметь значения.</p>
<pre><code class="language-python">while условие:
    блок кода (тело цикла)
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Один шаг цикла (выполнение тела цикла) еще называют <strong>итерацией</strong>.</p>
<p>Используйте цикл <var>while</var> всегда, когда какая-то часть кода должна выполниться несколько раз, причем невозможно заранее сказать, сколько именно.</p>
</section>
<p>Давайте посмотрим программу, в&nbsp;которой цикл будет выполняться, пока не&nbsp;введут число, меньшее или равное&nbsp;0:</p>
<pre><code class="language-python">number = int(input())
while number &gt; 0:
    print('Вы ввели положительное число! Вводите дальше.')
    number = int(input())
    print('Так-так, что тут у нас...')
print('Вы ввели отрицательное число или ноль. Всё.')
</code></pre>
<p>Разберемся, как будет работать эта программа.</p>
<p>Сначала выполняется первая строчка: <code>number = int(input())</code> &mdash; пользователь вводит целое число. (Мы&nbsp;предполагаем, что пользователь действительно ввел число, и&nbsp;программа не&nbsp;вылетела с&nbsp;ошибкой.) Предположим, он&nbsp;ввел число 10. Оно записано в&nbsp;переменной <var>number</var>.</p>
<p>Выполняется вторая строчка: <code>while number &gt; 0</code>: &mdash;&nbsp;&laquo;пока number &gt; 0&raquo;&nbsp;&mdash; здесь проверяется, выполнено&nbsp;ли условие <code>number &gt; 0</code>. Поскольку мы&nbsp;предположили, что <var>number</var> в&nbsp;этот момент равно&nbsp;10, тогда условие выполнено, поэтому дальше выполняется блок, записанный с&nbsp;отступом,&nbsp;&mdash; тело цикла.</p>
<p>Третья строчка программы выводит на&nbsp;экран строку, тут все понятно.</p>
<p>Четвертая строчка вновь считывает с&nbsp;клавиатуры число и&nbsp;сохраняет его в&nbsp;переменную <var>number</var>. Пусть пользователь ввел&nbsp;2.</p>
<p>Когда выполнение программы доходит до&nbsp;конца тела цикла, происходит возврат к&nbsp;заголовку цикла (второй строчке программы) и&nbsp;повторная проверка условия. Поскольку <code>2 &gt; 0</code>, снова выполняется тело цикла.</p>
<p>Третья строчка снова выводит на&nbsp;экран сообщение, четвертая строчка снова считывает число (пусть это будет число&nbsp;3), пятая строчка снова выводит на&nbsp;экран сообщение...</p>
<p>Закончив тело цикла, опять проверяем условие в&nbsp;заголовке. <var>number</var> равно 3, <code>3 &gt; 0</code>, поэтому продолжаем.</p>
<p>Третья строчка опять выводит на&nbsp;экран сообщение, четвертая строчка опять считывает число. Пусть теперь это будет &minus;1. Обратите внимание: переменная <var>number</var> на&nbsp;каждой итерации цикла приобретает новое значение! Пятая строчка опять выводит на&nbsp;экран сообщение...</p>
<p>Вновь вернувшись на&nbsp;вторую строчку, получаем, что <code>&minus;1 &gt; 0</code>&nbsp;&mdash; ложно. Поэтому цикл завершается, тело цикла больше не&nbsp;выполняется, прыгаем сразу на&nbsp;следующую после цикла строчку программы&nbsp;&mdash; шестую. Она выводит последнее сообщение.</p>
<p>Все.</p>
</section>
<section class="material__chapter">
<h2 id="2">Составной оператор присваивания</h2>
<p>Напомним, что в&nbsp;операторе присваивания одно и&nbsp;то&nbsp;же имя переменной может стоять и&nbsp;справа (в&nbsp;составе какого-то выражения), и&nbsp;слева. В&nbsp;этом случае сначала вычисляется правая часть со&nbsp;старым значением переменной, после чего результат становится новым значением этой переменной. Ни&nbsp;в&nbsp;коем случае не&nbsp;воспринимайте такой оператор присваивания как уравнение!</p>
<pre><code class="language-python">number = int(input())  # например, 5
number = number + 1  # тогда здесь number становится равным 6
print(number)
</code></pre>
<section class="material__note">
<p class="material__note-heading"><strong>Важно!</strong></p>
<p>Для конструкций вида <code>number = number + 1</code> существует и сокращенная форма записи оператора присваивания: <code>number += 1</code>. Аналогично оператор <code>x = x + y</code>&nbsp;можно записать как <code>x += y</code>, оператор <code>x = x * y</code>&nbsp;&mdash; как <code>x *= y</code>, и&nbsp;так для любого из&nbsp;семи арифметических действий.</p>
</section>
</section>
<section class="material__chapter">
<h2 id="3">Сигнал остановки</h2>
<p>Рассмотрим такую задачу: пользователь вводит числа. Пусть это будут цены на&nbsp;купленные в&nbsp;магазине товары, а&nbsp;наша программа&nbsp;&mdash; часть программного обеспечения кассового аппарата. Ввод "&minus;1"&nbsp;&mdash; сигнал остановки. Нужно сосчитать сумму всех введенных чисел (сумму чека).</p>
<p>Поскольку требуется повторить нечто (ввод очередной цены) неизвестное количество раз, потребуется цикл <var>while</var>. Нам понадобится как минимум две переменные: <var>price</var> для цены очередного товара и&nbsp;<var>total</var>&nbsp;&mdash; для общей суммы.</p>
<p>Если&nbsp;бы мы&nbsp;знали точно, что пользователю надо купить ровно три товара, цикл (и&nbsp;ввод &minus;1 как условие его прерывания) был&nbsp;бы не&nbsp;нужен. Тогда программа могла&nbsp;бы выглядеть так:</p>
<pre><code class="language-python">total = 0
price = float(input())
total = total + price 
price = float(input())
total = total + price 
price = float(input())
total = total + price
print('Сумма введённых чисел равна', total)
</code></pre>
<p>Обратите внимание: мы&nbsp;назвали переменные осмысленно. Это очень облегчит жизнь программисту, который будет читать наш код позже, даже если это будете вы&nbsp;сами неделю спустя. Однако интерпретатор Python к&nbsp;этому факту совершенно равнодушен. Чтобы значения переменных соответствовали названиям и&nbsp;тому смыслу, который мы&nbsp;в&nbsp;них закладываем, нужно поддерживать переменные в&nbsp;актуальном состоянии. И&nbsp;только&nbsp;вы, программист, можете это сделать.</p>
<p>С&nbsp;переменной <var>price</var> все относительно понятно: ее&nbsp;значение обновляется при считывании с&nbsp;клавиатуры на&nbsp;каждой итерации цикла, как это делалось во&nbsp;многих других задачах. <var>total</var> сначала равно нулю: до&nbsp;начала ввода цен их&nbsp;сумма, конечно, ноль. Однако значение переменной <var>total</var> устаревает каждый раз, когда пользователь вводит цену очередного товара. Поэтому нам нужно прибавить к&nbsp;значению <var>total</var> только что введенную цену, чтобы эта переменная по-прежнему обозначала сумму цен всех купленных товаров.</p>
<p>Если&nbsp;бы мы&nbsp;хотели сократить запись, можно было&nbsp;бы организовать цикл, который выполнился&nbsp;бы ровно три раза. Для этого нам потребуется переменная-счетчик, которая внутри цикла будет считать каждую итерацию цикла. А&nbsp;условием выхода обозначим выполнение нужного количества итераций:</p>
<pre><code class="language-python">count = 0
total = 0
while count &lt; 3:
    price = float(input())
    total = total + price
    count = count + 1
print('Сумма введённых чисел равна', total)
</code></pre>
<p>Обратите внимание: <var>total</var> и&nbsp;<var>count</var> должны обнуляться до&nbsp;цикла.</p>
<p>Однако у&nbsp;нас в&nbsp;задаче количество товаров неизвестно, поэтому понадобится цикл до&nbsp;ввода сигнала остановки (&minus;1). С&nbsp;учетом сказанного выше программа будет выглядеть так:</p>
<pre><code class="language-python">total = 0
print('Вводите цены; для остановки введите -1.')
price = float(input())
while price &gt; 0:
    total = total + price  # можно заменить на аналогичную запись 
    # total += price
    price = float(input())
print('Общая стоимость равна', total)
</code></pre>
</section>
<section class="material__chapter">
<h2 id="4">Подсчет количества элементов, удовлетворяющих условию</h2>
<p>А&nbsp;теперь рассмотрим еще одну задачу.</p>
<p>Пользователь вводит целые числа. Ввод чисел прекращается, если введено число&nbsp;0. Необходимо определить, сколько чисел среди введенных оканчивались на&nbsp;2&nbsp;и&nbsp;были кратны числу&nbsp;4. Теперь нам надо проверять последовательность чисел.</p>
<p>Для каждого введенного числа надо делать проверку, соответствует&nbsp;ли оно условию. Если оно подходит под условие, увеличиваем счетчик таких чисел.</p>
<p>И&nbsp;уже после цикла, когда остановился ввод чисел, выводим результат&nbsp;&mdash; посчитанное количество нужных чисел.</p>
<pre><code class="language-python">count = 0
number = int(input())
while number != 0:
    if number % 10 == 2 and number % 4 == 0:
        count += 1
    number = int(input())
print('Количество искомых чисел:', count)
</code></pre>
<p>Обратите внимание: до&nbsp;цикла необходимо задать начальное значение для переменной <var>count</var>. Ведь когда придет первое подходящее под условие число, у&nbsp;нас <var>count</var> будет увеличиваться на&nbsp;1 относительно предыдущего значения. А&nbsp;значит, это значение должно быть задано.</p>
<p>Давайте посмотрим, как будет работать эта программа для последовательности чисел: 12, 3, 32, 14, 0.</p>
<div class="material__content-positioner">
<table style="border-collapse: collapse;" border="1" cellpadding="5px">
<thead>
<tr>
<th>Шаг</th>
<th>Действие</th>
<th>Пояснение</th>
<th>Цикл</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>count = 0</code></td>
<td><code>count = 0</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>2</td>
<td><code>number = int(input())</code></td>
<td><code>number = 12</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>3</td>
<td><code>while number != 0:</code></td>
<td><code>12 != 0</code> (Истина)</td>
<td>Вход в&nbsp;цикл, 1-я&nbsp;итерация</td>
</tr>
<tr>
<td>4</td>
<td><code>if number % 10 == 2 and number % 4 == 0:</code></td>
<td><code>12 % 10 == 2 and 12 % 4 == 0</code> (Истина)</td>
<td>Заходим в&nbsp;if</td>
</tr>
<tr>
<td>5</td>
<td><code>count += 1</code></td>
<td><code>count = 1</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>6</td>
<td><code>number = int(input())</code></td>
<td><code>number = 3</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>7</td>
<td><code>while number != 0:</code></td>
<td><code>3 != 0</code> (Истина)</td>
<td>2-я&nbsp;итерация</td>
</tr>
<tr>
<td>8</td>
<td><code>if number % 10 == 2 and number % 4 == 0:</code></td>
<td><code>3 % 10 == 2 and 3 % 4 == 0</code> (Ложь)</td>
<td>Пропускаем if</td>
</tr>
<tr>
<td>9</td>
<td><code>number = int(input())</code></td>
<td><code>number = 32</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>10</td>
<td><code>while number != 0:</code></td>
<td><code>32 != 0</code> (Истина)</td>
<td>3-я&nbsp;итерация</td>
</tr>
<tr>
<td>11</td>
<td><code>if number % 10 == 2 and number % 4 == 0:</code></td>
<td><code>32 % 10 == 2 and 32 % 4 == 0</code> (Истина)</td>
<td>Заходим в&nbsp;if</td>
</tr>
<tr>
<td>12</td>
<td><code>count += 1</code></td>
<td><code>count = 2</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>13</td>
<td><code>number = int(input())</code></td>
<td><code>number = 14</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>14</td>
<td><code>while number != 0:</code></td>
<td><code>14 != 0</code> (Истина)</td>
<td>4-я&nbsp;итерация</td>
</tr>
<tr>
<td>15</td>
<td><code>if number % 10 == 2 and number % 4 == 0:</code></td>
<td><code>14 % 10 == 2 and 14 % 4 == 0</code> (Ложь)</td>
<td>Пропускаем if</td>
</tr>
<tr>
<td>16</td>
<td><code>number = int(input())</code></td>
<td><code>number = 0</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>17</td>
<td><code>while number != 0:</code></td>
<td><code>0 != 0</code> (Ложь)</td>
<td>Выход из&nbsp;цикла</td>
</tr>
<tr>
<td>18</td>
<td><code>print('Количество искомых чисел:', count)</code></td>
<td>Вывод вычисленного <var>count</var></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
<section class="material__chapter">
<h2 id="5">Поиск максимума и&nbsp;минимума</h2>
<p>Очень часто в&nbsp;задачах приходится использовать различные статистические алгоритмы: поиск максимума, минимума, среднего значения, медианы и&nbsp;моды чисел, главный из&nbsp;которых&nbsp;&mdash; определение максимального и&nbsp;минимального значений на&nbsp;множестве данных.</p>
<p>Рассмотрим алгоритм в&nbsp;общем виде.</p>
<ol>
<li>Заведем отдельную переменную для хранения максимума и&nbsp;минимума. В&nbsp;качестве начального значения можно задать:
<ul>
<li>Заведомо малое для анализируемых данных значения, для максимума это будет совсем маленькое число: например, если мы&nbsp;вычисляем максимальный балл за&nbsp;экзамен, можно взять <code>maximum = 0</code>, тогда гарантированно произойдет замена максимума. Минимуму&nbsp;же, наоборот, присваивается заведомо большое значение</li>
<li>Первый элемент данных</li>
</ul>
</li>
<li>В&nbsp;теле цикла каждый подходящий элемент данных обрабатывается операторами по&nbsp;принципу:
<ul>
<li>Если текущий элемент больше максимума, меняем максимум</li>
<li>Если текущий элемент меньше минимума, заменяем минимум</li>
</ul>
</li>
</ol>
<p>Рассмотрим пример. Витя анализировал список литературы и&nbsp;решил, что хочет начать с&nbsp;самой большой по&nbsp;объему книги. Напишем программу, которая поможет мальчику определить, сколько страниц ему предстоит прочитать. Витя последовательно вводит количество страниц каждой книги из&nbsp;списка, а&nbsp;окончанием ввода служит ввод любого отрицательного числа&nbsp;(или&nbsp;0).</p>
<pre><code class="language-python">biggest_book = 0
n = int(input())
while n &gt; 0:
    if n &gt; biggest_book:
        biggest_book = n
    n = int(input())
print(biggest_book)
</code></pre>
<p>Так как книга не&nbsp;может содержать в&nbsp;себе 0&nbsp;страниц, для значения максимума мы&nbsp;можем взять&nbsp;0.</p>
<p>После этого Витя начинает вводить количество страниц: например, он&nbsp;вводит&nbsp;148. <code>148 &gt; 0</code>&nbsp;&mdash; условие цикла выполняется, и&nbsp;мы&nbsp;переходим к&nbsp;операции сравнения. На&nbsp;данном шаге <code>148 &gt; 0</code>, значит, <code>biggest_book = 148</code>. Снова считываем число.</p>
<p>Предположим, теперь введено 120. <code>120 &gt; 0</code>&nbsp;&mdash; продолжаем работать в&nbsp;цикле.&nbsp;<code>120 &gt; 148</code>&nbsp;&mdash; условие не&nbsp;выполняется, переходим к&nbsp;вводу новых данных, <var>biggest_book</var> все еще равен 148.</p>
<p>В&nbsp;этот раз мальчик ввел 486, мы&nbsp;заходим в&nbsp;цикл <code>486 &gt; 148</code>, производим замену <code>biggest_book = 486</code>. Продолжаем ввод. И&nbsp;так далее до&nbsp;тех пор пока не&nbsp;будет введено отрицательное число или&nbsp;0.</p>
<p>При решении задачи мы&nbsp;можем использовать особенность языка Python&nbsp;3.8&nbsp;&mdash; моржовый оператор или, как его еще называют, &laquo;оператор-морж&raquo; (из&nbsp;за&nbsp;ассоциации обозначения оператора <code>:=</code> c&nbsp;животным). Моржовый оператор позволяет присвоить значение переменной в&nbsp;условии <code>if</code> или <code>while</code>. Используя его, можно записать нашу программу следующим образом:</p>
<pre><code class="language-python">biggest_book = 0
while (n := int(input())) &gt; 0:
    if n &gt; biggest_book:
        biggest_book = n
print(biggest_book)
</code></pre>
<p>В&nbsp;этой программе значение переменной <var>n</var> задается один раз, в&nbsp;условии цикла, в&nbsp;отличие от&nbsp;ее&nbsp;предыдущей версии.</p>
</section></article>
						</section>
					</div>
				</main>
			</div>
		</div>
<footer class="footer">
	<div class="footer__controls">
		<a rel="noopener noreferrer" target="_blank" class="footer__help-link"
		   href="https://yandex.ru/legal/lms_termsofuse/">Terms of use</a>
	</div>
	<div class="footer__copyright">
		<div>
			<div class="Markdown">
				<div class="paragraph">Generated by <a rel="noopener noreferrer" target="_blank"
				                                       class="footer__help-link"
				                                       href="https://github.com/rodion-gudz/YandexLyceumDocs">Yandex Lyceum Docs</a>
				</div>
			</div>
		</div>
	</div>
</footer>	</div>
	<script src="/js/prism.js"></script>
</body>
</html>